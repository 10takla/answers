/*! For license information please see main.8632da1640c21657f67f.js.LICENSE.txt */
(()=>{var e,t,n={98:function(e,t){var n="undefined"!=typeof self?self:this,r=function(){function e(){this.fetch=!1,this.DOMException=n.DOMException}return e.prototype=n,new e}();!function(e){!function(t){var n="URLSearchParams"in e,r="Symbol"in e&&"iterator"in Symbol,s="FileReader"in e&&"Blob"in e&&function(){try{return new Blob,!0}catch(e){return!1}}(),l="FormData"in e,o="ArrayBuffer"in e;if(o)var a=["[object Int8Array]","[object Uint8Array]","[object Uint8ClampedArray]","[object Int16Array]","[object Uint16Array]","[object Int32Array]","[object Uint32Array]","[object Float32Array]","[object Float64Array]"],i=ArrayBuffer.isView||function(e){return e&&a.indexOf(Object.prototype.toString.call(e))>-1};function p(e){if("string"!=typeof e&&(e=String(e)),/[^a-z0-9\-#$%&'*+.^_`|~]/i.test(e))throw new TypeError("Invalid character in header field name");return e.toLowerCase()}function u(e){return"string"!=typeof e&&(e=String(e)),e}function c(e){var t={next:function(){var t=e.shift();return{done:void 0===t,value:t}}};return r&&(t[Symbol.iterator]=function(){return t}),t}function d(e){this.map={},e instanceof d?e.forEach((function(e,t){this.append(t,e)}),this):Array.isArray(e)?e.forEach((function(e){this.append(e[0],e[1])}),this):e&&Object.getOwnPropertyNames(e).forEach((function(t){this.append(t,e[t])}),this)}function f(e){if(e.bodyUsed)return Promise.reject(new TypeError("Already read"));e.bodyUsed=!0}function g(e){return new Promise((function(t,n){e.onload=function(){t(e.result)},e.onerror=function(){n(e.error)}}))}function h(e){var t=new FileReader,n=g(t);return t.readAsArrayBuffer(e),n}function v(e){if(e.slice)return e.slice(0);var t=new Uint8Array(e.byteLength);return t.set(new Uint8Array(e)),t.buffer}function m(){return this.bodyUsed=!1,this._initBody=function(e){var t;this._bodyInit=e,e?"string"==typeof e?this._bodyText=e:s&&Blob.prototype.isPrototypeOf(e)?this._bodyBlob=e:l&&FormData.prototype.isPrototypeOf(e)?this._bodyFormData=e:n&&URLSearchParams.prototype.isPrototypeOf(e)?this._bodyText=e.toString():o&&s&&(t=e)&&DataView.prototype.isPrototypeOf(t)?(this._bodyArrayBuffer=v(e.buffer),this._bodyInit=new Blob([this._bodyArrayBuffer])):o&&(ArrayBuffer.prototype.isPrototypeOf(e)||i(e))?this._bodyArrayBuffer=v(e):this._bodyText=e=Object.prototype.toString.call(e):this._bodyText="",this.headers.get("content-type")||("string"==typeof e?this.headers.set("content-type","text/plain;charset=UTF-8"):this._bodyBlob&&this._bodyBlob.type?this.headers.set("content-type",this._bodyBlob.type):n&&URLSearchParams.prototype.isPrototypeOf(e)&&this.headers.set("content-type","application/x-www-form-urlencoded;charset=UTF-8"))},s&&(this.blob=function(){var e=f(this);if(e)return e;if(this._bodyBlob)return Promise.resolve(this._bodyBlob);if(this._bodyArrayBuffer)return Promise.resolve(new Blob([this._bodyArrayBuffer]));if(this._bodyFormData)throw new Error("could not read FormData body as blob");return Promise.resolve(new Blob([this._bodyText]))},this.arrayBuffer=function(){return this._bodyArrayBuffer?f(this)||Promise.resolve(this._bodyArrayBuffer):this.blob().then(h)}),this.text=function(){var e,t,n,r=f(this);if(r)return r;if(this._bodyBlob)return e=this._bodyBlob,n=g(t=new FileReader),t.readAsText(e),n;if(this._bodyArrayBuffer)return Promise.resolve(function(e){for(var t=new Uint8Array(e),n=new Array(t.length),r=0;r<t.length;r++)n[r]=String.fromCharCode(t[r]);return n.join("")}(this._bodyArrayBuffer));if(this._bodyFormData)throw new Error("could not read FormData body as text");return Promise.resolve(this._bodyText)},l&&(this.formData=function(){return this.text().then(w)}),this.json=function(){return this.text().then(JSON.parse)},this}d.prototype.append=function(e,t){e=p(e),t=u(t);var n=this.map[e];this.map[e]=n?n+", "+t:t},d.prototype.delete=function(e){delete this.map[p(e)]},d.prototype.get=function(e){return e=p(e),this.has(e)?this.map[e]:null},d.prototype.has=function(e){return this.map.hasOwnProperty(p(e))},d.prototype.set=function(e,t){this.map[p(e)]=u(t)},d.prototype.forEach=function(e,t){for(var n in this.map)this.map.hasOwnProperty(n)&&e.call(t,this.map[n],n,this)},d.prototype.keys=function(){var e=[];return this.forEach((function(t,n){e.push(n)})),c(e)},d.prototype.values=function(){var e=[];return this.forEach((function(t){e.push(t)})),c(e)},d.prototype.entries=function(){var e=[];return this.forEach((function(t,n){e.push([n,t])})),c(e)},r&&(d.prototype[Symbol.iterator]=d.prototype.entries);var y=["DELETE","GET","HEAD","OPTIONS","POST","PUT"];function b(e,t){var n,r,s=(t=t||{}).body;if(e instanceof b){if(e.bodyUsed)throw new TypeError("Already read");this.url=e.url,this.credentials=e.credentials,t.headers||(this.headers=new d(e.headers)),this.method=e.method,this.mode=e.mode,this.signal=e.signal,s||null==e._bodyInit||(s=e._bodyInit,e.bodyUsed=!0)}else this.url=String(e);if(this.credentials=t.credentials||this.credentials||"same-origin",!t.headers&&this.headers||(this.headers=new d(t.headers)),this.method=(r=(n=t.method||this.method||"GET").toUpperCase(),y.indexOf(r)>-1?r:n),this.mode=t.mode||this.mode||null,this.signal=t.signal||this.signal,this.referrer=null,("GET"===this.method||"HEAD"===this.method)&&s)throw new TypeError("Body not allowed for GET or HEAD requests");this._initBody(s)}function w(e){var t=new FormData;return e.trim().split("&").forEach((function(e){if(e){var n=e.split("="),r=n.shift().replace(/\+/g," "),s=n.join("=").replace(/\+/g," ");t.append(decodeURIComponent(r),decodeURIComponent(s))}})),t}function k(e,t){t||(t={}),this.type="default",this.status=void 0===t.status?200:t.status,this.ok=this.status>=200&&this.status<300,this.statusText="statusText"in t?t.statusText:"OK",this.headers=new d(t.headers),this.url=t.url||"",this._initBody(e)}b.prototype.clone=function(){return new b(this,{body:this._bodyInit})},m.call(b.prototype),m.call(k.prototype),k.prototype.clone=function(){return new k(this._bodyInit,{status:this.status,statusText:this.statusText,headers:new d(this.headers),url:this.url})},k.error=function(){var e=new k(null,{status:0,statusText:""});return e.type="error",e};var x=[301,302,303,307,308];k.redirect=function(e,t){if(-1===x.indexOf(t))throw new RangeError("Invalid status code");return new k(null,{status:t,headers:{location:e}})},t.DOMException=e.DOMException;try{new t.DOMException}catch(e){t.DOMException=function(e,t){this.message=e,this.name=t;var n=Error(e);this.stack=n.stack},t.DOMException.prototype=Object.create(Error.prototype),t.DOMException.prototype.constructor=t.DOMException}function j(e,n){return new Promise((function(r,l){var o=new b(e,n);if(o.signal&&o.signal.aborted)return l(new t.DOMException("Aborted","AbortError"));var a=new XMLHttpRequest;function i(){a.abort()}a.onload=function(){var e,t,n={status:a.status,statusText:a.statusText,headers:(e=a.getAllResponseHeaders()||"",t=new d,e.replace(/\r?\n[\t ]+/g," ").split(/\r?\n/).forEach((function(e){var n=e.split(":"),r=n.shift().trim();if(r){var s=n.join(":").trim();t.append(r,s)}})),t)};n.url="responseURL"in a?a.responseURL:n.headers.get("X-Request-URL");var s="response"in a?a.response:a.responseText;r(new k(s,n))},a.onerror=function(){l(new TypeError("Network request failed"))},a.ontimeout=function(){l(new TypeError("Network request failed"))},a.onabort=function(){l(new t.DOMException("Aborted","AbortError"))},a.open(o.method,o.url,!0),"include"===o.credentials?a.withCredentials=!0:"omit"===o.credentials&&(a.withCredentials=!1),"responseType"in a&&s&&(a.responseType="blob"),o.headers.forEach((function(e,t){a.setRequestHeader(t,e)})),o.signal&&(o.signal.addEventListener("abort",i),a.onreadystatechange=function(){4===a.readyState&&o.signal.removeEventListener("abort",i)}),a.send(void 0===o._bodyInit?null:o._bodyInit)}))}j.polyfill=!0,e.fetch||(e.fetch=j,e.Headers=d,e.Request=b,e.Response=k),t.Headers=d,t.Request=b,t.Response=k,t.fetch=j,Object.defineProperty(t,"__esModule",{value:!0})}({})}(r),r.fetch.ponyfill=!0,delete r.fetch.polyfill;var s=r;(t=s.fetch).default=s.fetch,t.fetch=s.fetch,t.Headers=s.Headers,t.Request=s.Request,t.Response=s.Response,e.exports=t},679:(e,t,n)=>{"use strict";var r=n(864),s={childContextTypes:!0,contextType:!0,contextTypes:!0,defaultProps:!0,displayName:!0,getDefaultProps:!0,getDerivedStateFromError:!0,getDerivedStateFromProps:!0,mixins:!0,propTypes:!0,type:!0},l={name:!0,length:!0,prototype:!0,caller:!0,callee:!0,arguments:!0,arity:!0},o={$$typeof:!0,compare:!0,defaultProps:!0,displayName:!0,propTypes:!0,type:!0},a={};function i(e){return r.isMemo(e)?o:a[e.$$typeof]||s}a[r.ForwardRef]={$$typeof:!0,render:!0,defaultProps:!0,displayName:!0,propTypes:!0},a[r.Memo]=o;var p=Object.defineProperty,u=Object.getOwnPropertyNames,c=Object.getOwnPropertySymbols,d=Object.getOwnPropertyDescriptor,f=Object.getPrototypeOf,g=Object.prototype;e.exports=function e(t,n,r){if("string"!=typeof n){if(g){var s=f(n);s&&s!==g&&e(t,s,r)}var o=u(n);c&&(o=o.concat(c(n)));for(var a=i(t),h=i(n),v=0;v<o.length;++v){var m=o[v];if(!(l[m]||r&&r[m]||h&&h[m]||a&&a[m])){var y=d(n,m);try{p(t,m,y)}catch(e){}}}}return t}},418:e=>{"use strict";var t=Object.getOwnPropertySymbols,n=Object.prototype.hasOwnProperty,r=Object.prototype.propertyIsEnumerable;function s(e){if(null==e)throw new TypeError("Object.assign cannot be called with null or undefined");return Object(e)}e.exports=function(){try{if(!Object.assign)return!1;var e=new String("abc");if(e[5]="de","5"===Object.getOwnPropertyNames(e)[0])return!1;for(var t={},n=0;n<10;n++)t["_"+String.fromCharCode(n)]=n;if("0123456789"!==Object.getOwnPropertyNames(t).map((function(e){return t[e]})).join(""))return!1;var r={};return"abcdefghijklmnopqrst".split("").forEach((function(e){r[e]=e})),"abcdefghijklmnopqrst"===Object.keys(Object.assign({},r)).join("")}catch(e){return!1}}()?Object.assign:function(e,l){for(var o,a,i=s(e),p=1;p<arguments.length;p++){for(var u in o=Object(arguments[p]))n.call(o,u)&&(i[u]=o[u]);if(t){a=t(o);for(var c=0;c<a.length;c++)r.call(o,a[c])&&(i[a[c]]=o[a[c]])}}return i}},448:(e,t,n)=>{"use strict";var r=n(294),s=n(418),l=n(840);function o(e){for(var t="https://reactjs.org/docs/error-decoder.html?invariant="+e,n=1;n<arguments.length;n++)t+="&args[]="+encodeURIComponent(arguments[n]);return"Minified React error #"+e+"; visit "+t+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}if(!r)throw Error(o(227));var a=new Set,i={};function p(e,t){u(e,t),u(e+"Capture",t)}function u(e,t){for(i[e]=t,e=0;e<t.length;e++)a.add(t[e])}var c=!("undefined"==typeof window||void 0===window.document||void 0===window.document.createElement),d=/^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,f=Object.prototype.hasOwnProperty,g={},h={};function v(e,t,n,r,s,l,o){this.acceptsBooleans=2===t||3===t||4===t,this.attributeName=r,this.attributeNamespace=s,this.mustUseProperty=n,this.propertyName=e,this.type=t,this.sanitizeURL=l,this.removeEmptyString=o}var m={};"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach((function(e){m[e]=new v(e,0,!1,e,null,!1,!1)})),[["acceptCharset","accept-charset"],["className","class"],["htmlFor","for"],["httpEquiv","http-equiv"]].forEach((function(e){var t=e[0];m[t]=new v(t,1,!1,e[1],null,!1,!1)})),["contentEditable","draggable","spellCheck","value"].forEach((function(e){m[e]=new v(e,2,!1,e.toLowerCase(),null,!1,!1)})),["autoReverse","externalResourcesRequired","focusable","preserveAlpha"].forEach((function(e){m[e]=new v(e,2,!1,e,null,!1,!1)})),"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach((function(e){m[e]=new v(e,3,!1,e.toLowerCase(),null,!1,!1)})),["checked","multiple","muted","selected"].forEach((function(e){m[e]=new v(e,3,!0,e,null,!1,!1)})),["capture","download"].forEach((function(e){m[e]=new v(e,4,!1,e,null,!1,!1)})),["cols","rows","size","span"].forEach((function(e){m[e]=new v(e,6,!1,e,null,!1,!1)})),["rowSpan","start"].forEach((function(e){m[e]=new v(e,5,!1,e.toLowerCase(),null,!1,!1)}));var y=/[\-:]([a-z])/g;function b(e){return e[1].toUpperCase()}function w(e,t,n,r){var s=m.hasOwnProperty(t)?m[t]:null;(null!==s?0===s.type:!r&&2<t.length&&("o"===t[0]||"O"===t[0])&&("n"===t[1]||"N"===t[1]))||(function(e,t,n,r){if(null==t||function(e,t,n,r){if(null!==n&&0===n.type)return!1;switch(typeof t){case"function":case"symbol":return!0;case"boolean":return!r&&(null!==n?!n.acceptsBooleans:"data-"!==(e=e.toLowerCase().slice(0,5))&&"aria-"!==e);default:return!1}}(e,t,n,r))return!0;if(r)return!1;if(null!==n)switch(n.type){case 3:return!t;case 4:return!1===t;case 5:return isNaN(t);case 6:return isNaN(t)||1>t}return!1}(t,n,s,r)&&(n=null),r||null===s?function(e){return!!f.call(h,e)||!f.call(g,e)&&(d.test(e)?h[e]=!0:(g[e]=!0,!1))}(t)&&(null===n?e.removeAttribute(t):e.setAttribute(t,""+n)):s.mustUseProperty?e[s.propertyName]=null===n?3!==s.type&&"":n:(t=s.attributeName,r=s.attributeNamespace,null===n?e.removeAttribute(t):(n=3===(s=s.type)||4===s&&!0===n?"":""+n,r?e.setAttributeNS(r,t,n):e.setAttribute(t,n))))}"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach((function(e){var t=e.replace(y,b);m[t]=new v(t,1,!1,e,null,!1,!1)})),"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach((function(e){var t=e.replace(y,b);m[t]=new v(t,1,!1,e,"http://www.w3.org/1999/xlink",!1,!1)})),["xml:base","xml:lang","xml:space"].forEach((function(e){var t=e.replace(y,b);m[t]=new v(t,1,!1,e,"http://www.w3.org/XML/1998/namespace",!1,!1)})),["tabIndex","crossOrigin"].forEach((function(e){m[e]=new v(e,1,!1,e.toLowerCase(),null,!1,!1)})),m.xlinkHref=new v("xlinkHref",1,!1,"xlink:href","http://www.w3.org/1999/xlink",!0,!1),["src","href","action","formAction"].forEach((function(e){m[e]=new v(e,1,!1,e.toLowerCase(),null,!0,!0)}));var k=r.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,x=60103,j=60106,S=60107,E=60108,O=60114,C=60109,P=60110,A=60112,_=60113,L=60120,N=60115,T=60116,R=60121,D=60128,I=60129,B=60130,M=60131;if("function"==typeof Symbol&&Symbol.for){var F=Symbol.for;x=F("react.element"),j=F("react.portal"),S=F("react.fragment"),E=F("react.strict_mode"),O=F("react.profiler"),C=F("react.provider"),P=F("react.context"),A=F("react.forward_ref"),_=F("react.suspense"),L=F("react.suspense_list"),N=F("react.memo"),T=F("react.lazy"),R=F("react.block"),F("react.scope"),D=F("react.opaque.id"),I=F("react.debug_trace_mode"),B=F("react.offscreen"),M=F("react.legacy_hidden")}var q,z="function"==typeof Symbol&&Symbol.iterator;function U(e){return null===e||"object"!=typeof e?null:"function"==typeof(e=z&&e[z]||e["@@iterator"])?e:null}function H(e){if(void 0===q)try{throw Error()}catch(e){var t=e.stack.trim().match(/\n( *(at )?)/);q=t&&t[1]||""}return"\n"+q+e}var V=!1;function Q(e,t){if(!e||V)return"";V=!0;var n=Error.prepareStackTrace;Error.prepareStackTrace=void 0;try{if(t)if(t=function(){throw Error()},Object.defineProperty(t.prototype,"props",{set:function(){throw Error()}}),"object"==typeof Reflect&&Reflect.construct){try{Reflect.construct(t,[])}catch(e){var r=e}Reflect.construct(e,[],t)}else{try{t.call()}catch(e){r=e}e.call(t.prototype)}else{try{throw Error()}catch(e){r=e}e()}}catch(e){if(e&&r&&"string"==typeof e.stack){for(var s=e.stack.split("\n"),l=r.stack.split("\n"),o=s.length-1,a=l.length-1;1<=o&&0<=a&&s[o]!==l[a];)a--;for(;1<=o&&0<=a;o--,a--)if(s[o]!==l[a]){if(1!==o||1!==a)do{if(o--,0>--a||s[o]!==l[a])return"\n"+s[o].replace(" at new "," at ")}while(1<=o&&0<=a);break}}}finally{V=!1,Error.prepareStackTrace=n}return(e=e?e.displayName||e.name:"")?H(e):""}function $(e){switch(e.tag){case 5:return H(e.type);case 16:return H("Lazy");case 13:return H("Suspense");case 19:return H("SuspenseList");case 0:case 2:case 15:return Q(e.type,!1);case 11:return Q(e.type.render,!1);case 22:return Q(e.type._render,!1);case 1:return Q(e.type,!0);default:return""}}function W(e){if(null==e)return null;if("function"==typeof e)return e.displayName||e.name||null;if("string"==typeof e)return e;switch(e){case S:return"Fragment";case j:return"Portal";case O:return"Profiler";case E:return"StrictMode";case _:return"Suspense";case L:return"SuspenseList"}if("object"==typeof e)switch(e.$$typeof){case P:return(e.displayName||"Context")+".Consumer";case C:return(e._context.displayName||"Context")+".Provider";case A:var t=e.render;return t=t.displayName||t.name||"",e.displayName||(""!==t?"ForwardRef("+t+")":"ForwardRef");case N:return W(e.type);case R:return W(e._render);case T:t=e._payload,e=e._init;try{return W(e(t))}catch(e){}}return null}function X(e){switch(typeof e){case"boolean":case"number":case"object":case"string":case"undefined":return e;default:return""}}function K(e){var t=e.type;return(e=e.nodeName)&&"input"===e.toLowerCase()&&("checkbox"===t||"radio"===t)}function Y(e){e._valueTracker||(e._valueTracker=function(e){var t=K(e)?"checked":"value",n=Object.getOwnPropertyDescriptor(e.constructor.prototype,t),r=""+e[t];if(!e.hasOwnProperty(t)&&void 0!==n&&"function"==typeof n.get&&"function"==typeof n.set){var s=n.get,l=n.set;return Object.defineProperty(e,t,{configurable:!0,get:function(){return s.call(this)},set:function(e){r=""+e,l.call(this,e)}}),Object.defineProperty(e,t,{enumerable:n.enumerable}),{getValue:function(){return r},setValue:function(e){r=""+e},stopTracking:function(){e._valueTracker=null,delete e[t]}}}}(e))}function G(e){if(!e)return!1;var t=e._valueTracker;if(!t)return!0;var n=t.getValue(),r="";return e&&(r=K(e)?e.checked?"true":"false":e.value),(e=r)!==n&&(t.setValue(e),!0)}function J(e){if(void 0===(e=e||("undefined"!=typeof document?document:void 0)))return null;try{return e.activeElement||e.body}catch(t){return e.body}}function Z(e,t){var n=t.checked;return s({},t,{defaultChecked:void 0,defaultValue:void 0,value:void 0,checked:null!=n?n:e._wrapperState.initialChecked})}function ee(e,t){var n=null==t.defaultValue?"":t.defaultValue,r=null!=t.checked?t.checked:t.defaultChecked;n=X(null!=t.value?t.value:n),e._wrapperState={initialChecked:r,initialValue:n,controlled:"checkbox"===t.type||"radio"===t.type?null!=t.checked:null!=t.value}}function te(e,t){null!=(t=t.checked)&&w(e,"checked",t,!1)}function ne(e,t){te(e,t);var n=X(t.value),r=t.type;if(null!=n)"number"===r?(0===n&&""===e.value||e.value!=n)&&(e.value=""+n):e.value!==""+n&&(e.value=""+n);else if("submit"===r||"reset"===r)return void e.removeAttribute("value");t.hasOwnProperty("value")?se(e,t.type,n):t.hasOwnProperty("defaultValue")&&se(e,t.type,X(t.defaultValue)),null==t.checked&&null!=t.defaultChecked&&(e.defaultChecked=!!t.defaultChecked)}function re(e,t,n){if(t.hasOwnProperty("value")||t.hasOwnProperty("defaultValue")){var r=t.type;if(!("submit"!==r&&"reset"!==r||void 0!==t.value&&null!==t.value))return;t=""+e._wrapperState.initialValue,n||t===e.value||(e.value=t),e.defaultValue=t}""!==(n=e.name)&&(e.name=""),e.defaultChecked=!!e._wrapperState.initialChecked,""!==n&&(e.name=n)}function se(e,t,n){"number"===t&&J(e.ownerDocument)===e||(null==n?e.defaultValue=""+e._wrapperState.initialValue:e.defaultValue!==""+n&&(e.defaultValue=""+n))}function le(e,t){return e=s({children:void 0},t),(t=function(e){var t="";return r.Children.forEach(e,(function(e){null!=e&&(t+=e)})),t}(t.children))&&(e.children=t),e}function oe(e,t,n,r){if(e=e.options,t){t={};for(var s=0;s<n.length;s++)t["$"+n[s]]=!0;for(n=0;n<e.length;n++)s=t.hasOwnProperty("$"+e[n].value),e[n].selected!==s&&(e[n].selected=s),s&&r&&(e[n].defaultSelected=!0)}else{for(n=""+X(n),t=null,s=0;s<e.length;s++){if(e[s].value===n)return e[s].selected=!0,void(r&&(e[s].defaultSelected=!0));null!==t||e[s].disabled||(t=e[s])}null!==t&&(t.selected=!0)}}function ae(e,t){if(null!=t.dangerouslySetInnerHTML)throw Error(o(91));return s({},t,{value:void 0,defaultValue:void 0,children:""+e._wrapperState.initialValue})}function ie(e,t){var n=t.value;if(null==n){if(n=t.children,t=t.defaultValue,null!=n){if(null!=t)throw Error(o(92));if(Array.isArray(n)){if(!(1>=n.length))throw Error(o(93));n=n[0]}t=n}null==t&&(t=""),n=t}e._wrapperState={initialValue:X(n)}}function pe(e,t){var n=X(t.value),r=X(t.defaultValue);null!=n&&((n=""+n)!==e.value&&(e.value=n),null==t.defaultValue&&e.defaultValue!==n&&(e.defaultValue=n)),null!=r&&(e.defaultValue=""+r)}function ue(e){var t=e.textContent;t===e._wrapperState.initialValue&&""!==t&&null!==t&&(e.value=t)}var ce="http://www.w3.org/1999/xhtml";function de(e){switch(e){case"svg":return"http://www.w3.org/2000/svg";case"math":return"http://www.w3.org/1998/Math/MathML";default:return"http://www.w3.org/1999/xhtml"}}function fe(e,t){return null==e||"http://www.w3.org/1999/xhtml"===e?de(t):"http://www.w3.org/2000/svg"===e&&"foreignObject"===t?"http://www.w3.org/1999/xhtml":e}var ge,he,ve=(he=function(e,t){if("http://www.w3.org/2000/svg"!==e.namespaceURI||"innerHTML"in e)e.innerHTML=t;else{for((ge=ge||document.createElement("div")).innerHTML="<svg>"+t.valueOf().toString()+"</svg>",t=ge.firstChild;e.firstChild;)e.removeChild(e.firstChild);for(;t.firstChild;)e.appendChild(t.firstChild)}},"undefined"!=typeof MSApp&&MSApp.execUnsafeLocalFunction?function(e,t,n,r){MSApp.execUnsafeLocalFunction((function(){return he(e,t)}))}:he);function me(e,t){if(t){var n=e.firstChild;if(n&&n===e.lastChild&&3===n.nodeType)return void(n.nodeValue=t)}e.textContent=t}var ye={animationIterationCount:!0,borderImageOutset:!0,borderImageSlice:!0,borderImageWidth:!0,boxFlex:!0,boxFlexGroup:!0,boxOrdinalGroup:!0,columnCount:!0,columns:!0,flex:!0,flexGrow:!0,flexPositive:!0,flexShrink:!0,flexNegative:!0,flexOrder:!0,gridArea:!0,gridRow:!0,gridRowEnd:!0,gridRowSpan:!0,gridRowStart:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnSpan:!0,gridColumnStart:!0,fontWeight:!0,lineClamp:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,tabSize:!0,widows:!0,zIndex:!0,zoom:!0,fillOpacity:!0,floodOpacity:!0,stopOpacity:!0,strokeDasharray:!0,strokeDashoffset:!0,strokeMiterlimit:!0,strokeOpacity:!0,strokeWidth:!0},be=["Webkit","ms","Moz","O"];function we(e,t,n){return null==t||"boolean"==typeof t||""===t?"":n||"number"!=typeof t||0===t||ye.hasOwnProperty(e)&&ye[e]?(""+t).trim():t+"px"}function ke(e,t){for(var n in e=e.style,t)if(t.hasOwnProperty(n)){var r=0===n.indexOf("--"),s=we(n,t[n],r);"float"===n&&(n="cssFloat"),r?e.setProperty(n,s):e[n]=s}}Object.keys(ye).forEach((function(e){be.forEach((function(t){t=t+e.charAt(0).toUpperCase()+e.substring(1),ye[t]=ye[e]}))}));var xe=s({menuitem:!0},{area:!0,base:!0,br:!0,col:!0,embed:!0,hr:!0,img:!0,input:!0,keygen:!0,link:!0,meta:!0,param:!0,source:!0,track:!0,wbr:!0});function je(e,t){if(t){if(xe[e]&&(null!=t.children||null!=t.dangerouslySetInnerHTML))throw Error(o(137,e));if(null!=t.dangerouslySetInnerHTML){if(null!=t.children)throw Error(o(60));if("object"!=typeof t.dangerouslySetInnerHTML||!("__html"in t.dangerouslySetInnerHTML))throw Error(o(61))}if(null!=t.style&&"object"!=typeof t.style)throw Error(o(62))}}function Se(e,t){if(-1===e.indexOf("-"))return"string"==typeof t.is;switch(e){case"annotation-xml":case"color-profile":case"font-face":case"font-face-src":case"font-face-uri":case"font-face-format":case"font-face-name":case"missing-glyph":return!1;default:return!0}}function Ee(e){return(e=e.target||e.srcElement||window).correspondingUseElement&&(e=e.correspondingUseElement),3===e.nodeType?e.parentNode:e}var Oe=null,Ce=null,Pe=null;function Ae(e){if(e=ns(e)){if("function"!=typeof Oe)throw Error(o(280));var t=e.stateNode;t&&(t=ss(t),Oe(e.stateNode,e.type,t))}}function _e(e){Ce?Pe?Pe.push(e):Pe=[e]:Ce=e}function Le(){if(Ce){var e=Ce,t=Pe;if(Pe=Ce=null,Ae(e),t)for(e=0;e<t.length;e++)Ae(t[e])}}function Ne(e,t){return e(t)}function Te(e,t,n,r,s){return e(t,n,r,s)}function Re(){}var De=Ne,Ie=!1,Be=!1;function Me(){null===Ce&&null===Pe||(Re(),Le())}function Fe(e,t){var n=e.stateNode;if(null===n)return null;var r=ss(n);if(null===r)return null;n=r[t];e:switch(t){case"onClick":case"onClickCapture":case"onDoubleClick":case"onDoubleClickCapture":case"onMouseDown":case"onMouseDownCapture":case"onMouseMove":case"onMouseMoveCapture":case"onMouseUp":case"onMouseUpCapture":case"onMouseEnter":(r=!r.disabled)||(r=!("button"===(e=e.type)||"input"===e||"select"===e||"textarea"===e)),e=!r;break e;default:e=!1}if(e)return null;if(n&&"function"!=typeof n)throw Error(o(231,t,typeof n));return n}var qe=!1;if(c)try{var ze={};Object.defineProperty(ze,"passive",{get:function(){qe=!0}}),window.addEventListener("test",ze,ze),window.removeEventListener("test",ze,ze)}catch(he){qe=!1}function Ue(e,t,n,r,s,l,o,a,i){var p=Array.prototype.slice.call(arguments,3);try{t.apply(n,p)}catch(e){this.onError(e)}}var He=!1,Ve=null,Qe=!1,$e=null,We={onError:function(e){He=!0,Ve=e}};function Xe(e,t,n,r,s,l,o,a,i){He=!1,Ve=null,Ue.apply(We,arguments)}function Ke(e){var t=e,n=e;if(e.alternate)for(;t.return;)t=t.return;else{e=t;do{0!=(1026&(t=e).flags)&&(n=t.return),e=t.return}while(e)}return 3===t.tag?n:null}function Ye(e){if(13===e.tag){var t=e.memoizedState;if(null===t&&null!==(e=e.alternate)&&(t=e.memoizedState),null!==t)return t.dehydrated}return null}function Ge(e){if(Ke(e)!==e)throw Error(o(188))}function Je(e){if(e=function(e){var t=e.alternate;if(!t){if(null===(t=Ke(e)))throw Error(o(188));return t!==e?null:e}for(var n=e,r=t;;){var s=n.return;if(null===s)break;var l=s.alternate;if(null===l){if(null!==(r=s.return)){n=r;continue}break}if(s.child===l.child){for(l=s.child;l;){if(l===n)return Ge(s),e;if(l===r)return Ge(s),t;l=l.sibling}throw Error(o(188))}if(n.return!==r.return)n=s,r=l;else{for(var a=!1,i=s.child;i;){if(i===n){a=!0,n=s,r=l;break}if(i===r){a=!0,r=s,n=l;break}i=i.sibling}if(!a){for(i=l.child;i;){if(i===n){a=!0,n=l,r=s;break}if(i===r){a=!0,r=l,n=s;break}i=i.sibling}if(!a)throw Error(o(189))}}if(n.alternate!==r)throw Error(o(190))}if(3!==n.tag)throw Error(o(188));return n.stateNode.current===n?e:t}(e),!e)return null;for(var t=e;;){if(5===t.tag||6===t.tag)return t;if(t.child)t.child.return=t,t=t.child;else{if(t===e)break;for(;!t.sibling;){if(!t.return||t.return===e)return null;t=t.return}t.sibling.return=t.return,t=t.sibling}}return null}function Ze(e,t){for(var n=e.alternate;null!==t;){if(t===e||t===n)return!0;t=t.return}return!1}var et,tt,nt,rt,st=!1,lt=[],ot=null,at=null,it=null,pt=new Map,ut=new Map,ct=[],dt="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");function ft(e,t,n,r,s){return{blockedOn:e,domEventName:t,eventSystemFlags:16|n,nativeEvent:s,targetContainers:[r]}}function gt(e,t){switch(e){case"focusin":case"focusout":ot=null;break;case"dragenter":case"dragleave":at=null;break;case"mouseover":case"mouseout":it=null;break;case"pointerover":case"pointerout":pt.delete(t.pointerId);break;case"gotpointercapture":case"lostpointercapture":ut.delete(t.pointerId)}}function ht(e,t,n,r,s,l){return null===e||e.nativeEvent!==l?(e=ft(t,n,r,s,l),null!==t&&null!==(t=ns(t))&&tt(t),e):(e.eventSystemFlags|=r,t=e.targetContainers,null!==s&&-1===t.indexOf(s)&&t.push(s),e)}function vt(e){var t=ts(e.target);if(null!==t){var n=Ke(t);if(null!==n)if(13===(t=n.tag)){if(null!==(t=Ye(n)))return e.blockedOn=t,void rt(e.lanePriority,(function(){l.unstable_runWithPriority(e.priority,(function(){nt(n)}))}))}else if(3===t&&n.stateNode.hydrate)return void(e.blockedOn=3===n.tag?n.stateNode.containerInfo:null)}e.blockedOn=null}function mt(e){if(null!==e.blockedOn)return!1;for(var t=e.targetContainers;0<t.length;){var n=Jt(e.domEventName,e.eventSystemFlags,t[0],e.nativeEvent);if(null!==n)return null!==(t=ns(n))&&tt(t),e.blockedOn=n,!1;t.shift()}return!0}function yt(e,t,n){mt(e)&&n.delete(t)}function bt(){for(st=!1;0<lt.length;){var e=lt[0];if(null!==e.blockedOn){null!==(e=ns(e.blockedOn))&&et(e);break}for(var t=e.targetContainers;0<t.length;){var n=Jt(e.domEventName,e.eventSystemFlags,t[0],e.nativeEvent);if(null!==n){e.blockedOn=n;break}t.shift()}null===e.blockedOn&&lt.shift()}null!==ot&&mt(ot)&&(ot=null),null!==at&&mt(at)&&(at=null),null!==it&&mt(it)&&(it=null),pt.forEach(yt),ut.forEach(yt)}function wt(e,t){e.blockedOn===t&&(e.blockedOn=null,st||(st=!0,l.unstable_scheduleCallback(l.unstable_NormalPriority,bt)))}function kt(e){function t(t){return wt(t,e)}if(0<lt.length){wt(lt[0],e);for(var n=1;n<lt.length;n++){var r=lt[n];r.blockedOn===e&&(r.blockedOn=null)}}for(null!==ot&&wt(ot,e),null!==at&&wt(at,e),null!==it&&wt(it,e),pt.forEach(t),ut.forEach(t),n=0;n<ct.length;n++)(r=ct[n]).blockedOn===e&&(r.blockedOn=null);for(;0<ct.length&&null===(n=ct[0]).blockedOn;)vt(n),null===n.blockedOn&&ct.shift()}function xt(e,t){var n={};return n[e.toLowerCase()]=t.toLowerCase(),n["Webkit"+e]="webkit"+t,n["Moz"+e]="moz"+t,n}var jt={animationend:xt("Animation","AnimationEnd"),animationiteration:xt("Animation","AnimationIteration"),animationstart:xt("Animation","AnimationStart"),transitionend:xt("Transition","TransitionEnd")},St={},Et={};function Ot(e){if(St[e])return St[e];if(!jt[e])return e;var t,n=jt[e];for(t in n)if(n.hasOwnProperty(t)&&t in Et)return St[e]=n[t];return e}c&&(Et=document.createElement("div").style,"AnimationEvent"in window||(delete jt.animationend.animation,delete jt.animationiteration.animation,delete jt.animationstart.animation),"TransitionEvent"in window||delete jt.transitionend.transition);var Ct=Ot("animationend"),Pt=Ot("animationiteration"),At=Ot("animationstart"),_t=Ot("transitionend"),Lt=new Map,Nt=new Map,Tt=["abort","abort",Ct,"animationEnd",Pt,"animationIteration",At,"animationStart","canplay","canPlay","canplaythrough","canPlayThrough","durationchange","durationChange","emptied","emptied","encrypted","encrypted","ended","ended","error","error","gotpointercapture","gotPointerCapture","load","load","loadeddata","loadedData","loadedmetadata","loadedMetadata","loadstart","loadStart","lostpointercapture","lostPointerCapture","playing","playing","progress","progress","seeking","seeking","stalled","stalled","suspend","suspend","timeupdate","timeUpdate",_t,"transitionEnd","waiting","waiting"];function Rt(e,t){for(var n=0;n<e.length;n+=2){var r=e[n],s=e[n+1];s="on"+(s[0].toUpperCase()+s.slice(1)),Nt.set(r,t),Lt.set(r,s),p(s,[r])}}(0,l.unstable_now)();var Dt=8;function It(e){if(0!=(1&e))return Dt=15,1;if(0!=(2&e))return Dt=14,2;if(0!=(4&e))return Dt=13,4;var t=24&e;return 0!==t?(Dt=12,t):0!=(32&e)?(Dt=11,32):0!=(t=192&e)?(Dt=10,t):0!=(256&e)?(Dt=9,256):0!=(t=3584&e)?(Dt=8,t):0!=(4096&e)?(Dt=7,4096):0!=(t=4186112&e)?(Dt=6,t):0!=(t=62914560&e)?(Dt=5,t):67108864&e?(Dt=4,67108864):0!=(134217728&e)?(Dt=3,134217728):0!=(t=805306368&e)?(Dt=2,t):0!=(1073741824&e)?(Dt=1,1073741824):(Dt=8,e)}function Bt(e,t){var n=e.pendingLanes;if(0===n)return Dt=0;var r=0,s=0,l=e.expiredLanes,o=e.suspendedLanes,a=e.pingedLanes;if(0!==l)r=l,s=Dt=15;else if(0!=(l=134217727&n)){var i=l&~o;0!==i?(r=It(i),s=Dt):0!=(a&=l)&&(r=It(a),s=Dt)}else 0!=(l=n&~o)?(r=It(l),s=Dt):0!==a&&(r=It(a),s=Dt);if(0===r)return 0;if(r=n&((0>(r=31-Ht(r))?0:1<<r)<<1)-1,0!==t&&t!==r&&0==(t&o)){if(It(t),s<=Dt)return t;Dt=s}if(0!==(t=e.entangledLanes))for(e=e.entanglements,t&=r;0<t;)s=1<<(n=31-Ht(t)),r|=e[n],t&=~s;return r}function Mt(e){return 0!=(e=-1073741825&e.pendingLanes)?e:1073741824&e?1073741824:0}function Ft(e,t){switch(e){case 15:return 1;case 14:return 2;case 12:return 0===(e=qt(24&~t))?Ft(10,t):e;case 10:return 0===(e=qt(192&~t))?Ft(8,t):e;case 8:return 0===(e=qt(3584&~t))&&0===(e=qt(4186112&~t))&&(e=512),e;case 2:return 0===(t=qt(805306368&~t))&&(t=268435456),t}throw Error(o(358,e))}function qt(e){return e&-e}function zt(e){for(var t=[],n=0;31>n;n++)t.push(e);return t}function Ut(e,t,n){e.pendingLanes|=t;var r=t-1;e.suspendedLanes&=r,e.pingedLanes&=r,(e=e.eventTimes)[t=31-Ht(t)]=n}var Ht=Math.clz32?Math.clz32:function(e){return 0===e?32:31-(Vt(e)/Qt|0)|0},Vt=Math.log,Qt=Math.LN2,$t=l.unstable_UserBlockingPriority,Wt=l.unstable_runWithPriority,Xt=!0;function Kt(e,t,n,r){Ie||Re();var s=Gt,l=Ie;Ie=!0;try{Te(s,e,t,n,r)}finally{(Ie=l)||Me()}}function Yt(e,t,n,r){Wt($t,Gt.bind(null,e,t,n,r))}function Gt(e,t,n,r){var s;if(Xt)if((s=0==(4&t))&&0<lt.length&&-1<dt.indexOf(e))e=ft(null,e,t,n,r),lt.push(e);else{var l=Jt(e,t,n,r);if(null===l)s&&gt(e,r);else{if(s){if(-1<dt.indexOf(e))return e=ft(l,e,t,n,r),void lt.push(e);if(function(e,t,n,r,s){switch(t){case"focusin":return ot=ht(ot,e,t,n,r,s),!0;case"dragenter":return at=ht(at,e,t,n,r,s),!0;case"mouseover":return it=ht(it,e,t,n,r,s),!0;case"pointerover":var l=s.pointerId;return pt.set(l,ht(pt.get(l)||null,e,t,n,r,s)),!0;case"gotpointercapture":return l=s.pointerId,ut.set(l,ht(ut.get(l)||null,e,t,n,r,s)),!0}return!1}(l,e,t,n,r))return;gt(e,r)}Rr(e,t,r,null,n)}}}function Jt(e,t,n,r){var s=Ee(r);if(null!==(s=ts(s))){var l=Ke(s);if(null===l)s=null;else{var o=l.tag;if(13===o){if(null!==(s=Ye(l)))return s;s=null}else if(3===o){if(l.stateNode.hydrate)return 3===l.tag?l.stateNode.containerInfo:null;s=null}else l!==s&&(s=null)}}return Rr(e,t,r,s,n),null}var Zt=null,en=null,tn=null;function nn(){if(tn)return tn;var e,t,n=en,r=n.length,s="value"in Zt?Zt.value:Zt.textContent,l=s.length;for(e=0;e<r&&n[e]===s[e];e++);var o=r-e;for(t=1;t<=o&&n[r-t]===s[l-t];t++);return tn=s.slice(e,1<t?1-t:void 0)}function rn(e){var t=e.keyCode;return"charCode"in e?0===(e=e.charCode)&&13===t&&(e=13):e=t,10===e&&(e=13),32<=e||13===e?e:0}function sn(){return!0}function ln(){return!1}function on(e){function t(t,n,r,s,l){for(var o in this._reactName=t,this._targetInst=r,this.type=n,this.nativeEvent=s,this.target=l,this.currentTarget=null,e)e.hasOwnProperty(o)&&(t=e[o],this[o]=t?t(s):s[o]);return this.isDefaultPrevented=(null!=s.defaultPrevented?s.defaultPrevented:!1===s.returnValue)?sn:ln,this.isPropagationStopped=ln,this}return s(t.prototype,{preventDefault:function(){this.defaultPrevented=!0;var e=this.nativeEvent;e&&(e.preventDefault?e.preventDefault():"unknown"!=typeof e.returnValue&&(e.returnValue=!1),this.isDefaultPrevented=sn)},stopPropagation:function(){var e=this.nativeEvent;e&&(e.stopPropagation?e.stopPropagation():"unknown"!=typeof e.cancelBubble&&(e.cancelBubble=!0),this.isPropagationStopped=sn)},persist:function(){},isPersistent:sn}),t}var an,pn,un,cn={eventPhase:0,bubbles:0,cancelable:0,timeStamp:function(e){return e.timeStamp||Date.now()},defaultPrevented:0,isTrusted:0},dn=on(cn),fn=s({},cn,{view:0,detail:0}),gn=on(fn),hn=s({},fn,{screenX:0,screenY:0,clientX:0,clientY:0,pageX:0,pageY:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,getModifierState:Cn,button:0,buttons:0,relatedTarget:function(e){return void 0===e.relatedTarget?e.fromElement===e.srcElement?e.toElement:e.fromElement:e.relatedTarget},movementX:function(e){return"movementX"in e?e.movementX:(e!==un&&(un&&"mousemove"===e.type?(an=e.screenX-un.screenX,pn=e.screenY-un.screenY):pn=an=0,un=e),an)},movementY:function(e){return"movementY"in e?e.movementY:pn}}),vn=on(hn),mn=on(s({},hn,{dataTransfer:0})),yn=on(s({},fn,{relatedTarget:0})),bn=on(s({},cn,{animationName:0,elapsedTime:0,pseudoElement:0})),wn=s({},cn,{clipboardData:function(e){return"clipboardData"in e?e.clipboardData:window.clipboardData}}),kn=on(wn),xn=on(s({},cn,{data:0})),jn={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},Sn={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",224:"Meta"},En={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"};function On(e){var t=this.nativeEvent;return t.getModifierState?t.getModifierState(e):!!(e=En[e])&&!!t[e]}function Cn(){return On}var Pn=s({},fn,{key:function(e){if(e.key){var t=jn[e.key]||e.key;if("Unidentified"!==t)return t}return"keypress"===e.type?13===(e=rn(e))?"Enter":String.fromCharCode(e):"keydown"===e.type||"keyup"===e.type?Sn[e.keyCode]||"Unidentified":""},code:0,location:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,repeat:0,locale:0,getModifierState:Cn,charCode:function(e){return"keypress"===e.type?rn(e):0},keyCode:function(e){return"keydown"===e.type||"keyup"===e.type?e.keyCode:0},which:function(e){return"keypress"===e.type?rn(e):"keydown"===e.type||"keyup"===e.type?e.keyCode:0}}),An=on(Pn),_n=on(s({},hn,{pointerId:0,width:0,height:0,pressure:0,tangentialPressure:0,tiltX:0,tiltY:0,twist:0,pointerType:0,isPrimary:0})),Ln=on(s({},fn,{touches:0,targetTouches:0,changedTouches:0,altKey:0,metaKey:0,ctrlKey:0,shiftKey:0,getModifierState:Cn})),Nn=on(s({},cn,{propertyName:0,elapsedTime:0,pseudoElement:0})),Tn=s({},hn,{deltaX:function(e){return"deltaX"in e?e.deltaX:"wheelDeltaX"in e?-e.wheelDeltaX:0},deltaY:function(e){return"deltaY"in e?e.deltaY:"wheelDeltaY"in e?-e.wheelDeltaY:"wheelDelta"in e?-e.wheelDelta:0},deltaZ:0,deltaMode:0}),Rn=on(Tn),Dn=[9,13,27,32],In=c&&"CompositionEvent"in window,Bn=null;c&&"documentMode"in document&&(Bn=document.documentMode);var Mn=c&&"TextEvent"in window&&!Bn,Fn=c&&(!In||Bn&&8<Bn&&11>=Bn),qn=String.fromCharCode(32),zn=!1;function Un(e,t){switch(e){case"keyup":return-1!==Dn.indexOf(t.keyCode);case"keydown":return 229!==t.keyCode;case"keypress":case"mousedown":case"focusout":return!0;default:return!1}}function Hn(e){return"object"==typeof(e=e.detail)&&"data"in e?e.data:null}var Vn=!1,Qn={color:!0,date:!0,datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0};function $n(e){var t=e&&e.nodeName&&e.nodeName.toLowerCase();return"input"===t?!!Qn[e.type]:"textarea"===t}function Wn(e,t,n,r){_e(r),0<(t=Ir(t,"onChange")).length&&(n=new dn("onChange","change",null,n,r),e.push({event:n,listeners:t}))}var Xn=null,Kn=null;function Yn(e){Pr(e,0)}function Gn(e){if(G(rs(e)))return e}function Jn(e,t){if("change"===e)return t}var Zn=!1;if(c){var er;if(c){var tr="oninput"in document;if(!tr){var nr=document.createElement("div");nr.setAttribute("oninput","return;"),tr="function"==typeof nr.oninput}er=tr}else er=!1;Zn=er&&(!document.documentMode||9<document.documentMode)}function rr(){Xn&&(Xn.detachEvent("onpropertychange",sr),Kn=Xn=null)}function sr(e){if("value"===e.propertyName&&Gn(Kn)){var t=[];if(Wn(t,Kn,e,Ee(e)),e=Yn,Ie)e(t);else{Ie=!0;try{Ne(e,t)}finally{Ie=!1,Me()}}}}function lr(e,t,n){"focusin"===e?(rr(),Kn=n,(Xn=t).attachEvent("onpropertychange",sr)):"focusout"===e&&rr()}function or(e){if("selectionchange"===e||"keyup"===e||"keydown"===e)return Gn(Kn)}function ar(e,t){if("click"===e)return Gn(t)}function ir(e,t){if("input"===e||"change"===e)return Gn(t)}var pr="function"==typeof Object.is?Object.is:function(e,t){return e===t&&(0!==e||1/e==1/t)||e!=e&&t!=t},ur=Object.prototype.hasOwnProperty;function cr(e,t){if(pr(e,t))return!0;if("object"!=typeof e||null===e||"object"!=typeof t||null===t)return!1;var n=Object.keys(e),r=Object.keys(t);if(n.length!==r.length)return!1;for(r=0;r<n.length;r++)if(!ur.call(t,n[r])||!pr(e[n[r]],t[n[r]]))return!1;return!0}function dr(e){for(;e&&e.firstChild;)e=e.firstChild;return e}function fr(e,t){var n,r=dr(e);for(e=0;r;){if(3===r.nodeType){if(n=e+r.textContent.length,e<=t&&n>=t)return{node:r,offset:t-e};e=n}e:{for(;r;){if(r.nextSibling){r=r.nextSibling;break e}r=r.parentNode}r=void 0}r=dr(r)}}function gr(e,t){return!(!e||!t)&&(e===t||(!e||3!==e.nodeType)&&(t&&3===t.nodeType?gr(e,t.parentNode):"contains"in e?e.contains(t):!!e.compareDocumentPosition&&!!(16&e.compareDocumentPosition(t))))}function hr(){for(var e=window,t=J();t instanceof e.HTMLIFrameElement;){try{var n="string"==typeof t.contentWindow.location.href}catch(e){n=!1}if(!n)break;t=J((e=t.contentWindow).document)}return t}function vr(e){var t=e&&e.nodeName&&e.nodeName.toLowerCase();return t&&("input"===t&&("text"===e.type||"search"===e.type||"tel"===e.type||"url"===e.type||"password"===e.type)||"textarea"===t||"true"===e.contentEditable)}var mr=c&&"documentMode"in document&&11>=document.documentMode,yr=null,br=null,wr=null,kr=!1;function xr(e,t,n){var r=n.window===n?n.document:9===n.nodeType?n:n.ownerDocument;kr||null==yr||yr!==J(r)||(r="selectionStart"in(r=yr)&&vr(r)?{start:r.selectionStart,end:r.selectionEnd}:{anchorNode:(r=(r.ownerDocument&&r.ownerDocument.defaultView||window).getSelection()).anchorNode,anchorOffset:r.anchorOffset,focusNode:r.focusNode,focusOffset:r.focusOffset},wr&&cr(wr,r)||(wr=r,0<(r=Ir(br,"onSelect")).length&&(t=new dn("onSelect","select",null,t,n),e.push({event:t,listeners:r}),t.target=yr)))}Rt("cancel cancel click click close close contextmenu contextMenu copy copy cut cut auxclick auxClick dblclick doubleClick dragend dragEnd dragstart dragStart drop drop focusin focus focusout blur input input invalid invalid keydown keyDown keypress keyPress keyup keyUp mousedown mouseDown mouseup mouseUp paste paste pause pause play play pointercancel pointerCancel pointerdown pointerDown pointerup pointerUp ratechange rateChange reset reset seeked seeked submit submit touchcancel touchCancel touchend touchEnd touchstart touchStart volumechange volumeChange".split(" "),0),Rt("drag drag dragenter dragEnter dragexit dragExit dragleave dragLeave dragover dragOver mousemove mouseMove mouseout mouseOut mouseover mouseOver pointermove pointerMove pointerout pointerOut pointerover pointerOver scroll scroll toggle toggle touchmove touchMove wheel wheel".split(" "),1),Rt(Tt,2);for(var jr="change selectionchange textInput compositionstart compositionend compositionupdate".split(" "),Sr=0;Sr<jr.length;Sr++)Nt.set(jr[Sr],0);u("onMouseEnter",["mouseout","mouseover"]),u("onMouseLeave",["mouseout","mouseover"]),u("onPointerEnter",["pointerout","pointerover"]),u("onPointerLeave",["pointerout","pointerover"]),p("onChange","change click focusin focusout input keydown keyup selectionchange".split(" ")),p("onSelect","focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" ")),p("onBeforeInput",["compositionend","keypress","textInput","paste"]),p("onCompositionEnd","compositionend focusout keydown keypress keyup mousedown".split(" ")),p("onCompositionStart","compositionstart focusout keydown keypress keyup mousedown".split(" ")),p("onCompositionUpdate","compositionupdate focusout keydown keypress keyup mousedown".split(" "));var Er="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),Or=new Set("cancel close invalid load scroll toggle".split(" ").concat(Er));function Cr(e,t,n){var r=e.type||"unknown-event";e.currentTarget=n,function(e,t,n,r,s,l,a,i,p){if(Xe.apply(this,arguments),He){if(!He)throw Error(o(198));var u=Ve;He=!1,Ve=null,Qe||(Qe=!0,$e=u)}}(r,t,void 0,e),e.currentTarget=null}function Pr(e,t){t=0!=(4&t);for(var n=0;n<e.length;n++){var r=e[n],s=r.event;r=r.listeners;e:{var l=void 0;if(t)for(var o=r.length-1;0<=o;o--){var a=r[o],i=a.instance,p=a.currentTarget;if(a=a.listener,i!==l&&s.isPropagationStopped())break e;Cr(s,a,p),l=i}else for(o=0;o<r.length;o++){if(i=(a=r[o]).instance,p=a.currentTarget,a=a.listener,i!==l&&s.isPropagationStopped())break e;Cr(s,a,p),l=i}}}if(Qe)throw e=$e,Qe=!1,$e=null,e}function Ar(e,t){var n=ls(t),r=e+"__bubble";n.has(r)||(Tr(t,e,2,!1),n.add(r))}var _r="_reactListening"+Math.random().toString(36).slice(2);function Lr(e){e[_r]||(e[_r]=!0,a.forEach((function(t){Or.has(t)||Nr(t,!1,e,null),Nr(t,!0,e,null)})))}function Nr(e,t,n,r){var s=4<arguments.length&&void 0!==arguments[4]?arguments[4]:0,l=n;if("selectionchange"===e&&9!==n.nodeType&&(l=n.ownerDocument),null!==r&&!t&&Or.has(e)){if("scroll"!==e)return;s|=2,l=r}var o=ls(l),a=e+"__"+(t?"capture":"bubble");o.has(a)||(t&&(s|=4),Tr(l,e,s,t),o.add(a))}function Tr(e,t,n,r){var s=Nt.get(t);switch(void 0===s?2:s){case 0:s=Kt;break;case 1:s=Yt;break;default:s=Gt}n=s.bind(null,t,n,e),s=void 0,!qe||"touchstart"!==t&&"touchmove"!==t&&"wheel"!==t||(s=!0),r?void 0!==s?e.addEventListener(t,n,{capture:!0,passive:s}):e.addEventListener(t,n,!0):void 0!==s?e.addEventListener(t,n,{passive:s}):e.addEventListener(t,n,!1)}function Rr(e,t,n,r,s){var l=r;if(0==(1&t)&&0==(2&t)&&null!==r)e:for(;;){if(null===r)return;var o=r.tag;if(3===o||4===o){var a=r.stateNode.containerInfo;if(a===s||8===a.nodeType&&a.parentNode===s)break;if(4===o)for(o=r.return;null!==o;){var i=o.tag;if((3===i||4===i)&&((i=o.stateNode.containerInfo)===s||8===i.nodeType&&i.parentNode===s))return;o=o.return}for(;null!==a;){if(null===(o=ts(a)))return;if(5===(i=o.tag)||6===i){r=l=o;continue e}a=a.parentNode}}r=r.return}!function(e,t,n){if(Be)return e();Be=!0;try{De(e,t,n)}finally{Be=!1,Me()}}((function(){var r=l,s=Ee(n),o=[];e:{var a=Lt.get(e);if(void 0!==a){var i=dn,p=e;switch(e){case"keypress":if(0===rn(n))break e;case"keydown":case"keyup":i=An;break;case"focusin":p="focus",i=yn;break;case"focusout":p="blur",i=yn;break;case"beforeblur":case"afterblur":i=yn;break;case"click":if(2===n.button)break e;case"auxclick":case"dblclick":case"mousedown":case"mousemove":case"mouseup":case"mouseout":case"mouseover":case"contextmenu":i=vn;break;case"drag":case"dragend":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"dragstart":case"drop":i=mn;break;case"touchcancel":case"touchend":case"touchmove":case"touchstart":i=Ln;break;case Ct:case Pt:case At:i=bn;break;case _t:i=Nn;break;case"scroll":i=gn;break;case"wheel":i=Rn;break;case"copy":case"cut":case"paste":i=kn;break;case"gotpointercapture":case"lostpointercapture":case"pointercancel":case"pointerdown":case"pointermove":case"pointerout":case"pointerover":case"pointerup":i=_n}var u=0!=(4&t),c=!u&&"scroll"===e,d=u?null!==a?a+"Capture":null:a;u=[];for(var f,g=r;null!==g;){var h=(f=g).stateNode;if(5===f.tag&&null!==h&&(f=h,null!==d&&null!=(h=Fe(g,d))&&u.push(Dr(g,h,f))),c)break;g=g.return}0<u.length&&(a=new i(a,p,null,n,s),o.push({event:a,listeners:u}))}}if(0==(7&t)){if(i="mouseout"===e||"pointerout"===e,(!(a="mouseover"===e||"pointerover"===e)||0!=(16&t)||!(p=n.relatedTarget||n.fromElement)||!ts(p)&&!p[Zr])&&(i||a)&&(a=s.window===s?s:(a=s.ownerDocument)?a.defaultView||a.parentWindow:window,i?(i=r,null!==(p=(p=n.relatedTarget||n.toElement)?ts(p):null)&&(p!==(c=Ke(p))||5!==p.tag&&6!==p.tag)&&(p=null)):(i=null,p=r),i!==p)){if(u=vn,h="onMouseLeave",d="onMouseEnter",g="mouse","pointerout"!==e&&"pointerover"!==e||(u=_n,h="onPointerLeave",d="onPointerEnter",g="pointer"),c=null==i?a:rs(i),f=null==p?a:rs(p),(a=new u(h,g+"leave",i,n,s)).target=c,a.relatedTarget=f,h=null,ts(s)===r&&((u=new u(d,g+"enter",p,n,s)).target=f,u.relatedTarget=c,h=u),c=h,i&&p)e:{for(d=p,g=0,f=u=i;f;f=Br(f))g++;for(f=0,h=d;h;h=Br(h))f++;for(;0<g-f;)u=Br(u),g--;for(;0<f-g;)d=Br(d),f--;for(;g--;){if(u===d||null!==d&&u===d.alternate)break e;u=Br(u),d=Br(d)}u=null}else u=null;null!==i&&Mr(o,a,i,u,!1),null!==p&&null!==c&&Mr(o,c,p,u,!0)}if("select"===(i=(a=r?rs(r):window).nodeName&&a.nodeName.toLowerCase())||"input"===i&&"file"===a.type)var v=Jn;else if($n(a))if(Zn)v=ir;else{v=or;var m=lr}else(i=a.nodeName)&&"input"===i.toLowerCase()&&("checkbox"===a.type||"radio"===a.type)&&(v=ar);switch(v&&(v=v(e,r))?Wn(o,v,n,s):(m&&m(e,a,r),"focusout"===e&&(m=a._wrapperState)&&m.controlled&&"number"===a.type&&se(a,"number",a.value)),m=r?rs(r):window,e){case"focusin":($n(m)||"true"===m.contentEditable)&&(yr=m,br=r,wr=null);break;case"focusout":wr=br=yr=null;break;case"mousedown":kr=!0;break;case"contextmenu":case"mouseup":case"dragend":kr=!1,xr(o,n,s);break;case"selectionchange":if(mr)break;case"keydown":case"keyup":xr(o,n,s)}var y;if(In)e:{switch(e){case"compositionstart":var b="onCompositionStart";break e;case"compositionend":b="onCompositionEnd";break e;case"compositionupdate":b="onCompositionUpdate";break e}b=void 0}else Vn?Un(e,n)&&(b="onCompositionEnd"):"keydown"===e&&229===n.keyCode&&(b="onCompositionStart");b&&(Fn&&"ko"!==n.locale&&(Vn||"onCompositionStart"!==b?"onCompositionEnd"===b&&Vn&&(y=nn()):(en="value"in(Zt=s)?Zt.value:Zt.textContent,Vn=!0)),0<(m=Ir(r,b)).length&&(b=new xn(b,e,null,n,s),o.push({event:b,listeners:m}),(y||null!==(y=Hn(n)))&&(b.data=y))),(y=Mn?function(e,t){switch(e){case"compositionend":return Hn(t);case"keypress":return 32!==t.which?null:(zn=!0,qn);case"textInput":return(e=t.data)===qn&&zn?null:e;default:return null}}(e,n):function(e,t){if(Vn)return"compositionend"===e||!In&&Un(e,t)?(e=nn(),tn=en=Zt=null,Vn=!1,e):null;switch(e){case"paste":default:return null;case"keypress":if(!(t.ctrlKey||t.altKey||t.metaKey)||t.ctrlKey&&t.altKey){if(t.char&&1<t.char.length)return t.char;if(t.which)return String.fromCharCode(t.which)}return null;case"compositionend":return Fn&&"ko"!==t.locale?null:t.data}}(e,n))&&0<(r=Ir(r,"onBeforeInput")).length&&(s=new xn("onBeforeInput","beforeinput",null,n,s),o.push({event:s,listeners:r}),s.data=y)}Pr(o,t)}))}function Dr(e,t,n){return{instance:e,listener:t,currentTarget:n}}function Ir(e,t){for(var n=t+"Capture",r=[];null!==e;){var s=e,l=s.stateNode;5===s.tag&&null!==l&&(s=l,null!=(l=Fe(e,n))&&r.unshift(Dr(e,l,s)),null!=(l=Fe(e,t))&&r.push(Dr(e,l,s))),e=e.return}return r}function Br(e){if(null===e)return null;do{e=e.return}while(e&&5!==e.tag);return e||null}function Mr(e,t,n,r,s){for(var l=t._reactName,o=[];null!==n&&n!==r;){var a=n,i=a.alternate,p=a.stateNode;if(null!==i&&i===r)break;5===a.tag&&null!==p&&(a=p,s?null!=(i=Fe(n,l))&&o.unshift(Dr(n,i,a)):s||null!=(i=Fe(n,l))&&o.push(Dr(n,i,a))),n=n.return}0!==o.length&&e.push({event:t,listeners:o})}function Fr(){}var qr=null,zr=null;function Ur(e,t){switch(e){case"button":case"input":case"select":case"textarea":return!!t.autoFocus}return!1}function Hr(e,t){return"textarea"===e||"option"===e||"noscript"===e||"string"==typeof t.children||"number"==typeof t.children||"object"==typeof t.dangerouslySetInnerHTML&&null!==t.dangerouslySetInnerHTML&&null!=t.dangerouslySetInnerHTML.__html}var Vr="function"==typeof setTimeout?setTimeout:void 0,Qr="function"==typeof clearTimeout?clearTimeout:void 0;function $r(e){(1===e.nodeType||9===e.nodeType&&null!=(e=e.body))&&(e.textContent="")}function Wr(e){for(;null!=e;e=e.nextSibling){var t=e.nodeType;if(1===t||3===t)break}return e}function Xr(e){e=e.previousSibling;for(var t=0;e;){if(8===e.nodeType){var n=e.data;if("$"===n||"$!"===n||"$?"===n){if(0===t)return e;t--}else"/$"===n&&t++}e=e.previousSibling}return null}var Kr=0,Yr=Math.random().toString(36).slice(2),Gr="__reactFiber$"+Yr,Jr="__reactProps$"+Yr,Zr="__reactContainer$"+Yr,es="__reactEvents$"+Yr;function ts(e){var t=e[Gr];if(t)return t;for(var n=e.parentNode;n;){if(t=n[Zr]||n[Gr]){if(n=t.alternate,null!==t.child||null!==n&&null!==n.child)for(e=Xr(e);null!==e;){if(n=e[Gr])return n;e=Xr(e)}return t}n=(e=n).parentNode}return null}function ns(e){return!(e=e[Gr]||e[Zr])||5!==e.tag&&6!==e.tag&&13!==e.tag&&3!==e.tag?null:e}function rs(e){if(5===e.tag||6===e.tag)return e.stateNode;throw Error(o(33))}function ss(e){return e[Jr]||null}function ls(e){var t=e[es];return void 0===t&&(t=e[es]=new Set),t}var os=[],as=-1;function is(e){return{current:e}}function ps(e){0>as||(e.current=os[as],os[as]=null,as--)}function us(e,t){as++,os[as]=e.current,e.current=t}var cs={},ds=is(cs),fs=is(!1),gs=cs;function hs(e,t){var n=e.type.contextTypes;if(!n)return cs;var r=e.stateNode;if(r&&r.__reactInternalMemoizedUnmaskedChildContext===t)return r.__reactInternalMemoizedMaskedChildContext;var s,l={};for(s in n)l[s]=t[s];return r&&((e=e.stateNode).__reactInternalMemoizedUnmaskedChildContext=t,e.__reactInternalMemoizedMaskedChildContext=l),l}function vs(e){return null!=e.childContextTypes}function ms(){ps(fs),ps(ds)}function ys(e,t,n){if(ds.current!==cs)throw Error(o(168));us(ds,t),us(fs,n)}function bs(e,t,n){var r=e.stateNode;if(e=t.childContextTypes,"function"!=typeof r.getChildContext)return n;for(var l in r=r.getChildContext())if(!(l in e))throw Error(o(108,W(t)||"Unknown",l));return s({},n,r)}function ws(e){return e=(e=e.stateNode)&&e.__reactInternalMemoizedMergedChildContext||cs,gs=ds.current,us(ds,e),us(fs,fs.current),!0}function ks(e,t,n){var r=e.stateNode;if(!r)throw Error(o(169));n?(e=bs(e,t,gs),r.__reactInternalMemoizedMergedChildContext=e,ps(fs),ps(ds),us(ds,e)):ps(fs),us(fs,n)}var xs=null,js=null,Ss=l.unstable_runWithPriority,Es=l.unstable_scheduleCallback,Os=l.unstable_cancelCallback,Cs=l.unstable_shouldYield,Ps=l.unstable_requestPaint,As=l.unstable_now,_s=l.unstable_getCurrentPriorityLevel,Ls=l.unstable_ImmediatePriority,Ns=l.unstable_UserBlockingPriority,Ts=l.unstable_NormalPriority,Rs=l.unstable_LowPriority,Ds=l.unstable_IdlePriority,Is={},Bs=void 0!==Ps?Ps:function(){},Ms=null,Fs=null,qs=!1,zs=As(),Us=1e4>zs?As:function(){return As()-zs};function Hs(){switch(_s()){case Ls:return 99;case Ns:return 98;case Ts:return 97;case Rs:return 96;case Ds:return 95;default:throw Error(o(332))}}function Vs(e){switch(e){case 99:return Ls;case 98:return Ns;case 97:return Ts;case 96:return Rs;case 95:return Ds;default:throw Error(o(332))}}function Qs(e,t){return e=Vs(e),Ss(e,t)}function $s(e,t,n){return e=Vs(e),Es(e,t,n)}function Ws(){if(null!==Fs){var e=Fs;Fs=null,Os(e)}Xs()}function Xs(){if(!qs&&null!==Ms){qs=!0;var e=0;try{var t=Ms;Qs(99,(function(){for(;e<t.length;e++){var n=t[e];do{n=n(!0)}while(null!==n)}})),Ms=null}catch(t){throw null!==Ms&&(Ms=Ms.slice(e+1)),Es(Ls,Ws),t}finally{qs=!1}}}var Ks=k.ReactCurrentBatchConfig;function Ys(e,t){if(e&&e.defaultProps){for(var n in t=s({},t),e=e.defaultProps)void 0===t[n]&&(t[n]=e[n]);return t}return t}var Gs=is(null),Js=null,Zs=null,el=null;function tl(){el=Zs=Js=null}function nl(e){var t=Gs.current;ps(Gs),e.type._context._currentValue=t}function rl(e,t){for(;null!==e;){var n=e.alternate;if((e.childLanes&t)===t){if(null===n||(n.childLanes&t)===t)break;n.childLanes|=t}else e.childLanes|=t,null!==n&&(n.childLanes|=t);e=e.return}}function sl(e,t){Js=e,el=Zs=null,null!==(e=e.dependencies)&&null!==e.firstContext&&(0!=(e.lanes&t)&&(Io=!0),e.firstContext=null)}function ll(e,t){if(el!==e&&!1!==t&&0!==t)if("number"==typeof t&&1073741823!==t||(el=e,t=1073741823),t={context:e,observedBits:t,next:null},null===Zs){if(null===Js)throw Error(o(308));Zs=t,Js.dependencies={lanes:0,firstContext:t,responders:null}}else Zs=Zs.next=t;return e._currentValue}var ol=!1;function al(e){e.updateQueue={baseState:e.memoizedState,firstBaseUpdate:null,lastBaseUpdate:null,shared:{pending:null},effects:null}}function il(e,t){e=e.updateQueue,t.updateQueue===e&&(t.updateQueue={baseState:e.baseState,firstBaseUpdate:e.firstBaseUpdate,lastBaseUpdate:e.lastBaseUpdate,shared:e.shared,effects:e.effects})}function pl(e,t){return{eventTime:e,lane:t,tag:0,payload:null,callback:null,next:null}}function ul(e,t){if(null!==(e=e.updateQueue)){var n=(e=e.shared).pending;null===n?t.next=t:(t.next=n.next,n.next=t),e.pending=t}}function cl(e,t){var n=e.updateQueue,r=e.alternate;if(null!==r&&n===(r=r.updateQueue)){var s=null,l=null;if(null!==(n=n.firstBaseUpdate)){do{var o={eventTime:n.eventTime,lane:n.lane,tag:n.tag,payload:n.payload,callback:n.callback,next:null};null===l?s=l=o:l=l.next=o,n=n.next}while(null!==n);null===l?s=l=t:l=l.next=t}else s=l=t;return n={baseState:r.baseState,firstBaseUpdate:s,lastBaseUpdate:l,shared:r.shared,effects:r.effects},void(e.updateQueue=n)}null===(e=n.lastBaseUpdate)?n.firstBaseUpdate=t:e.next=t,n.lastBaseUpdate=t}function dl(e,t,n,r){var l=e.updateQueue;ol=!1;var o=l.firstBaseUpdate,a=l.lastBaseUpdate,i=l.shared.pending;if(null!==i){l.shared.pending=null;var p=i,u=p.next;p.next=null,null===a?o=u:a.next=u,a=p;var c=e.alternate;if(null!==c){var d=(c=c.updateQueue).lastBaseUpdate;d!==a&&(null===d?c.firstBaseUpdate=u:d.next=u,c.lastBaseUpdate=p)}}if(null!==o){for(d=l.baseState,a=0,c=u=p=null;;){i=o.lane;var f=o.eventTime;if((r&i)===i){null!==c&&(c=c.next={eventTime:f,lane:0,tag:o.tag,payload:o.payload,callback:o.callback,next:null});e:{var g=e,h=o;switch(i=t,f=n,h.tag){case 1:if("function"==typeof(g=h.payload)){d=g.call(f,d,i);break e}d=g;break e;case 3:g.flags=-4097&g.flags|64;case 0:if(null==(i="function"==typeof(g=h.payload)?g.call(f,d,i):g))break e;d=s({},d,i);break e;case 2:ol=!0}}null!==o.callback&&(e.flags|=32,null===(i=l.effects)?l.effects=[o]:i.push(o))}else f={eventTime:f,lane:i,tag:o.tag,payload:o.payload,callback:o.callback,next:null},null===c?(u=c=f,p=d):c=c.next=f,a|=i;if(null===(o=o.next)){if(null===(i=l.shared.pending))break;o=i.next,i.next=null,l.lastBaseUpdate=i,l.shared.pending=null}}null===c&&(p=d),l.baseState=p,l.firstBaseUpdate=u,l.lastBaseUpdate=c,Ma|=a,e.lanes=a,e.memoizedState=d}}function fl(e,t,n){if(e=t.effects,t.effects=null,null!==e)for(t=0;t<e.length;t++){var r=e[t],s=r.callback;if(null!==s){if(r.callback=null,r=n,"function"!=typeof s)throw Error(o(191,s));s.call(r)}}}var gl=(new r.Component).refs;function hl(e,t,n,r){n=null==(n=n(r,t=e.memoizedState))?t:s({},t,n),e.memoizedState=n,0===e.lanes&&(e.updateQueue.baseState=n)}var vl={isMounted:function(e){return!!(e=e._reactInternals)&&Ke(e)===e},enqueueSetState:function(e,t,n){e=e._reactInternals;var r=pi(),s=ui(e),l=pl(r,s);l.payload=t,null!=n&&(l.callback=n),ul(e,l),ci(e,s,r)},enqueueReplaceState:function(e,t,n){e=e._reactInternals;var r=pi(),s=ui(e),l=pl(r,s);l.tag=1,l.payload=t,null!=n&&(l.callback=n),ul(e,l),ci(e,s,r)},enqueueForceUpdate:function(e,t){e=e._reactInternals;var n=pi(),r=ui(e),s=pl(n,r);s.tag=2,null!=t&&(s.callback=t),ul(e,s),ci(e,r,n)}};function ml(e,t,n,r,s,l,o){return"function"==typeof(e=e.stateNode).shouldComponentUpdate?e.shouldComponentUpdate(r,l,o):!(t.prototype&&t.prototype.isPureReactComponent&&cr(n,r)&&cr(s,l))}function yl(e,t,n){var r=!1,s=cs,l=t.contextType;return"object"==typeof l&&null!==l?l=ll(l):(s=vs(t)?gs:ds.current,l=(r=null!=(r=t.contextTypes))?hs(e,s):cs),t=new t(n,l),e.memoizedState=null!==t.state&&void 0!==t.state?t.state:null,t.updater=vl,e.stateNode=t,t._reactInternals=e,r&&((e=e.stateNode).__reactInternalMemoizedUnmaskedChildContext=s,e.__reactInternalMemoizedMaskedChildContext=l),t}function bl(e,t,n,r){e=t.state,"function"==typeof t.componentWillReceiveProps&&t.componentWillReceiveProps(n,r),"function"==typeof t.UNSAFE_componentWillReceiveProps&&t.UNSAFE_componentWillReceiveProps(n,r),t.state!==e&&vl.enqueueReplaceState(t,t.state,null)}function wl(e,t,n,r){var s=e.stateNode;s.props=n,s.state=e.memoizedState,s.refs=gl,al(e);var l=t.contextType;"object"==typeof l&&null!==l?s.context=ll(l):(l=vs(t)?gs:ds.current,s.context=hs(e,l)),dl(e,n,s,r),s.state=e.memoizedState,"function"==typeof(l=t.getDerivedStateFromProps)&&(hl(e,t,l,n),s.state=e.memoizedState),"function"==typeof t.getDerivedStateFromProps||"function"==typeof s.getSnapshotBeforeUpdate||"function"!=typeof s.UNSAFE_componentWillMount&&"function"!=typeof s.componentWillMount||(t=s.state,"function"==typeof s.componentWillMount&&s.componentWillMount(),"function"==typeof s.UNSAFE_componentWillMount&&s.UNSAFE_componentWillMount(),t!==s.state&&vl.enqueueReplaceState(s,s.state,null),dl(e,n,s,r),s.state=e.memoizedState),"function"==typeof s.componentDidMount&&(e.flags|=4)}var kl=Array.isArray;function xl(e,t,n){if(null!==(e=n.ref)&&"function"!=typeof e&&"object"!=typeof e){if(n._owner){if(n=n._owner){if(1!==n.tag)throw Error(o(309));var r=n.stateNode}if(!r)throw Error(o(147,e));var s=""+e;return null!==t&&null!==t.ref&&"function"==typeof t.ref&&t.ref._stringRef===s?t.ref:(t=function(e){var t=r.refs;t===gl&&(t=r.refs={}),null===e?delete t[s]:t[s]=e},t._stringRef=s,t)}if("string"!=typeof e)throw Error(o(284));if(!n._owner)throw Error(o(290,e))}return e}function jl(e,t){if("textarea"!==e.type)throw Error(o(31,"[object Object]"===Object.prototype.toString.call(t)?"object with keys {"+Object.keys(t).join(", ")+"}":t))}function Sl(e){function t(t,n){if(e){var r=t.lastEffect;null!==r?(r.nextEffect=n,t.lastEffect=n):t.firstEffect=t.lastEffect=n,n.nextEffect=null,n.flags=8}}function n(n,r){if(!e)return null;for(;null!==r;)t(n,r),r=r.sibling;return null}function r(e,t){for(e=new Map;null!==t;)null!==t.key?e.set(t.key,t):e.set(t.index,t),t=t.sibling;return e}function s(e,t){return(e=Hi(e,t)).index=0,e.sibling=null,e}function l(t,n,r){return t.index=r,e?null!==(r=t.alternate)?(r=r.index)<n?(t.flags=2,n):r:(t.flags=2,n):n}function a(t){return e&&null===t.alternate&&(t.flags=2),t}function i(e,t,n,r){return null===t||6!==t.tag?((t=Wi(n,e.mode,r)).return=e,t):((t=s(t,n)).return=e,t)}function p(e,t,n,r){return null!==t&&t.elementType===n.type?((r=s(t,n.props)).ref=xl(e,t,n),r.return=e,r):((r=Vi(n.type,n.key,n.props,null,e.mode,r)).ref=xl(e,t,n),r.return=e,r)}function u(e,t,n,r){return null===t||4!==t.tag||t.stateNode.containerInfo!==n.containerInfo||t.stateNode.implementation!==n.implementation?((t=Xi(n,e.mode,r)).return=e,t):((t=s(t,n.children||[])).return=e,t)}function c(e,t,n,r,l){return null===t||7!==t.tag?((t=Qi(n,e.mode,r,l)).return=e,t):((t=s(t,n)).return=e,t)}function d(e,t,n){if("string"==typeof t||"number"==typeof t)return(t=Wi(""+t,e.mode,n)).return=e,t;if("object"==typeof t&&null!==t){switch(t.$$typeof){case x:return(n=Vi(t.type,t.key,t.props,null,e.mode,n)).ref=xl(e,null,t),n.return=e,n;case j:return(t=Xi(t,e.mode,n)).return=e,t}if(kl(t)||U(t))return(t=Qi(t,e.mode,n,null)).return=e,t;jl(e,t)}return null}function f(e,t,n,r){var s=null!==t?t.key:null;if("string"==typeof n||"number"==typeof n)return null!==s?null:i(e,t,""+n,r);if("object"==typeof n&&null!==n){switch(n.$$typeof){case x:return n.key===s?n.type===S?c(e,t,n.props.children,r,s):p(e,t,n,r):null;case j:return n.key===s?u(e,t,n,r):null}if(kl(n)||U(n))return null!==s?null:c(e,t,n,r,null);jl(e,n)}return null}function g(e,t,n,r,s){if("string"==typeof r||"number"==typeof r)return i(t,e=e.get(n)||null,""+r,s);if("object"==typeof r&&null!==r){switch(r.$$typeof){case x:return e=e.get(null===r.key?n:r.key)||null,r.type===S?c(t,e,r.props.children,s,r.key):p(t,e,r,s);case j:return u(t,e=e.get(null===r.key?n:r.key)||null,r,s)}if(kl(r)||U(r))return c(t,e=e.get(n)||null,r,s,null);jl(t,r)}return null}function h(s,o,a,i){for(var p=null,u=null,c=o,h=o=0,v=null;null!==c&&h<a.length;h++){c.index>h?(v=c,c=null):v=c.sibling;var m=f(s,c,a[h],i);if(null===m){null===c&&(c=v);break}e&&c&&null===m.alternate&&t(s,c),o=l(m,o,h),null===u?p=m:u.sibling=m,u=m,c=v}if(h===a.length)return n(s,c),p;if(null===c){for(;h<a.length;h++)null!==(c=d(s,a[h],i))&&(o=l(c,o,h),null===u?p=c:u.sibling=c,u=c);return p}for(c=r(s,c);h<a.length;h++)null!==(v=g(c,s,h,a[h],i))&&(e&&null!==v.alternate&&c.delete(null===v.key?h:v.key),o=l(v,o,h),null===u?p=v:u.sibling=v,u=v);return e&&c.forEach((function(e){return t(s,e)})),p}function v(s,a,i,p){var u=U(i);if("function"!=typeof u)throw Error(o(150));if(null==(i=u.call(i)))throw Error(o(151));for(var c=u=null,h=a,v=a=0,m=null,y=i.next();null!==h&&!y.done;v++,y=i.next()){h.index>v?(m=h,h=null):m=h.sibling;var b=f(s,h,y.value,p);if(null===b){null===h&&(h=m);break}e&&h&&null===b.alternate&&t(s,h),a=l(b,a,v),null===c?u=b:c.sibling=b,c=b,h=m}if(y.done)return n(s,h),u;if(null===h){for(;!y.done;v++,y=i.next())null!==(y=d(s,y.value,p))&&(a=l(y,a,v),null===c?u=y:c.sibling=y,c=y);return u}for(h=r(s,h);!y.done;v++,y=i.next())null!==(y=g(h,s,v,y.value,p))&&(e&&null!==y.alternate&&h.delete(null===y.key?v:y.key),a=l(y,a,v),null===c?u=y:c.sibling=y,c=y);return e&&h.forEach((function(e){return t(s,e)})),u}return function(e,r,l,i){var p="object"==typeof l&&null!==l&&l.type===S&&null===l.key;p&&(l=l.props.children);var u="object"==typeof l&&null!==l;if(u)switch(l.$$typeof){case x:e:{for(u=l.key,p=r;null!==p;){if(p.key===u){if(7===p.tag){if(l.type===S){n(e,p.sibling),(r=s(p,l.props.children)).return=e,e=r;break e}}else if(p.elementType===l.type){n(e,p.sibling),(r=s(p,l.props)).ref=xl(e,p,l),r.return=e,e=r;break e}n(e,p);break}t(e,p),p=p.sibling}l.type===S?((r=Qi(l.props.children,e.mode,i,l.key)).return=e,e=r):((i=Vi(l.type,l.key,l.props,null,e.mode,i)).ref=xl(e,r,l),i.return=e,e=i)}return a(e);case j:e:{for(p=l.key;null!==r;){if(r.key===p){if(4===r.tag&&r.stateNode.containerInfo===l.containerInfo&&r.stateNode.implementation===l.implementation){n(e,r.sibling),(r=s(r,l.children||[])).return=e,e=r;break e}n(e,r);break}t(e,r),r=r.sibling}(r=Xi(l,e.mode,i)).return=e,e=r}return a(e)}if("string"==typeof l||"number"==typeof l)return l=""+l,null!==r&&6===r.tag?(n(e,r.sibling),(r=s(r,l)).return=e,e=r):(n(e,r),(r=Wi(l,e.mode,i)).return=e,e=r),a(e);if(kl(l))return h(e,r,l,i);if(U(l))return v(e,r,l,i);if(u&&jl(e,l),void 0===l&&!p)switch(e.tag){case 1:case 22:case 0:case 11:case 15:throw Error(o(152,W(e.type)||"Component"))}return n(e,r)}}var El=Sl(!0),Ol=Sl(!1),Cl={},Pl=is(Cl),Al=is(Cl),_l=is(Cl);function Ll(e){if(e===Cl)throw Error(o(174));return e}function Nl(e,t){switch(us(_l,t),us(Al,e),us(Pl,Cl),e=t.nodeType){case 9:case 11:t=(t=t.documentElement)?t.namespaceURI:fe(null,"");break;default:t=fe(t=(e=8===e?t.parentNode:t).namespaceURI||null,e=e.tagName)}ps(Pl),us(Pl,t)}function Tl(){ps(Pl),ps(Al),ps(_l)}function Rl(e){Ll(_l.current);var t=Ll(Pl.current),n=fe(t,e.type);t!==n&&(us(Al,e),us(Pl,n))}function Dl(e){Al.current===e&&(ps(Pl),ps(Al))}var Il=is(0);function Bl(e){for(var t=e;null!==t;){if(13===t.tag){var n=t.memoizedState;if(null!==n&&(null===(n=n.dehydrated)||"$?"===n.data||"$!"===n.data))return t}else if(19===t.tag&&void 0!==t.memoizedProps.revealOrder){if(0!=(64&t.flags))return t}else if(null!==t.child){t.child.return=t,t=t.child;continue}if(t===e)break;for(;null===t.sibling;){if(null===t.return||t.return===e)return null;t=t.return}t.sibling.return=t.return,t=t.sibling}return null}var Ml=null,Fl=null,ql=!1;function zl(e,t){var n=zi(5,null,null,0);n.elementType="DELETED",n.type="DELETED",n.stateNode=t,n.return=e,n.flags=8,null!==e.lastEffect?(e.lastEffect.nextEffect=n,e.lastEffect=n):e.firstEffect=e.lastEffect=n}function Ul(e,t){switch(e.tag){case 5:var n=e.type;return null!==(t=1!==t.nodeType||n.toLowerCase()!==t.nodeName.toLowerCase()?null:t)&&(e.stateNode=t,!0);case 6:return null!==(t=""===e.pendingProps||3!==t.nodeType?null:t)&&(e.stateNode=t,!0);default:return!1}}function Hl(e){if(ql){var t=Fl;if(t){var n=t;if(!Ul(e,t)){if(!(t=Wr(n.nextSibling))||!Ul(e,t))return e.flags=-1025&e.flags|2,ql=!1,void(Ml=e);zl(Ml,n)}Ml=e,Fl=Wr(t.firstChild)}else e.flags=-1025&e.flags|2,ql=!1,Ml=e}}function Vl(e){for(e=e.return;null!==e&&5!==e.tag&&3!==e.tag&&13!==e.tag;)e=e.return;Ml=e}function Ql(e){if(e!==Ml)return!1;if(!ql)return Vl(e),ql=!0,!1;var t=e.type;if(5!==e.tag||"head"!==t&&"body"!==t&&!Hr(t,e.memoizedProps))for(t=Fl;t;)zl(e,t),t=Wr(t.nextSibling);if(Vl(e),13===e.tag){if(!(e=null!==(e=e.memoizedState)?e.dehydrated:null))throw Error(o(317));e:{for(e=e.nextSibling,t=0;e;){if(8===e.nodeType){var n=e.data;if("/$"===n){if(0===t){Fl=Wr(e.nextSibling);break e}t--}else"$"!==n&&"$!"!==n&&"$?"!==n||t++}e=e.nextSibling}Fl=null}}else Fl=Ml?Wr(e.stateNode.nextSibling):null;return!0}function $l(){Fl=Ml=null,ql=!1}var Wl=[];function Xl(){for(var e=0;e<Wl.length;e++)Wl[e]._workInProgressVersionPrimary=null;Wl.length=0}var Kl=k.ReactCurrentDispatcher,Yl=k.ReactCurrentBatchConfig,Gl=0,Jl=null,Zl=null,eo=null,to=!1,no=!1;function ro(){throw Error(o(321))}function so(e,t){if(null===t)return!1;for(var n=0;n<t.length&&n<e.length;n++)if(!pr(e[n],t[n]))return!1;return!0}function lo(e,t,n,r,s,l){if(Gl=l,Jl=t,t.memoizedState=null,t.updateQueue=null,t.lanes=0,Kl.current=null===e||null===e.memoizedState?No:To,e=n(r,s),no){l=0;do{if(no=!1,!(25>l))throw Error(o(301));l+=1,eo=Zl=null,t.updateQueue=null,Kl.current=Ro,e=n(r,s)}while(no)}if(Kl.current=Lo,t=null!==Zl&&null!==Zl.next,Gl=0,eo=Zl=Jl=null,to=!1,t)throw Error(o(300));return e}function oo(){var e={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};return null===eo?Jl.memoizedState=eo=e:eo=eo.next=e,eo}function ao(){if(null===Zl){var e=Jl.alternate;e=null!==e?e.memoizedState:null}else e=Zl.next;var t=null===eo?Jl.memoizedState:eo.next;if(null!==t)eo=t,Zl=e;else{if(null===e)throw Error(o(310));e={memoizedState:(Zl=e).memoizedState,baseState:Zl.baseState,baseQueue:Zl.baseQueue,queue:Zl.queue,next:null},null===eo?Jl.memoizedState=eo=e:eo=eo.next=e}return eo}function io(e,t){return"function"==typeof t?t(e):t}function po(e){var t=ao(),n=t.queue;if(null===n)throw Error(o(311));n.lastRenderedReducer=e;var r=Zl,s=r.baseQueue,l=n.pending;if(null!==l){if(null!==s){var a=s.next;s.next=l.next,l.next=a}r.baseQueue=s=l,n.pending=null}if(null!==s){s=s.next,r=r.baseState;var i=a=l=null,p=s;do{var u=p.lane;if((Gl&u)===u)null!==i&&(i=i.next={lane:0,action:p.action,eagerReducer:p.eagerReducer,eagerState:p.eagerState,next:null}),r=p.eagerReducer===e?p.eagerState:e(r,p.action);else{var c={lane:u,action:p.action,eagerReducer:p.eagerReducer,eagerState:p.eagerState,next:null};null===i?(a=i=c,l=r):i=i.next=c,Jl.lanes|=u,Ma|=u}p=p.next}while(null!==p&&p!==s);null===i?l=r:i.next=a,pr(r,t.memoizedState)||(Io=!0),t.memoizedState=r,t.baseState=l,t.baseQueue=i,n.lastRenderedState=r}return[t.memoizedState,n.dispatch]}function uo(e){var t=ao(),n=t.queue;if(null===n)throw Error(o(311));n.lastRenderedReducer=e;var r=n.dispatch,s=n.pending,l=t.memoizedState;if(null!==s){n.pending=null;var a=s=s.next;do{l=e(l,a.action),a=a.next}while(a!==s);pr(l,t.memoizedState)||(Io=!0),t.memoizedState=l,null===t.baseQueue&&(t.baseState=l),n.lastRenderedState=l}return[l,r]}function co(e,t,n){var r=t._getVersion;r=r(t._source);var s=t._workInProgressVersionPrimary;if(null!==s?e=s===r:(e=e.mutableReadLanes,(e=(Gl&e)===e)&&(t._workInProgressVersionPrimary=r,Wl.push(t))),e)return n(t._source);throw Wl.push(t),Error(o(350))}function fo(e,t,n,r){var s=_a;if(null===s)throw Error(o(349));var l=t._getVersion,a=l(t._source),i=Kl.current,p=i.useState((function(){return co(s,t,n)})),u=p[1],c=p[0];p=eo;var d=e.memoizedState,f=d.refs,g=f.getSnapshot,h=d.source;d=d.subscribe;var v=Jl;return e.memoizedState={refs:f,source:t,subscribe:r},i.useEffect((function(){f.getSnapshot=n,f.setSnapshot=u;var e=l(t._source);if(!pr(a,e)){e=n(t._source),pr(c,e)||(u(e),e=ui(v),s.mutableReadLanes|=e&s.pendingLanes),e=s.mutableReadLanes,s.entangledLanes|=e;for(var r=s.entanglements,o=e;0<o;){var i=31-Ht(o),p=1<<i;r[i]|=e,o&=~p}}}),[n,t,r]),i.useEffect((function(){return r(t._source,(function(){var e=f.getSnapshot,n=f.setSnapshot;try{n(e(t._source));var r=ui(v);s.mutableReadLanes|=r&s.pendingLanes}catch(e){n((function(){throw e}))}}))}),[t,r]),pr(g,n)&&pr(h,t)&&pr(d,r)||((e={pending:null,dispatch:null,lastRenderedReducer:io,lastRenderedState:c}).dispatch=u=_o.bind(null,Jl,e),p.queue=e,p.baseQueue=null,c=co(s,t,n),p.memoizedState=p.baseState=c),c}function go(e,t,n){return fo(ao(),e,t,n)}function ho(e){var t=oo();return"function"==typeof e&&(e=e()),t.memoizedState=t.baseState=e,e=(e=t.queue={pending:null,dispatch:null,lastRenderedReducer:io,lastRenderedState:e}).dispatch=_o.bind(null,Jl,e),[t.memoizedState,e]}function vo(e,t,n,r){return e={tag:e,create:t,destroy:n,deps:r,next:null},null===(t=Jl.updateQueue)?(t={lastEffect:null},Jl.updateQueue=t,t.lastEffect=e.next=e):null===(n=t.lastEffect)?t.lastEffect=e.next=e:(r=n.next,n.next=e,e.next=r,t.lastEffect=e),e}function mo(e){return e={current:e},oo().memoizedState=e}function yo(){return ao().memoizedState}function bo(e,t,n,r){var s=oo();Jl.flags|=e,s.memoizedState=vo(1|t,n,void 0,void 0===r?null:r)}function wo(e,t,n,r){var s=ao();r=void 0===r?null:r;var l=void 0;if(null!==Zl){var o=Zl.memoizedState;if(l=o.destroy,null!==r&&so(r,o.deps))return void vo(t,n,l,r)}Jl.flags|=e,s.memoizedState=vo(1|t,n,l,r)}function ko(e,t){return bo(516,4,e,t)}function xo(e,t){return wo(516,4,e,t)}function jo(e,t){return wo(4,2,e,t)}function So(e,t){return"function"==typeof t?(e=e(),t(e),function(){t(null)}):null!=t?(e=e(),t.current=e,function(){t.current=null}):void 0}function Eo(e,t,n){return n=null!=n?n.concat([e]):null,wo(4,2,So.bind(null,t,e),n)}function Oo(){}function Co(e,t){var n=ao();t=void 0===t?null:t;var r=n.memoizedState;return null!==r&&null!==t&&so(t,r[1])?r[0]:(n.memoizedState=[e,t],e)}function Po(e,t){var n=ao();t=void 0===t?null:t;var r=n.memoizedState;return null!==r&&null!==t&&so(t,r[1])?r[0]:(e=e(),n.memoizedState=[e,t],e)}function Ao(e,t){var n=Hs();Qs(98>n?98:n,(function(){e(!0)})),Qs(97<n?97:n,(function(){var n=Yl.transition;Yl.transition=1;try{e(!1),t()}finally{Yl.transition=n}}))}function _o(e,t,n){var r=pi(),s=ui(e),l={lane:s,action:n,eagerReducer:null,eagerState:null,next:null},o=t.pending;if(null===o?l.next=l:(l.next=o.next,o.next=l),t.pending=l,o=e.alternate,e===Jl||null!==o&&o===Jl)no=to=!0;else{if(0===e.lanes&&(null===o||0===o.lanes)&&null!==(o=t.lastRenderedReducer))try{var a=t.lastRenderedState,i=o(a,n);if(l.eagerReducer=o,l.eagerState=i,pr(i,a))return}catch(e){}ci(e,s,r)}}var Lo={readContext:ll,useCallback:ro,useContext:ro,useEffect:ro,useImperativeHandle:ro,useLayoutEffect:ro,useMemo:ro,useReducer:ro,useRef:ro,useState:ro,useDebugValue:ro,useDeferredValue:ro,useTransition:ro,useMutableSource:ro,useOpaqueIdentifier:ro,unstable_isNewReconciler:!1},No={readContext:ll,useCallback:function(e,t){return oo().memoizedState=[e,void 0===t?null:t],e},useContext:ll,useEffect:ko,useImperativeHandle:function(e,t,n){return n=null!=n?n.concat([e]):null,bo(4,2,So.bind(null,t,e),n)},useLayoutEffect:function(e,t){return bo(4,2,e,t)},useMemo:function(e,t){var n=oo();return t=void 0===t?null:t,e=e(),n.memoizedState=[e,t],e},useReducer:function(e,t,n){var r=oo();return t=void 0!==n?n(t):t,r.memoizedState=r.baseState=t,e=(e=r.queue={pending:null,dispatch:null,lastRenderedReducer:e,lastRenderedState:t}).dispatch=_o.bind(null,Jl,e),[r.memoizedState,e]},useRef:mo,useState:ho,useDebugValue:Oo,useDeferredValue:function(e){var t=ho(e),n=t[0],r=t[1];return ko((function(){var t=Yl.transition;Yl.transition=1;try{r(e)}finally{Yl.transition=t}}),[e]),n},useTransition:function(){var e=ho(!1),t=e[0];return mo(e=Ao.bind(null,e[1])),[e,t]},useMutableSource:function(e,t,n){var r=oo();return r.memoizedState={refs:{getSnapshot:t,setSnapshot:null},source:e,subscribe:n},fo(r,e,t,n)},useOpaqueIdentifier:function(){if(ql){var e=!1,t=function(e){return{$$typeof:D,toString:e,valueOf:e}}((function(){throw e||(e=!0,n("r:"+(Kr++).toString(36))),Error(o(355))})),n=ho(t)[1];return 0==(2&Jl.mode)&&(Jl.flags|=516,vo(5,(function(){n("r:"+(Kr++).toString(36))}),void 0,null)),t}return ho(t="r:"+(Kr++).toString(36)),t},unstable_isNewReconciler:!1},To={readContext:ll,useCallback:Co,useContext:ll,useEffect:xo,useImperativeHandle:Eo,useLayoutEffect:jo,useMemo:Po,useReducer:po,useRef:yo,useState:function(){return po(io)},useDebugValue:Oo,useDeferredValue:function(e){var t=po(io),n=t[0],r=t[1];return xo((function(){var t=Yl.transition;Yl.transition=1;try{r(e)}finally{Yl.transition=t}}),[e]),n},useTransition:function(){var e=po(io)[0];return[yo().current,e]},useMutableSource:go,useOpaqueIdentifier:function(){return po(io)[0]},unstable_isNewReconciler:!1},Ro={readContext:ll,useCallback:Co,useContext:ll,useEffect:xo,useImperativeHandle:Eo,useLayoutEffect:jo,useMemo:Po,useReducer:uo,useRef:yo,useState:function(){return uo(io)},useDebugValue:Oo,useDeferredValue:function(e){var t=uo(io),n=t[0],r=t[1];return xo((function(){var t=Yl.transition;Yl.transition=1;try{r(e)}finally{Yl.transition=t}}),[e]),n},useTransition:function(){var e=uo(io)[0];return[yo().current,e]},useMutableSource:go,useOpaqueIdentifier:function(){return uo(io)[0]},unstable_isNewReconciler:!1},Do=k.ReactCurrentOwner,Io=!1;function Bo(e,t,n,r){t.child=null===e?Ol(t,null,n,r):El(t,e.child,n,r)}function Mo(e,t,n,r,s){n=n.render;var l=t.ref;return sl(t,s),r=lo(e,t,n,r,l,s),null===e||Io?(t.flags|=1,Bo(e,t,r,s),t.child):(t.updateQueue=e.updateQueue,t.flags&=-517,e.lanes&=~s,na(e,t,s))}function Fo(e,t,n,r,s,l){if(null===e){var o=n.type;return"function"!=typeof o||Ui(o)||void 0!==o.defaultProps||null!==n.compare||void 0!==n.defaultProps?((e=Vi(n.type,null,r,t,t.mode,l)).ref=t.ref,e.return=t,t.child=e):(t.tag=15,t.type=o,qo(e,t,o,r,s,l))}return o=e.child,0==(s&l)&&(s=o.memoizedProps,(n=null!==(n=n.compare)?n:cr)(s,r)&&e.ref===t.ref)?na(e,t,l):(t.flags|=1,(e=Hi(o,r)).ref=t.ref,e.return=t,t.child=e)}function qo(e,t,n,r,s,l){if(null!==e&&cr(e.memoizedProps,r)&&e.ref===t.ref){if(Io=!1,0==(l&s))return t.lanes=e.lanes,na(e,t,l);0!=(16384&e.flags)&&(Io=!0)}return Ho(e,t,n,r,l)}function zo(e,t,n){var r=t.pendingProps,s=r.children,l=null!==e?e.memoizedState:null;if("hidden"===r.mode||"unstable-defer-without-hiding"===r.mode)if(0==(4&t.mode))t.memoizedState={baseLanes:0},bi(0,n);else{if(0==(1073741824&n))return e=null!==l?l.baseLanes|n:n,t.lanes=t.childLanes=1073741824,t.memoizedState={baseLanes:e},bi(0,e),null;t.memoizedState={baseLanes:0},bi(0,null!==l?l.baseLanes:n)}else null!==l?(r=l.baseLanes|n,t.memoizedState=null):r=n,bi(0,r);return Bo(e,t,s,n),t.child}function Uo(e,t){var n=t.ref;(null===e&&null!==n||null!==e&&e.ref!==n)&&(t.flags|=128)}function Ho(e,t,n,r,s){var l=vs(n)?gs:ds.current;return l=hs(t,l),sl(t,s),n=lo(e,t,n,r,l,s),null===e||Io?(t.flags|=1,Bo(e,t,n,s),t.child):(t.updateQueue=e.updateQueue,t.flags&=-517,e.lanes&=~s,na(e,t,s))}function Vo(e,t,n,r,s){if(vs(n)){var l=!0;ws(t)}else l=!1;if(sl(t,s),null===t.stateNode)null!==e&&(e.alternate=null,t.alternate=null,t.flags|=2),yl(t,n,r),wl(t,n,r,s),r=!0;else if(null===e){var o=t.stateNode,a=t.memoizedProps;o.props=a;var i=o.context,p=n.contextType;p="object"==typeof p&&null!==p?ll(p):hs(t,p=vs(n)?gs:ds.current);var u=n.getDerivedStateFromProps,c="function"==typeof u||"function"==typeof o.getSnapshotBeforeUpdate;c||"function"!=typeof o.UNSAFE_componentWillReceiveProps&&"function"!=typeof o.componentWillReceiveProps||(a!==r||i!==p)&&bl(t,o,r,p),ol=!1;var d=t.memoizedState;o.state=d,dl(t,r,o,s),i=t.memoizedState,a!==r||d!==i||fs.current||ol?("function"==typeof u&&(hl(t,n,u,r),i=t.memoizedState),(a=ol||ml(t,n,a,r,d,i,p))?(c||"function"!=typeof o.UNSAFE_componentWillMount&&"function"!=typeof o.componentWillMount||("function"==typeof o.componentWillMount&&o.componentWillMount(),"function"==typeof o.UNSAFE_componentWillMount&&o.UNSAFE_componentWillMount()),"function"==typeof o.componentDidMount&&(t.flags|=4)):("function"==typeof o.componentDidMount&&(t.flags|=4),t.memoizedProps=r,t.memoizedState=i),o.props=r,o.state=i,o.context=p,r=a):("function"==typeof o.componentDidMount&&(t.flags|=4),r=!1)}else{o=t.stateNode,il(e,t),a=t.memoizedProps,p=t.type===t.elementType?a:Ys(t.type,a),o.props=p,c=t.pendingProps,d=o.context,i="object"==typeof(i=n.contextType)&&null!==i?ll(i):hs(t,i=vs(n)?gs:ds.current);var f=n.getDerivedStateFromProps;(u="function"==typeof f||"function"==typeof o.getSnapshotBeforeUpdate)||"function"!=typeof o.UNSAFE_componentWillReceiveProps&&"function"!=typeof o.componentWillReceiveProps||(a!==c||d!==i)&&bl(t,o,r,i),ol=!1,d=t.memoizedState,o.state=d,dl(t,r,o,s);var g=t.memoizedState;a!==c||d!==g||fs.current||ol?("function"==typeof f&&(hl(t,n,f,r),g=t.memoizedState),(p=ol||ml(t,n,p,r,d,g,i))?(u||"function"!=typeof o.UNSAFE_componentWillUpdate&&"function"!=typeof o.componentWillUpdate||("function"==typeof o.componentWillUpdate&&o.componentWillUpdate(r,g,i),"function"==typeof o.UNSAFE_componentWillUpdate&&o.UNSAFE_componentWillUpdate(r,g,i)),"function"==typeof o.componentDidUpdate&&(t.flags|=4),"function"==typeof o.getSnapshotBeforeUpdate&&(t.flags|=256)):("function"!=typeof o.componentDidUpdate||a===e.memoizedProps&&d===e.memoizedState||(t.flags|=4),"function"!=typeof o.getSnapshotBeforeUpdate||a===e.memoizedProps&&d===e.memoizedState||(t.flags|=256),t.memoizedProps=r,t.memoizedState=g),o.props=r,o.state=g,o.context=i,r=p):("function"!=typeof o.componentDidUpdate||a===e.memoizedProps&&d===e.memoizedState||(t.flags|=4),"function"!=typeof o.getSnapshotBeforeUpdate||a===e.memoizedProps&&d===e.memoizedState||(t.flags|=256),r=!1)}return Qo(e,t,n,r,l,s)}function Qo(e,t,n,r,s,l){Uo(e,t);var o=0!=(64&t.flags);if(!r&&!o)return s&&ks(t,n,!1),na(e,t,l);r=t.stateNode,Do.current=t;var a=o&&"function"!=typeof n.getDerivedStateFromError?null:r.render();return t.flags|=1,null!==e&&o?(t.child=El(t,e.child,null,l),t.child=El(t,null,a,l)):Bo(e,t,a,l),t.memoizedState=r.state,s&&ks(t,n,!0),t.child}function $o(e){var t=e.stateNode;t.pendingContext?ys(0,t.pendingContext,t.pendingContext!==t.context):t.context&&ys(0,t.context,!1),Nl(e,t.containerInfo)}var Wo,Xo,Ko,Yo={dehydrated:null,retryLane:0};function Go(e,t,n){var r,s=t.pendingProps,l=Il.current,o=!1;return(r=0!=(64&t.flags))||(r=(null===e||null!==e.memoizedState)&&0!=(2&l)),r?(o=!0,t.flags&=-65):null!==e&&null===e.memoizedState||void 0===s.fallback||!0===s.unstable_avoidThisFallback||(l|=1),us(Il,1&l),null===e?(void 0!==s.fallback&&Hl(t),e=s.children,l=s.fallback,o?(e=Jo(t,e,l,n),t.child.memoizedState={baseLanes:n},t.memoizedState=Yo,e):"number"==typeof s.unstable_expectedLoadTime?(e=Jo(t,e,l,n),t.child.memoizedState={baseLanes:n},t.memoizedState=Yo,t.lanes=33554432,e):((n=$i({mode:"visible",children:e},t.mode,n,null)).return=t,t.child=n)):(e.memoizedState,o?(s=function(e,t,n,r,s){var l=t.mode,o=e.child;e=o.sibling;var a={mode:"hidden",children:n};return 0==(2&l)&&t.child!==o?((n=t.child).childLanes=0,n.pendingProps=a,null!==(o=n.lastEffect)?(t.firstEffect=n.firstEffect,t.lastEffect=o,o.nextEffect=null):t.firstEffect=t.lastEffect=null):n=Hi(o,a),null!==e?r=Hi(e,r):(r=Qi(r,l,s,null)).flags|=2,r.return=t,n.return=t,n.sibling=r,t.child=n,r}(e,t,s.children,s.fallback,n),o=t.child,l=e.child.memoizedState,o.memoizedState=null===l?{baseLanes:n}:{baseLanes:l.baseLanes|n},o.childLanes=e.childLanes&~n,t.memoizedState=Yo,s):(n=function(e,t,n,r){var s=e.child;return e=s.sibling,n=Hi(s,{mode:"visible",children:n}),0==(2&t.mode)&&(n.lanes=r),n.return=t,n.sibling=null,null!==e&&(e.nextEffect=null,e.flags=8,t.firstEffect=t.lastEffect=e),t.child=n}(e,t,s.children,n),t.memoizedState=null,n))}function Jo(e,t,n,r){var s=e.mode,l=e.child;return t={mode:"hidden",children:t},0==(2&s)&&null!==l?(l.childLanes=0,l.pendingProps=t):l=$i(t,s,0,null),n=Qi(n,s,r,null),l.return=e,n.return=e,l.sibling=n,e.child=l,n}function Zo(e,t){e.lanes|=t;var n=e.alternate;null!==n&&(n.lanes|=t),rl(e.return,t)}function ea(e,t,n,r,s,l){var o=e.memoizedState;null===o?e.memoizedState={isBackwards:t,rendering:null,renderingStartTime:0,last:r,tail:n,tailMode:s,lastEffect:l}:(o.isBackwards=t,o.rendering=null,o.renderingStartTime=0,o.last=r,o.tail=n,o.tailMode=s,o.lastEffect=l)}function ta(e,t,n){var r=t.pendingProps,s=r.revealOrder,l=r.tail;if(Bo(e,t,r.children,n),0!=(2&(r=Il.current)))r=1&r|2,t.flags|=64;else{if(null!==e&&0!=(64&e.flags))e:for(e=t.child;null!==e;){if(13===e.tag)null!==e.memoizedState&&Zo(e,n);else if(19===e.tag)Zo(e,n);else if(null!==e.child){e.child.return=e,e=e.child;continue}if(e===t)break e;for(;null===e.sibling;){if(null===e.return||e.return===t)break e;e=e.return}e.sibling.return=e.return,e=e.sibling}r&=1}if(us(Il,r),0==(2&t.mode))t.memoizedState=null;else switch(s){case"forwards":for(n=t.child,s=null;null!==n;)null!==(e=n.alternate)&&null===Bl(e)&&(s=n),n=n.sibling;null===(n=s)?(s=t.child,t.child=null):(s=n.sibling,n.sibling=null),ea(t,!1,s,n,l,t.lastEffect);break;case"backwards":for(n=null,s=t.child,t.child=null;null!==s;){if(null!==(e=s.alternate)&&null===Bl(e)){t.child=s;break}e=s.sibling,s.sibling=n,n=s,s=e}ea(t,!0,n,null,l,t.lastEffect);break;case"together":ea(t,!1,null,null,void 0,t.lastEffect);break;default:t.memoizedState=null}return t.child}function na(e,t,n){if(null!==e&&(t.dependencies=e.dependencies),Ma|=t.lanes,0!=(n&t.childLanes)){if(null!==e&&t.child!==e.child)throw Error(o(153));if(null!==t.child){for(n=Hi(e=t.child,e.pendingProps),t.child=n,n.return=t;null!==e.sibling;)e=e.sibling,(n=n.sibling=Hi(e,e.pendingProps)).return=t;n.sibling=null}return t.child}return null}function ra(e,t){if(!ql)switch(e.tailMode){case"hidden":t=e.tail;for(var n=null;null!==t;)null!==t.alternate&&(n=t),t=t.sibling;null===n?e.tail=null:n.sibling=null;break;case"collapsed":n=e.tail;for(var r=null;null!==n;)null!==n.alternate&&(r=n),n=n.sibling;null===r?t||null===e.tail?e.tail=null:e.tail.sibling=null:r.sibling=null}}function sa(e,t,n){var r=t.pendingProps;switch(t.tag){case 2:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return null;case 1:case 17:return vs(t.type)&&ms(),null;case 3:return Tl(),ps(fs),ps(ds),Xl(),(r=t.stateNode).pendingContext&&(r.context=r.pendingContext,r.pendingContext=null),null!==e&&null!==e.child||(Ql(t)?t.flags|=4:r.hydrate||(t.flags|=256)),null;case 5:Dl(t);var l=Ll(_l.current);if(n=t.type,null!==e&&null!=t.stateNode)Xo(e,t,n,r),e.ref!==t.ref&&(t.flags|=128);else{if(!r){if(null===t.stateNode)throw Error(o(166));return null}if(e=Ll(Pl.current),Ql(t)){r=t.stateNode,n=t.type;var a=t.memoizedProps;switch(r[Gr]=t,r[Jr]=a,n){case"dialog":Ar("cancel",r),Ar("close",r);break;case"iframe":case"object":case"embed":Ar("load",r);break;case"video":case"audio":for(e=0;e<Er.length;e++)Ar(Er[e],r);break;case"source":Ar("error",r);break;case"img":case"image":case"link":Ar("error",r),Ar("load",r);break;case"details":Ar("toggle",r);break;case"input":ee(r,a),Ar("invalid",r);break;case"select":r._wrapperState={wasMultiple:!!a.multiple},Ar("invalid",r);break;case"textarea":ie(r,a),Ar("invalid",r)}for(var p in je(n,a),e=null,a)a.hasOwnProperty(p)&&(l=a[p],"children"===p?"string"==typeof l?r.textContent!==l&&(e=["children",l]):"number"==typeof l&&r.textContent!==""+l&&(e=["children",""+l]):i.hasOwnProperty(p)&&null!=l&&"onScroll"===p&&Ar("scroll",r));switch(n){case"input":Y(r),re(r,a,!0);break;case"textarea":Y(r),ue(r);break;case"select":case"option":break;default:"function"==typeof a.onClick&&(r.onclick=Fr)}r=e,t.updateQueue=r,null!==r&&(t.flags|=4)}else{switch(p=9===l.nodeType?l:l.ownerDocument,e===ce&&(e=de(n)),e===ce?"script"===n?((e=p.createElement("div")).innerHTML="<script><\/script>",e=e.removeChild(e.firstChild)):"string"==typeof r.is?e=p.createElement(n,{is:r.is}):(e=p.createElement(n),"select"===n&&(p=e,r.multiple?p.multiple=!0:r.size&&(p.size=r.size))):e=p.createElementNS(e,n),e[Gr]=t,e[Jr]=r,Wo(e,t),t.stateNode=e,p=Se(n,r),n){case"dialog":Ar("cancel",e),Ar("close",e),l=r;break;case"iframe":case"object":case"embed":Ar("load",e),l=r;break;case"video":case"audio":for(l=0;l<Er.length;l++)Ar(Er[l],e);l=r;break;case"source":Ar("error",e),l=r;break;case"img":case"image":case"link":Ar("error",e),Ar("load",e),l=r;break;case"details":Ar("toggle",e),l=r;break;case"input":ee(e,r),l=Z(e,r),Ar("invalid",e);break;case"option":l=le(e,r);break;case"select":e._wrapperState={wasMultiple:!!r.multiple},l=s({},r,{value:void 0}),Ar("invalid",e);break;case"textarea":ie(e,r),l=ae(e,r),Ar("invalid",e);break;default:l=r}je(n,l);var u=l;for(a in u)if(u.hasOwnProperty(a)){var c=u[a];"style"===a?ke(e,c):"dangerouslySetInnerHTML"===a?null!=(c=c?c.__html:void 0)&&ve(e,c):"children"===a?"string"==typeof c?("textarea"!==n||""!==c)&&me(e,c):"number"==typeof c&&me(e,""+c):"suppressContentEditableWarning"!==a&&"suppressHydrationWarning"!==a&&"autoFocus"!==a&&(i.hasOwnProperty(a)?null!=c&&"onScroll"===a&&Ar("scroll",e):null!=c&&w(e,a,c,p))}switch(n){case"input":Y(e),re(e,r,!1);break;case"textarea":Y(e),ue(e);break;case"option":null!=r.value&&e.setAttribute("value",""+X(r.value));break;case"select":e.multiple=!!r.multiple,null!=(a=r.value)?oe(e,!!r.multiple,a,!1):null!=r.defaultValue&&oe(e,!!r.multiple,r.defaultValue,!0);break;default:"function"==typeof l.onClick&&(e.onclick=Fr)}Ur(n,r)&&(t.flags|=4)}null!==t.ref&&(t.flags|=128)}return null;case 6:if(e&&null!=t.stateNode)Ko(0,t,e.memoizedProps,r);else{if("string"!=typeof r&&null===t.stateNode)throw Error(o(166));n=Ll(_l.current),Ll(Pl.current),Ql(t)?(r=t.stateNode,n=t.memoizedProps,r[Gr]=t,r.nodeValue!==n&&(t.flags|=4)):((r=(9===n.nodeType?n:n.ownerDocument).createTextNode(r))[Gr]=t,t.stateNode=r)}return null;case 13:return ps(Il),r=t.memoizedState,0!=(64&t.flags)?(t.lanes=n,t):(r=null!==r,n=!1,null===e?void 0!==t.memoizedProps.fallback&&Ql(t):n=null!==e.memoizedState,r&&!n&&0!=(2&t.mode)&&(null===e&&!0!==t.memoizedProps.unstable_avoidThisFallback||0!=(1&Il.current)?0===Da&&(Da=3):(0!==Da&&3!==Da||(Da=4),null===_a||0==(134217727&Ma)&&0==(134217727&Fa)||hi(_a,Na))),(r||n)&&(t.flags|=4),null);case 4:return Tl(),null===e&&Lr(t.stateNode.containerInfo),null;case 10:return nl(t),null;case 19:if(ps(Il),null===(r=t.memoizedState))return null;if(a=0!=(64&t.flags),null===(p=r.rendering))if(a)ra(r,!1);else{if(0!==Da||null!==e&&0!=(64&e.flags))for(e=t.child;null!==e;){if(null!==(p=Bl(e))){for(t.flags|=64,ra(r,!1),null!==(a=p.updateQueue)&&(t.updateQueue=a,t.flags|=4),null===r.lastEffect&&(t.firstEffect=null),t.lastEffect=r.lastEffect,r=n,n=t.child;null!==n;)e=r,(a=n).flags&=2,a.nextEffect=null,a.firstEffect=null,a.lastEffect=null,null===(p=a.alternate)?(a.childLanes=0,a.lanes=e,a.child=null,a.memoizedProps=null,a.memoizedState=null,a.updateQueue=null,a.dependencies=null,a.stateNode=null):(a.childLanes=p.childLanes,a.lanes=p.lanes,a.child=p.child,a.memoizedProps=p.memoizedProps,a.memoizedState=p.memoizedState,a.updateQueue=p.updateQueue,a.type=p.type,e=p.dependencies,a.dependencies=null===e?null:{lanes:e.lanes,firstContext:e.firstContext}),n=n.sibling;return us(Il,1&Il.current|2),t.child}e=e.sibling}null!==r.tail&&Us()>Ha&&(t.flags|=64,a=!0,ra(r,!1),t.lanes=33554432)}else{if(!a)if(null!==(e=Bl(p))){if(t.flags|=64,a=!0,null!==(n=e.updateQueue)&&(t.updateQueue=n,t.flags|=4),ra(r,!0),null===r.tail&&"hidden"===r.tailMode&&!p.alternate&&!ql)return null!==(t=t.lastEffect=r.lastEffect)&&(t.nextEffect=null),null}else 2*Us()-r.renderingStartTime>Ha&&1073741824!==n&&(t.flags|=64,a=!0,ra(r,!1),t.lanes=33554432);r.isBackwards?(p.sibling=t.child,t.child=p):(null!==(n=r.last)?n.sibling=p:t.child=p,r.last=p)}return null!==r.tail?(n=r.tail,r.rendering=n,r.tail=n.sibling,r.lastEffect=t.lastEffect,r.renderingStartTime=Us(),n.sibling=null,t=Il.current,us(Il,a?1&t|2:1&t),n):null;case 23:case 24:return wi(),null!==e&&null!==e.memoizedState!=(null!==t.memoizedState)&&"unstable-defer-without-hiding"!==r.mode&&(t.flags|=4),null}throw Error(o(156,t.tag))}function la(e){switch(e.tag){case 1:vs(e.type)&&ms();var t=e.flags;return 4096&t?(e.flags=-4097&t|64,e):null;case 3:if(Tl(),ps(fs),ps(ds),Xl(),0!=(64&(t=e.flags)))throw Error(o(285));return e.flags=-4097&t|64,e;case 5:return Dl(e),null;case 13:return ps(Il),4096&(t=e.flags)?(e.flags=-4097&t|64,e):null;case 19:return ps(Il),null;case 4:return Tl(),null;case 10:return nl(e),null;case 23:case 24:return wi(),null;default:return null}}function oa(e,t){try{var n="",r=t;do{n+=$(r),r=r.return}while(r);var s=n}catch(e){s="\nError generating stack: "+e.message+"\n"+e.stack}return{value:e,source:t,stack:s}}function aa(e,t){try{console.error(t.value)}catch(e){setTimeout((function(){throw e}))}}Wo=function(e,t){for(var n=t.child;null!==n;){if(5===n.tag||6===n.tag)e.appendChild(n.stateNode);else if(4!==n.tag&&null!==n.child){n.child.return=n,n=n.child;continue}if(n===t)break;for(;null===n.sibling;){if(null===n.return||n.return===t)return;n=n.return}n.sibling.return=n.return,n=n.sibling}},Xo=function(e,t,n,r){var l=e.memoizedProps;if(l!==r){e=t.stateNode,Ll(Pl.current);var o,a=null;switch(n){case"input":l=Z(e,l),r=Z(e,r),a=[];break;case"option":l=le(e,l),r=le(e,r),a=[];break;case"select":l=s({},l,{value:void 0}),r=s({},r,{value:void 0}),a=[];break;case"textarea":l=ae(e,l),r=ae(e,r),a=[];break;default:"function"!=typeof l.onClick&&"function"==typeof r.onClick&&(e.onclick=Fr)}for(c in je(n,r),n=null,l)if(!r.hasOwnProperty(c)&&l.hasOwnProperty(c)&&null!=l[c])if("style"===c){var p=l[c];for(o in p)p.hasOwnProperty(o)&&(n||(n={}),n[o]="")}else"dangerouslySetInnerHTML"!==c&&"children"!==c&&"suppressContentEditableWarning"!==c&&"suppressHydrationWarning"!==c&&"autoFocus"!==c&&(i.hasOwnProperty(c)?a||(a=[]):(a=a||[]).push(c,null));for(c in r){var u=r[c];if(p=null!=l?l[c]:void 0,r.hasOwnProperty(c)&&u!==p&&(null!=u||null!=p))if("style"===c)if(p){for(o in p)!p.hasOwnProperty(o)||u&&u.hasOwnProperty(o)||(n||(n={}),n[o]="");for(o in u)u.hasOwnProperty(o)&&p[o]!==u[o]&&(n||(n={}),n[o]=u[o])}else n||(a||(a=[]),a.push(c,n)),n=u;else"dangerouslySetInnerHTML"===c?(u=u?u.__html:void 0,p=p?p.__html:void 0,null!=u&&p!==u&&(a=a||[]).push(c,u)):"children"===c?"string"!=typeof u&&"number"!=typeof u||(a=a||[]).push(c,""+u):"suppressContentEditableWarning"!==c&&"suppressHydrationWarning"!==c&&(i.hasOwnProperty(c)?(null!=u&&"onScroll"===c&&Ar("scroll",e),a||p===u||(a=[])):"object"==typeof u&&null!==u&&u.$$typeof===D?u.toString():(a=a||[]).push(c,u))}n&&(a=a||[]).push("style",n);var c=a;(t.updateQueue=c)&&(t.flags|=4)}},Ko=function(e,t,n,r){n!==r&&(t.flags|=4)};var ia="function"==typeof WeakMap?WeakMap:Map;function pa(e,t,n){(n=pl(-1,n)).tag=3,n.payload={element:null};var r=t.value;return n.callback=function(){Wa||(Wa=!0,Xa=r),aa(0,t)},n}function ua(e,t,n){(n=pl(-1,n)).tag=3;var r=e.type.getDerivedStateFromError;if("function"==typeof r){var s=t.value;n.payload=function(){return aa(0,t),r(s)}}var l=e.stateNode;return null!==l&&"function"==typeof l.componentDidCatch&&(n.callback=function(){"function"!=typeof r&&(null===Ka?Ka=new Set([this]):Ka.add(this),aa(0,t));var e=t.stack;this.componentDidCatch(t.value,{componentStack:null!==e?e:""})}),n}var ca="function"==typeof WeakSet?WeakSet:Set;function da(e){var t=e.ref;if(null!==t)if("function"==typeof t)try{t(null)}catch(t){Bi(e,t)}else t.current=null}function fa(e,t){switch(t.tag){case 0:case 11:case 15:case 22:case 5:case 6:case 4:case 17:return;case 1:if(256&t.flags&&null!==e){var n=e.memoizedProps,r=e.memoizedState;t=(e=t.stateNode).getSnapshotBeforeUpdate(t.elementType===t.type?n:Ys(t.type,n),r),e.__reactInternalSnapshotBeforeUpdate=t}return;case 3:return void(256&t.flags&&$r(t.stateNode.containerInfo))}throw Error(o(163))}function ga(e,t,n){switch(n.tag){case 0:case 11:case 15:case 22:if(null!==(t=null!==(t=n.updateQueue)?t.lastEffect:null)){e=t=t.next;do{if(3==(3&e.tag)){var r=e.create;e.destroy=r()}e=e.next}while(e!==t)}if(null!==(t=null!==(t=n.updateQueue)?t.lastEffect:null)){e=t=t.next;do{var s=e;r=s.next,0!=(4&(s=s.tag))&&0!=(1&s)&&(Ri(n,e),Ti(n,e)),e=r}while(e!==t)}return;case 1:return e=n.stateNode,4&n.flags&&(null===t?e.componentDidMount():(r=n.elementType===n.type?t.memoizedProps:Ys(n.type,t.memoizedProps),e.componentDidUpdate(r,t.memoizedState,e.__reactInternalSnapshotBeforeUpdate))),void(null!==(t=n.updateQueue)&&fl(n,t,e));case 3:if(null!==(t=n.updateQueue)){if(e=null,null!==n.child)switch(n.child.tag){case 5:case 1:e=n.child.stateNode}fl(n,t,e)}return;case 5:return e=n.stateNode,void(null===t&&4&n.flags&&Ur(n.type,n.memoizedProps)&&e.focus());case 6:case 4:case 12:case 19:case 17:case 20:case 21:case 23:case 24:return;case 13:return void(null===n.memoizedState&&(n=n.alternate,null!==n&&(n=n.memoizedState,null!==n&&(n=n.dehydrated,null!==n&&kt(n)))))}throw Error(o(163))}function ha(e,t){for(var n=e;;){if(5===n.tag){var r=n.stateNode;if(t)"function"==typeof(r=r.style).setProperty?r.setProperty("display","none","important"):r.display="none";else{r=n.stateNode;var s=n.memoizedProps.style;s=null!=s&&s.hasOwnProperty("display")?s.display:null,r.style.display=we("display",s)}}else if(6===n.tag)n.stateNode.nodeValue=t?"":n.memoizedProps;else if((23!==n.tag&&24!==n.tag||null===n.memoizedState||n===e)&&null!==n.child){n.child.return=n,n=n.child;continue}if(n===e)break;for(;null===n.sibling;){if(null===n.return||n.return===e)return;n=n.return}n.sibling.return=n.return,n=n.sibling}}function va(e,t){if(js&&"function"==typeof js.onCommitFiberUnmount)try{js.onCommitFiberUnmount(xs,t)}catch(e){}switch(t.tag){case 0:case 11:case 14:case 15:case 22:if(null!==(e=t.updateQueue)&&null!==(e=e.lastEffect)){var n=e=e.next;do{var r=n,s=r.destroy;if(r=r.tag,void 0!==s)if(0!=(4&r))Ri(t,n);else{r=t;try{s()}catch(e){Bi(r,e)}}n=n.next}while(n!==e)}break;case 1:if(da(t),"function"==typeof(e=t.stateNode).componentWillUnmount)try{e.props=t.memoizedProps,e.state=t.memoizedState,e.componentWillUnmount()}catch(e){Bi(t,e)}break;case 5:da(t);break;case 4:xa(e,t)}}function ma(e){e.alternate=null,e.child=null,e.dependencies=null,e.firstEffect=null,e.lastEffect=null,e.memoizedProps=null,e.memoizedState=null,e.pendingProps=null,e.return=null,e.updateQueue=null}function ya(e){return 5===e.tag||3===e.tag||4===e.tag}function ba(e){e:{for(var t=e.return;null!==t;){if(ya(t))break e;t=t.return}throw Error(o(160))}var n=t;switch(t=n.stateNode,n.tag){case 5:var r=!1;break;case 3:case 4:t=t.containerInfo,r=!0;break;default:throw Error(o(161))}16&n.flags&&(me(t,""),n.flags&=-17);e:t:for(n=e;;){for(;null===n.sibling;){if(null===n.return||ya(n.return)){n=null;break e}n=n.return}for(n.sibling.return=n.return,n=n.sibling;5!==n.tag&&6!==n.tag&&18!==n.tag;){if(2&n.flags)continue t;if(null===n.child||4===n.tag)continue t;n.child.return=n,n=n.child}if(!(2&n.flags)){n=n.stateNode;break e}}r?wa(e,n,t):ka(e,n,t)}function wa(e,t,n){var r=e.tag,s=5===r||6===r;if(s)e=s?e.stateNode:e.stateNode.instance,t?8===n.nodeType?n.parentNode.insertBefore(e,t):n.insertBefore(e,t):(8===n.nodeType?(t=n.parentNode).insertBefore(e,n):(t=n).appendChild(e),null!=(n=n._reactRootContainer)||null!==t.onclick||(t.onclick=Fr));else if(4!==r&&null!==(e=e.child))for(wa(e,t,n),e=e.sibling;null!==e;)wa(e,t,n),e=e.sibling}function ka(e,t,n){var r=e.tag,s=5===r||6===r;if(s)e=s?e.stateNode:e.stateNode.instance,t?n.insertBefore(e,t):n.appendChild(e);else if(4!==r&&null!==(e=e.child))for(ka(e,t,n),e=e.sibling;null!==e;)ka(e,t,n),e=e.sibling}function xa(e,t){for(var n,r,s=t,l=!1;;){if(!l){l=s.return;e:for(;;){if(null===l)throw Error(o(160));switch(n=l.stateNode,l.tag){case 5:r=!1;break e;case 3:case 4:n=n.containerInfo,r=!0;break e}l=l.return}l=!0}if(5===s.tag||6===s.tag){e:for(var a=e,i=s,p=i;;)if(va(a,p),null!==p.child&&4!==p.tag)p.child.return=p,p=p.child;else{if(p===i)break e;for(;null===p.sibling;){if(null===p.return||p.return===i)break e;p=p.return}p.sibling.return=p.return,p=p.sibling}r?(a=n,i=s.stateNode,8===a.nodeType?a.parentNode.removeChild(i):a.removeChild(i)):n.removeChild(s.stateNode)}else if(4===s.tag){if(null!==s.child){n=s.stateNode.containerInfo,r=!0,s.child.return=s,s=s.child;continue}}else if(va(e,s),null!==s.child){s.child.return=s,s=s.child;continue}if(s===t)break;for(;null===s.sibling;){if(null===s.return||s.return===t)return;4===(s=s.return).tag&&(l=!1)}s.sibling.return=s.return,s=s.sibling}}function ja(e,t){switch(t.tag){case 0:case 11:case 14:case 15:case 22:var n=t.updateQueue;if(null!==(n=null!==n?n.lastEffect:null)){var r=n=n.next;do{3==(3&r.tag)&&(e=r.destroy,r.destroy=void 0,void 0!==e&&e()),r=r.next}while(r!==n)}return;case 1:case 12:case 17:return;case 5:if(null!=(n=t.stateNode)){r=t.memoizedProps;var s=null!==e?e.memoizedProps:r;e=t.type;var l=t.updateQueue;if(t.updateQueue=null,null!==l){for(n[Jr]=r,"input"===e&&"radio"===r.type&&null!=r.name&&te(n,r),Se(e,s),t=Se(e,r),s=0;s<l.length;s+=2){var a=l[s],i=l[s+1];"style"===a?ke(n,i):"dangerouslySetInnerHTML"===a?ve(n,i):"children"===a?me(n,i):w(n,a,i,t)}switch(e){case"input":ne(n,r);break;case"textarea":pe(n,r);break;case"select":e=n._wrapperState.wasMultiple,n._wrapperState.wasMultiple=!!r.multiple,null!=(l=r.value)?oe(n,!!r.multiple,l,!1):e!==!!r.multiple&&(null!=r.defaultValue?oe(n,!!r.multiple,r.defaultValue,!0):oe(n,!!r.multiple,r.multiple?[]:"",!1))}}}return;case 6:if(null===t.stateNode)throw Error(o(162));return void(t.stateNode.nodeValue=t.memoizedProps);case 3:return void((n=t.stateNode).hydrate&&(n.hydrate=!1,kt(n.containerInfo)));case 13:return null!==t.memoizedState&&(Ua=Us(),ha(t.child,!0)),void Sa(t);case 19:return void Sa(t);case 23:case 24:return void ha(t,null!==t.memoizedState)}throw Error(o(163))}function Sa(e){var t=e.updateQueue;if(null!==t){e.updateQueue=null;var n=e.stateNode;null===n&&(n=e.stateNode=new ca),t.forEach((function(t){var r=Fi.bind(null,e,t);n.has(t)||(n.add(t),t.then(r,r))}))}}function Ea(e,t){return null!==e&&(null===(e=e.memoizedState)||null!==e.dehydrated)&&null!==(t=t.memoizedState)&&null===t.dehydrated}var Oa=Math.ceil,Ca=k.ReactCurrentDispatcher,Pa=k.ReactCurrentOwner,Aa=0,_a=null,La=null,Na=0,Ta=0,Ra=is(0),Da=0,Ia=null,Ba=0,Ma=0,Fa=0,qa=0,za=null,Ua=0,Ha=1/0;function Va(){Ha=Us()+500}var Qa,$a=null,Wa=!1,Xa=null,Ka=null,Ya=!1,Ga=null,Ja=90,Za=[],ei=[],ti=null,ni=0,ri=null,si=-1,li=0,oi=0,ai=null,ii=!1;function pi(){return 0!=(48&Aa)?Us():-1!==si?si:si=Us()}function ui(e){if(0==(2&(e=e.mode)))return 1;if(0==(4&e))return 99===Hs()?1:2;if(0===li&&(li=Ba),0!==Ks.transition){0!==oi&&(oi=null!==za?za.pendingLanes:0),e=li;var t=4186112&~oi;return 0==(t&=-t)&&0==(t=(e=4186112&~e)&-e)&&(t=8192),t}return e=Hs(),e=Ft(0!=(4&Aa)&&98===e?12:e=function(e){switch(e){case 99:return 15;case 98:return 10;case 97:case 96:return 8;case 95:return 2;default:return 0}}(e),li)}function ci(e,t,n){if(50<ni)throw ni=0,ri=null,Error(o(185));if(null===(e=di(e,t)))return null;Ut(e,t,n),e===_a&&(Fa|=t,4===Da&&hi(e,Na));var r=Hs();1===t?0!=(8&Aa)&&0==(48&Aa)?vi(e):(fi(e,n),0===Aa&&(Va(),Ws())):(0==(4&Aa)||98!==r&&99!==r||(null===ti?ti=new Set([e]):ti.add(e)),fi(e,n)),za=e}function di(e,t){e.lanes|=t;var n=e.alternate;for(null!==n&&(n.lanes|=t),n=e,e=e.return;null!==e;)e.childLanes|=t,null!==(n=e.alternate)&&(n.childLanes|=t),n=e,e=e.return;return 3===n.tag?n.stateNode:null}function fi(e,t){for(var n=e.callbackNode,r=e.suspendedLanes,s=e.pingedLanes,l=e.expirationTimes,a=e.pendingLanes;0<a;){var i=31-Ht(a),p=1<<i,u=l[i];if(-1===u){if(0==(p&r)||0!=(p&s)){u=t,It(p);var c=Dt;l[i]=10<=c?u+250:6<=c?u+5e3:-1}}else u<=t&&(e.expiredLanes|=p);a&=~p}if(r=Bt(e,e===_a?Na:0),t=Dt,0===r)null!==n&&(n!==Is&&Os(n),e.callbackNode=null,e.callbackPriority=0);else{if(null!==n){if(e.callbackPriority===t)return;n!==Is&&Os(n)}15===t?(n=vi.bind(null,e),null===Ms?(Ms=[n],Fs=Es(Ls,Xs)):Ms.push(n),n=Is):14===t?n=$s(99,vi.bind(null,e)):(n=function(e){switch(e){case 15:case 14:return 99;case 13:case 12:case 11:case 10:return 98;case 9:case 8:case 7:case 6:case 4:case 5:return 97;case 3:case 2:case 1:return 95;case 0:return 90;default:throw Error(o(358,e))}}(t),n=$s(n,gi.bind(null,e))),e.callbackPriority=t,e.callbackNode=n}}function gi(e){if(si=-1,oi=li=0,0!=(48&Aa))throw Error(o(327));var t=e.callbackNode;if(Ni()&&e.callbackNode!==t)return null;var n=Bt(e,e===_a?Na:0);if(0===n)return null;var r=n,s=Aa;Aa|=16;var l=ji();for(_a===e&&Na===r||(Va(),ki(e,r));;)try{Oi();break}catch(t){xi(e,t)}if(tl(),Ca.current=l,Aa=s,null!==La?r=0:(_a=null,Na=0,r=Da),0!=(Ba&Fa))ki(e,0);else if(0!==r){if(2===r&&(Aa|=64,e.hydrate&&(e.hydrate=!1,$r(e.containerInfo)),0!==(n=Mt(e))&&(r=Si(e,n))),1===r)throw t=Ia,ki(e,0),hi(e,n),fi(e,Us()),t;switch(e.finishedWork=e.current.alternate,e.finishedLanes=n,r){case 0:case 1:throw Error(o(345));case 2:case 5:Ai(e);break;case 3:if(hi(e,n),(62914560&n)===n&&10<(r=Ua+500-Us())){if(0!==Bt(e,0))break;if(((s=e.suspendedLanes)&n)!==n){pi(),e.pingedLanes|=e.suspendedLanes&s;break}e.timeoutHandle=Vr(Ai.bind(null,e),r);break}Ai(e);break;case 4:if(hi(e,n),(4186112&n)===n)break;for(r=e.eventTimes,s=-1;0<n;){var a=31-Ht(n);l=1<<a,(a=r[a])>s&&(s=a),n&=~l}if(n=s,10<(n=(120>(n=Us()-n)?120:480>n?480:1080>n?1080:1920>n?1920:3e3>n?3e3:4320>n?4320:1960*Oa(n/1960))-n)){e.timeoutHandle=Vr(Ai.bind(null,e),n);break}Ai(e);break;default:throw Error(o(329))}}return fi(e,Us()),e.callbackNode===t?gi.bind(null,e):null}function hi(e,t){for(t&=~qa,t&=~Fa,e.suspendedLanes|=t,e.pingedLanes&=~t,e=e.expirationTimes;0<t;){var n=31-Ht(t),r=1<<n;e[n]=-1,t&=~r}}function vi(e){if(0!=(48&Aa))throw Error(o(327));if(Ni(),e===_a&&0!=(e.expiredLanes&Na)){var t=Na,n=Si(e,t);0!=(Ba&Fa)&&(n=Si(e,t=Bt(e,t)))}else n=Si(e,t=Bt(e,0));if(0!==e.tag&&2===n&&(Aa|=64,e.hydrate&&(e.hydrate=!1,$r(e.containerInfo)),0!==(t=Mt(e))&&(n=Si(e,t))),1===n)throw n=Ia,ki(e,0),hi(e,t),fi(e,Us()),n;return e.finishedWork=e.current.alternate,e.finishedLanes=t,Ai(e),fi(e,Us()),null}function mi(e,t){var n=Aa;Aa|=1;try{return e(t)}finally{0===(Aa=n)&&(Va(),Ws())}}function yi(e,t){var n=Aa;Aa&=-2,Aa|=8;try{return e(t)}finally{0===(Aa=n)&&(Va(),Ws())}}function bi(e,t){us(Ra,Ta),Ta|=t,Ba|=t}function wi(){Ta=Ra.current,ps(Ra)}function ki(e,t){e.finishedWork=null,e.finishedLanes=0;var n=e.timeoutHandle;if(-1!==n&&(e.timeoutHandle=-1,Qr(n)),null!==La)for(n=La.return;null!==n;){var r=n;switch(r.tag){case 1:null!=(r=r.type.childContextTypes)&&ms();break;case 3:Tl(),ps(fs),ps(ds),Xl();break;case 5:Dl(r);break;case 4:Tl();break;case 13:case 19:ps(Il);break;case 10:nl(r);break;case 23:case 24:wi()}n=n.return}_a=e,La=Hi(e.current,null),Na=Ta=Ba=t,Da=0,Ia=null,qa=Fa=Ma=0}function xi(e,t){for(;;){var n=La;try{if(tl(),Kl.current=Lo,to){for(var r=Jl.memoizedState;null!==r;){var s=r.queue;null!==s&&(s.pending=null),r=r.next}to=!1}if(Gl=0,eo=Zl=Jl=null,no=!1,Pa.current=null,null===n||null===n.return){Da=1,Ia=t,La=null;break}e:{var l=e,o=n.return,a=n,i=t;if(t=Na,a.flags|=2048,a.firstEffect=a.lastEffect=null,null!==i&&"object"==typeof i&&"function"==typeof i.then){var p=i;if(0==(2&a.mode)){var u=a.alternate;u?(a.updateQueue=u.updateQueue,a.memoizedState=u.memoizedState,a.lanes=u.lanes):(a.updateQueue=null,a.memoizedState=null)}var c=0!=(1&Il.current),d=o;do{var f;if(f=13===d.tag){var g=d.memoizedState;if(null!==g)f=null!==g.dehydrated;else{var h=d.memoizedProps;f=void 0!==h.fallback&&(!0!==h.unstable_avoidThisFallback||!c)}}if(f){var v=d.updateQueue;if(null===v){var m=new Set;m.add(p),d.updateQueue=m}else v.add(p);if(0==(2&d.mode)){if(d.flags|=64,a.flags|=16384,a.flags&=-2981,1===a.tag)if(null===a.alternate)a.tag=17;else{var y=pl(-1,1);y.tag=2,ul(a,y)}a.lanes|=1;break e}i=void 0,a=t;var b=l.pingCache;if(null===b?(b=l.pingCache=new ia,i=new Set,b.set(p,i)):void 0===(i=b.get(p))&&(i=new Set,b.set(p,i)),!i.has(a)){i.add(a);var w=Mi.bind(null,l,p,a);p.then(w,w)}d.flags|=4096,d.lanes=t;break e}d=d.return}while(null!==d);i=Error((W(a.type)||"A React component")+" suspended while rendering, but no fallback UI was specified.\n\nAdd a <Suspense fallback=...> component higher in the tree to provide a loading indicator or placeholder to display.")}5!==Da&&(Da=2),i=oa(i,a),d=o;do{switch(d.tag){case 3:l=i,d.flags|=4096,t&=-t,d.lanes|=t,cl(d,pa(0,l,t));break e;case 1:l=i;var k=d.type,x=d.stateNode;if(0==(64&d.flags)&&("function"==typeof k.getDerivedStateFromError||null!==x&&"function"==typeof x.componentDidCatch&&(null===Ka||!Ka.has(x)))){d.flags|=4096,t&=-t,d.lanes|=t,cl(d,ua(d,l,t));break e}}d=d.return}while(null!==d)}Pi(n)}catch(e){t=e,La===n&&null!==n&&(La=n=n.return);continue}break}}function ji(){var e=Ca.current;return Ca.current=Lo,null===e?Lo:e}function Si(e,t){var n=Aa;Aa|=16;var r=ji();for(_a===e&&Na===t||ki(e,t);;)try{Ei();break}catch(t){xi(e,t)}if(tl(),Aa=n,Ca.current=r,null!==La)throw Error(o(261));return _a=null,Na=0,Da}function Ei(){for(;null!==La;)Ci(La)}function Oi(){for(;null!==La&&!Cs();)Ci(La)}function Ci(e){var t=Qa(e.alternate,e,Ta);e.memoizedProps=e.pendingProps,null===t?Pi(e):La=t,Pa.current=null}function Pi(e){var t=e;do{var n=t.alternate;if(e=t.return,0==(2048&t.flags)){if(null!==(n=sa(n,t,Ta)))return void(La=n);if(24!==(n=t).tag&&23!==n.tag||null===n.memoizedState||0!=(1073741824&Ta)||0==(4&n.mode)){for(var r=0,s=n.child;null!==s;)r|=s.lanes|s.childLanes,s=s.sibling;n.childLanes=r}null!==e&&0==(2048&e.flags)&&(null===e.firstEffect&&(e.firstEffect=t.firstEffect),null!==t.lastEffect&&(null!==e.lastEffect&&(e.lastEffect.nextEffect=t.firstEffect),e.lastEffect=t.lastEffect),1<t.flags&&(null!==e.lastEffect?e.lastEffect.nextEffect=t:e.firstEffect=t,e.lastEffect=t))}else{if(null!==(n=la(t)))return n.flags&=2047,void(La=n);null!==e&&(e.firstEffect=e.lastEffect=null,e.flags|=2048)}if(null!==(t=t.sibling))return void(La=t);La=t=e}while(null!==t);0===Da&&(Da=5)}function Ai(e){var t=Hs();return Qs(99,_i.bind(null,e,t)),null}function _i(e,t){do{Ni()}while(null!==Ga);if(0!=(48&Aa))throw Error(o(327));var n=e.finishedWork;if(null===n)return null;if(e.finishedWork=null,e.finishedLanes=0,n===e.current)throw Error(o(177));e.callbackNode=null;var r=n.lanes|n.childLanes,s=r,l=e.pendingLanes&~s;e.pendingLanes=s,e.suspendedLanes=0,e.pingedLanes=0,e.expiredLanes&=s,e.mutableReadLanes&=s,e.entangledLanes&=s,s=e.entanglements;for(var a=e.eventTimes,i=e.expirationTimes;0<l;){var p=31-Ht(l),u=1<<p;s[p]=0,a[p]=-1,i[p]=-1,l&=~u}if(null!==ti&&0==(24&r)&&ti.has(e)&&ti.delete(e),e===_a&&(La=_a=null,Na=0),1<n.flags?null!==n.lastEffect?(n.lastEffect.nextEffect=n,r=n.firstEffect):r=n:r=n.firstEffect,null!==r){if(s=Aa,Aa|=32,Pa.current=null,qr=Xt,vr(a=hr())){if("selectionStart"in a)i={start:a.selectionStart,end:a.selectionEnd};else e:if(i=(i=a.ownerDocument)&&i.defaultView||window,(u=i.getSelection&&i.getSelection())&&0!==u.rangeCount){i=u.anchorNode,l=u.anchorOffset,p=u.focusNode,u=u.focusOffset;try{i.nodeType,p.nodeType}catch(e){i=null;break e}var c=0,d=-1,f=-1,g=0,h=0,v=a,m=null;t:for(;;){for(var y;v!==i||0!==l&&3!==v.nodeType||(d=c+l),v!==p||0!==u&&3!==v.nodeType||(f=c+u),3===v.nodeType&&(c+=v.nodeValue.length),null!==(y=v.firstChild);)m=v,v=y;for(;;){if(v===a)break t;if(m===i&&++g===l&&(d=c),m===p&&++h===u&&(f=c),null!==(y=v.nextSibling))break;m=(v=m).parentNode}v=y}i=-1===d||-1===f?null:{start:d,end:f}}else i=null;i=i||{start:0,end:0}}else i=null;zr={focusedElem:a,selectionRange:i},Xt=!1,ai=null,ii=!1,$a=r;do{try{Li()}catch(e){if(null===$a)throw Error(o(330));Bi($a,e),$a=$a.nextEffect}}while(null!==$a);ai=null,$a=r;do{try{for(a=e;null!==$a;){var b=$a.flags;if(16&b&&me($a.stateNode,""),128&b){var w=$a.alternate;if(null!==w){var k=w.ref;null!==k&&("function"==typeof k?k(null):k.current=null)}}switch(1038&b){case 2:ba($a),$a.flags&=-3;break;case 6:ba($a),$a.flags&=-3,ja($a.alternate,$a);break;case 1024:$a.flags&=-1025;break;case 1028:$a.flags&=-1025,ja($a.alternate,$a);break;case 4:ja($a.alternate,$a);break;case 8:xa(a,i=$a);var x=i.alternate;ma(i),null!==x&&ma(x)}$a=$a.nextEffect}}catch(e){if(null===$a)throw Error(o(330));Bi($a,e),$a=$a.nextEffect}}while(null!==$a);if(k=zr,w=hr(),b=k.focusedElem,a=k.selectionRange,w!==b&&b&&b.ownerDocument&&gr(b.ownerDocument.documentElement,b)){null!==a&&vr(b)&&(w=a.start,void 0===(k=a.end)&&(k=w),"selectionStart"in b?(b.selectionStart=w,b.selectionEnd=Math.min(k,b.value.length)):(k=(w=b.ownerDocument||document)&&w.defaultView||window).getSelection&&(k=k.getSelection(),i=b.textContent.length,x=Math.min(a.start,i),a=void 0===a.end?x:Math.min(a.end,i),!k.extend&&x>a&&(i=a,a=x,x=i),i=fr(b,x),l=fr(b,a),i&&l&&(1!==k.rangeCount||k.anchorNode!==i.node||k.anchorOffset!==i.offset||k.focusNode!==l.node||k.focusOffset!==l.offset)&&((w=w.createRange()).setStart(i.node,i.offset),k.removeAllRanges(),x>a?(k.addRange(w),k.extend(l.node,l.offset)):(w.setEnd(l.node,l.offset),k.addRange(w))))),w=[];for(k=b;k=k.parentNode;)1===k.nodeType&&w.push({element:k,left:k.scrollLeft,top:k.scrollTop});for("function"==typeof b.focus&&b.focus(),b=0;b<w.length;b++)(k=w[b]).element.scrollLeft=k.left,k.element.scrollTop=k.top}Xt=!!qr,zr=qr=null,e.current=n,$a=r;do{try{for(b=e;null!==$a;){var j=$a.flags;if(36&j&&ga(b,$a.alternate,$a),128&j){w=void 0;var S=$a.ref;if(null!==S){var E=$a.stateNode;$a.tag,w=E,"function"==typeof S?S(w):S.current=w}}$a=$a.nextEffect}}catch(e){if(null===$a)throw Error(o(330));Bi($a,e),$a=$a.nextEffect}}while(null!==$a);$a=null,Bs(),Aa=s}else e.current=n;if(Ya)Ya=!1,Ga=e,Ja=t;else for($a=r;null!==$a;)t=$a.nextEffect,$a.nextEffect=null,8&$a.flags&&((j=$a).sibling=null,j.stateNode=null),$a=t;if(0===(r=e.pendingLanes)&&(Ka=null),1===r?e===ri?ni++:(ni=0,ri=e):ni=0,n=n.stateNode,js&&"function"==typeof js.onCommitFiberRoot)try{js.onCommitFiberRoot(xs,n,void 0,64==(64&n.current.flags))}catch(e){}if(fi(e,Us()),Wa)throw Wa=!1,e=Xa,Xa=null,e;return 0!=(8&Aa)||Ws(),null}function Li(){for(;null!==$a;){var e=$a.alternate;ii||null===ai||(0!=(8&$a.flags)?Ze($a,ai)&&(ii=!0):13===$a.tag&&Ea(e,$a)&&Ze($a,ai)&&(ii=!0));var t=$a.flags;0!=(256&t)&&fa(e,$a),0==(512&t)||Ya||(Ya=!0,$s(97,(function(){return Ni(),null}))),$a=$a.nextEffect}}function Ni(){if(90!==Ja){var e=97<Ja?97:Ja;return Ja=90,Qs(e,Di)}return!1}function Ti(e,t){Za.push(t,e),Ya||(Ya=!0,$s(97,(function(){return Ni(),null})))}function Ri(e,t){ei.push(t,e),Ya||(Ya=!0,$s(97,(function(){return Ni(),null})))}function Di(){if(null===Ga)return!1;var e=Ga;if(Ga=null,0!=(48&Aa))throw Error(o(331));var t=Aa;Aa|=32;var n=ei;ei=[];for(var r=0;r<n.length;r+=2){var s=n[r],l=n[r+1],a=s.destroy;if(s.destroy=void 0,"function"==typeof a)try{a()}catch(e){if(null===l)throw Error(o(330));Bi(l,e)}}for(n=Za,Za=[],r=0;r<n.length;r+=2){s=n[r],l=n[r+1];try{var i=s.create;s.destroy=i()}catch(e){if(null===l)throw Error(o(330));Bi(l,e)}}for(i=e.current.firstEffect;null!==i;)e=i.nextEffect,i.nextEffect=null,8&i.flags&&(i.sibling=null,i.stateNode=null),i=e;return Aa=t,Ws(),!0}function Ii(e,t,n){ul(e,t=pa(0,t=oa(n,t),1)),t=pi(),null!==(e=di(e,1))&&(Ut(e,1,t),fi(e,t))}function Bi(e,t){if(3===e.tag)Ii(e,e,t);else for(var n=e.return;null!==n;){if(3===n.tag){Ii(n,e,t);break}if(1===n.tag){var r=n.stateNode;if("function"==typeof n.type.getDerivedStateFromError||"function"==typeof r.componentDidCatch&&(null===Ka||!Ka.has(r))){var s=ua(n,e=oa(t,e),1);if(ul(n,s),s=pi(),null!==(n=di(n,1)))Ut(n,1,s),fi(n,s);else if("function"==typeof r.componentDidCatch&&(null===Ka||!Ka.has(r)))try{r.componentDidCatch(t,e)}catch(e){}break}}n=n.return}}function Mi(e,t,n){var r=e.pingCache;null!==r&&r.delete(t),t=pi(),e.pingedLanes|=e.suspendedLanes&n,_a===e&&(Na&n)===n&&(4===Da||3===Da&&(62914560&Na)===Na&&500>Us()-Ua?ki(e,0):qa|=n),fi(e,t)}function Fi(e,t){var n=e.stateNode;null!==n&&n.delete(t),0==(t=0)&&(0==(2&(t=e.mode))?t=1:0==(4&t)?t=99===Hs()?1:2:(0===li&&(li=Ba),0===(t=qt(62914560&~li))&&(t=4194304))),n=pi(),null!==(e=di(e,t))&&(Ut(e,t,n),fi(e,n))}function qi(e,t,n,r){this.tag=e,this.key=n,this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null,this.index=0,this.ref=null,this.pendingProps=t,this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null,this.mode=r,this.flags=0,this.lastEffect=this.firstEffect=this.nextEffect=null,this.childLanes=this.lanes=0,this.alternate=null}function zi(e,t,n,r){return new qi(e,t,n,r)}function Ui(e){return!(!(e=e.prototype)||!e.isReactComponent)}function Hi(e,t){var n=e.alternate;return null===n?((n=zi(e.tag,t,e.key,e.mode)).elementType=e.elementType,n.type=e.type,n.stateNode=e.stateNode,n.alternate=e,e.alternate=n):(n.pendingProps=t,n.type=e.type,n.flags=0,n.nextEffect=null,n.firstEffect=null,n.lastEffect=null),n.childLanes=e.childLanes,n.lanes=e.lanes,n.child=e.child,n.memoizedProps=e.memoizedProps,n.memoizedState=e.memoizedState,n.updateQueue=e.updateQueue,t=e.dependencies,n.dependencies=null===t?null:{lanes:t.lanes,firstContext:t.firstContext},n.sibling=e.sibling,n.index=e.index,n.ref=e.ref,n}function Vi(e,t,n,r,s,l){var a=2;if(r=e,"function"==typeof e)Ui(e)&&(a=1);else if("string"==typeof e)a=5;else e:switch(e){case S:return Qi(n.children,s,l,t);case I:a=8,s|=16;break;case E:a=8,s|=1;break;case O:return(e=zi(12,n,t,8|s)).elementType=O,e.type=O,e.lanes=l,e;case _:return(e=zi(13,n,t,s)).type=_,e.elementType=_,e.lanes=l,e;case L:return(e=zi(19,n,t,s)).elementType=L,e.lanes=l,e;case B:return $i(n,s,l,t);case M:return(e=zi(24,n,t,s)).elementType=M,e.lanes=l,e;default:if("object"==typeof e&&null!==e)switch(e.$$typeof){case C:a=10;break e;case P:a=9;break e;case A:a=11;break e;case N:a=14;break e;case T:a=16,r=null;break e;case R:a=22;break e}throw Error(o(130,null==e?e:typeof e,""))}return(t=zi(a,n,t,s)).elementType=e,t.type=r,t.lanes=l,t}function Qi(e,t,n,r){return(e=zi(7,e,r,t)).lanes=n,e}function $i(e,t,n,r){return(e=zi(23,e,r,t)).elementType=B,e.lanes=n,e}function Wi(e,t,n){return(e=zi(6,e,null,t)).lanes=n,e}function Xi(e,t,n){return(t=zi(4,null!==e.children?e.children:[],e.key,t)).lanes=n,t.stateNode={containerInfo:e.containerInfo,pendingChildren:null,implementation:e.implementation},t}function Ki(e,t,n){this.tag=t,this.containerInfo=e,this.finishedWork=this.pingCache=this.current=this.pendingChildren=null,this.timeoutHandle=-1,this.pendingContext=this.context=null,this.hydrate=n,this.callbackNode=null,this.callbackPriority=0,this.eventTimes=zt(0),this.expirationTimes=zt(-1),this.entangledLanes=this.finishedLanes=this.mutableReadLanes=this.expiredLanes=this.pingedLanes=this.suspendedLanes=this.pendingLanes=0,this.entanglements=zt(0),this.mutableSourceEagerHydrationData=null}function Yi(e,t,n){var r=3<arguments.length&&void 0!==arguments[3]?arguments[3]:null;return{$$typeof:j,key:null==r?null:""+r,children:e,containerInfo:t,implementation:n}}function Gi(e,t,n,r){var s=t.current,l=pi(),a=ui(s);e:if(n){t:{if(Ke(n=n._reactInternals)!==n||1!==n.tag)throw Error(o(170));var i=n;do{switch(i.tag){case 3:i=i.stateNode.context;break t;case 1:if(vs(i.type)){i=i.stateNode.__reactInternalMemoizedMergedChildContext;break t}}i=i.return}while(null!==i);throw Error(o(171))}if(1===n.tag){var p=n.type;if(vs(p)){n=bs(n,p,i);break e}}n=i}else n=cs;return null===t.context?t.context=n:t.pendingContext=n,(t=pl(l,a)).payload={element:e},null!==(r=void 0===r?null:r)&&(t.callback=r),ul(s,t),ci(s,a,l),a}function Ji(e){return(e=e.current).child?(e.child.tag,e.child.stateNode):null}function Zi(e,t){if(null!==(e=e.memoizedState)&&null!==e.dehydrated){var n=e.retryLane;e.retryLane=0!==n&&n<t?n:t}}function ep(e,t){Zi(e,t),(e=e.alternate)&&Zi(e,t)}function tp(e,t,n){var r=null!=n&&null!=n.hydrationOptions&&n.hydrationOptions.mutableSources||null;if(n=new Ki(e,t,null!=n&&!0===n.hydrate),t=zi(3,null,null,2===t?7:1===t?3:0),n.current=t,t.stateNode=n,al(t),e[Zr]=n.current,Lr(8===e.nodeType?e.parentNode:e),r)for(e=0;e<r.length;e++){var s=(t=r[e])._getVersion;s=s(t._source),null==n.mutableSourceEagerHydrationData?n.mutableSourceEagerHydrationData=[t,s]:n.mutableSourceEagerHydrationData.push(t,s)}this._internalRoot=n}function np(e){return!(!e||1!==e.nodeType&&9!==e.nodeType&&11!==e.nodeType&&(8!==e.nodeType||" react-mount-point-unstable "!==e.nodeValue))}function rp(e,t,n,r,s){var l=n._reactRootContainer;if(l){var o=l._internalRoot;if("function"==typeof s){var a=s;s=function(){var e=Ji(o);a.call(e)}}Gi(t,o,e,s)}else{if(l=n._reactRootContainer=function(e,t){if(t||(t=!(!(t=e?9===e.nodeType?e.documentElement:e.firstChild:null)||1!==t.nodeType||!t.hasAttribute("data-reactroot"))),!t)for(var n;n=e.lastChild;)e.removeChild(n);return new tp(e,0,t?{hydrate:!0}:void 0)}(n,r),o=l._internalRoot,"function"==typeof s){var i=s;s=function(){var e=Ji(o);i.call(e)}}yi((function(){Gi(t,o,e,s)}))}return Ji(o)}function sp(e,t){var n=2<arguments.length&&void 0!==arguments[2]?arguments[2]:null;if(!np(t))throw Error(o(200));return Yi(e,t,null,n)}Qa=function(e,t,n){var r=t.lanes;if(null!==e)if(e.memoizedProps!==t.pendingProps||fs.current)Io=!0;else{if(0==(n&r)){switch(Io=!1,t.tag){case 3:$o(t),$l();break;case 5:Rl(t);break;case 1:vs(t.type)&&ws(t);break;case 4:Nl(t,t.stateNode.containerInfo);break;case 10:r=t.memoizedProps.value;var s=t.type._context;us(Gs,s._currentValue),s._currentValue=r;break;case 13:if(null!==t.memoizedState)return 0!=(n&t.child.childLanes)?Go(e,t,n):(us(Il,1&Il.current),null!==(t=na(e,t,n))?t.sibling:null);us(Il,1&Il.current);break;case 19:if(r=0!=(n&t.childLanes),0!=(64&e.flags)){if(r)return ta(e,t,n);t.flags|=64}if(null!==(s=t.memoizedState)&&(s.rendering=null,s.tail=null,s.lastEffect=null),us(Il,Il.current),r)break;return null;case 23:case 24:return t.lanes=0,zo(e,t,n)}return na(e,t,n)}Io=0!=(16384&e.flags)}else Io=!1;switch(t.lanes=0,t.tag){case 2:if(r=t.type,null!==e&&(e.alternate=null,t.alternate=null,t.flags|=2),e=t.pendingProps,s=hs(t,ds.current),sl(t,n),s=lo(null,t,r,e,s,n),t.flags|=1,"object"==typeof s&&null!==s&&"function"==typeof s.render&&void 0===s.$$typeof){if(t.tag=1,t.memoizedState=null,t.updateQueue=null,vs(r)){var l=!0;ws(t)}else l=!1;t.memoizedState=null!==s.state&&void 0!==s.state?s.state:null,al(t);var a=r.getDerivedStateFromProps;"function"==typeof a&&hl(t,r,a,e),s.updater=vl,t.stateNode=s,s._reactInternals=t,wl(t,r,e,n),t=Qo(null,t,r,!0,l,n)}else t.tag=0,Bo(null,t,s,n),t=t.child;return t;case 16:s=t.elementType;e:{switch(null!==e&&(e.alternate=null,t.alternate=null,t.flags|=2),e=t.pendingProps,s=(l=s._init)(s._payload),t.type=s,l=t.tag=function(e){if("function"==typeof e)return Ui(e)?1:0;if(null!=e){if((e=e.$$typeof)===A)return 11;if(e===N)return 14}return 2}(s),e=Ys(s,e),l){case 0:t=Ho(null,t,s,e,n);break e;case 1:t=Vo(null,t,s,e,n);break e;case 11:t=Mo(null,t,s,e,n);break e;case 14:t=Fo(null,t,s,Ys(s.type,e),r,n);break e}throw Error(o(306,s,""))}return t;case 0:return r=t.type,s=t.pendingProps,Ho(e,t,r,s=t.elementType===r?s:Ys(r,s),n);case 1:return r=t.type,s=t.pendingProps,Vo(e,t,r,s=t.elementType===r?s:Ys(r,s),n);case 3:if($o(t),r=t.updateQueue,null===e||null===r)throw Error(o(282));if(r=t.pendingProps,s=null!==(s=t.memoizedState)?s.element:null,il(e,t),dl(t,r,null,n),(r=t.memoizedState.element)===s)$l(),t=na(e,t,n);else{if((l=(s=t.stateNode).hydrate)&&(Fl=Wr(t.stateNode.containerInfo.firstChild),Ml=t,l=ql=!0),l){if(null!=(e=s.mutableSourceEagerHydrationData))for(s=0;s<e.length;s+=2)(l=e[s])._workInProgressVersionPrimary=e[s+1],Wl.push(l);for(n=Ol(t,null,r,n),t.child=n;n;)n.flags=-3&n.flags|1024,n=n.sibling}else Bo(e,t,r,n),$l();t=t.child}return t;case 5:return Rl(t),null===e&&Hl(t),r=t.type,s=t.pendingProps,l=null!==e?e.memoizedProps:null,a=s.children,Hr(r,s)?a=null:null!==l&&Hr(r,l)&&(t.flags|=16),Uo(e,t),Bo(e,t,a,n),t.child;case 6:return null===e&&Hl(t),null;case 13:return Go(e,t,n);case 4:return Nl(t,t.stateNode.containerInfo),r=t.pendingProps,null===e?t.child=El(t,null,r,n):Bo(e,t,r,n),t.child;case 11:return r=t.type,s=t.pendingProps,Mo(e,t,r,s=t.elementType===r?s:Ys(r,s),n);case 7:return Bo(e,t,t.pendingProps,n),t.child;case 8:case 12:return Bo(e,t,t.pendingProps.children,n),t.child;case 10:e:{r=t.type._context,s=t.pendingProps,a=t.memoizedProps,l=s.value;var i=t.type._context;if(us(Gs,i._currentValue),i._currentValue=l,null!==a)if(i=a.value,0==(l=pr(i,l)?0:0|("function"==typeof r._calculateChangedBits?r._calculateChangedBits(i,l):1073741823))){if(a.children===s.children&&!fs.current){t=na(e,t,n);break e}}else for(null!==(i=t.child)&&(i.return=t);null!==i;){var p=i.dependencies;if(null!==p){a=i.child;for(var u=p.firstContext;null!==u;){if(u.context===r&&0!=(u.observedBits&l)){1===i.tag&&((u=pl(-1,n&-n)).tag=2,ul(i,u)),i.lanes|=n,null!==(u=i.alternate)&&(u.lanes|=n),rl(i.return,n),p.lanes|=n;break}u=u.next}}else a=10===i.tag&&i.type===t.type?null:i.child;if(null!==a)a.return=i;else for(a=i;null!==a;){if(a===t){a=null;break}if(null!==(i=a.sibling)){i.return=a.return,a=i;break}a=a.return}i=a}Bo(e,t,s.children,n),t=t.child}return t;case 9:return s=t.type,r=(l=t.pendingProps).children,sl(t,n),r=r(s=ll(s,l.unstable_observedBits)),t.flags|=1,Bo(e,t,r,n),t.child;case 14:return l=Ys(s=t.type,t.pendingProps),Fo(e,t,s,l=Ys(s.type,l),r,n);case 15:return qo(e,t,t.type,t.pendingProps,r,n);case 17:return r=t.type,s=t.pendingProps,s=t.elementType===r?s:Ys(r,s),null!==e&&(e.alternate=null,t.alternate=null,t.flags|=2),t.tag=1,vs(r)?(e=!0,ws(t)):e=!1,sl(t,n),yl(t,r,s),wl(t,r,s,n),Qo(null,t,r,!0,e,n);case 19:return ta(e,t,n);case 23:case 24:return zo(e,t,n)}throw Error(o(156,t.tag))},tp.prototype.render=function(e){Gi(e,this._internalRoot,null,null)},tp.prototype.unmount=function(){var e=this._internalRoot,t=e.containerInfo;Gi(null,e,null,(function(){t[Zr]=null}))},et=function(e){13===e.tag&&(ci(e,4,pi()),ep(e,4))},tt=function(e){13===e.tag&&(ci(e,67108864,pi()),ep(e,67108864))},nt=function(e){if(13===e.tag){var t=pi(),n=ui(e);ci(e,n,t),ep(e,n)}},rt=function(e,t){return t()},Oe=function(e,t,n){switch(t){case"input":if(ne(e,n),t=n.name,"radio"===n.type&&null!=t){for(n=e;n.parentNode;)n=n.parentNode;for(n=n.querySelectorAll("input[name="+JSON.stringify(""+t)+'][type="radio"]'),t=0;t<n.length;t++){var r=n[t];if(r!==e&&r.form===e.form){var s=ss(r);if(!s)throw Error(o(90));G(r),ne(r,s)}}}break;case"textarea":pe(e,n);break;case"select":null!=(t=n.value)&&oe(e,!!n.multiple,t,!1)}},Ne=mi,Te=function(e,t,n,r,s){var l=Aa;Aa|=4;try{return Qs(98,e.bind(null,t,n,r,s))}finally{0===(Aa=l)&&(Va(),Ws())}},Re=function(){0==(49&Aa)&&(function(){if(null!==ti){var e=ti;ti=null,e.forEach((function(e){e.expiredLanes|=24&e.pendingLanes,fi(e,Us())}))}Ws()}(),Ni())},De=function(e,t){var n=Aa;Aa|=2;try{return e(t)}finally{0===(Aa=n)&&(Va(),Ws())}};var lp={Events:[ns,rs,ss,_e,Le,Ni,{current:!1}]},op={findFiberByHostInstance:ts,bundleType:0,version:"17.0.2",rendererPackageName:"react-dom"},ap={bundleType:op.bundleType,version:op.version,rendererPackageName:op.rendererPackageName,rendererConfig:op.rendererConfig,overrideHookState:null,overrideHookStateDeletePath:null,overrideHookStateRenamePath:null,overrideProps:null,overridePropsDeletePath:null,overridePropsRenamePath:null,setSuspenseHandler:null,scheduleUpdate:null,currentDispatcherRef:k.ReactCurrentDispatcher,findHostInstanceByFiber:function(e){return null===(e=Je(e))?null:e.stateNode},findFiberByHostInstance:op.findFiberByHostInstance||function(){return null},findHostInstancesForRefresh:null,scheduleRefresh:null,scheduleRoot:null,setRefreshHandler:null,getCurrentFiber:null};if("undefined"!=typeof __REACT_DEVTOOLS_GLOBAL_HOOK__){var ip=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(!ip.isDisabled&&ip.supportsFiber)try{xs=ip.inject(ap),js=ip}catch(he){}}t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=lp,t.createPortal=sp,t.findDOMNode=function(e){if(null==e)return null;if(1===e.nodeType)return e;var t=e._reactInternals;if(void 0===t){if("function"==typeof e.render)throw Error(o(188));throw Error(o(268,Object.keys(e)))}return null===(e=Je(t))?null:e.stateNode},t.flushSync=function(e,t){var n=Aa;if(0!=(48&n))return e(t);Aa|=1;try{if(e)return Qs(99,e.bind(null,t))}finally{Aa=n,Ws()}},t.hydrate=function(e,t,n){if(!np(t))throw Error(o(200));return rp(null,e,t,!0,n)},t.render=function(e,t,n){if(!np(t))throw Error(o(200));return rp(null,e,t,!1,n)},t.unmountComponentAtNode=function(e){if(!np(e))throw Error(o(40));return!!e._reactRootContainer&&(yi((function(){rp(null,null,e,!1,(function(){e._reactRootContainer=null,e[Zr]=null}))})),!0)},t.unstable_batchedUpdates=mi,t.unstable_createPortal=function(e,t){return sp(e,t,2<arguments.length&&void 0!==arguments[2]?arguments[2]:null)},t.unstable_renderSubtreeIntoContainer=function(e,t,n,r){if(!np(n))throw Error(o(200));if(null==e||void 0===e._reactInternals)throw Error(o(38));return rp(e,t,n,!1,r)},t.version="17.0.2"},935:(e,t,n)=>{"use strict";!function e(){if("undefined"!=typeof __REACT_DEVTOOLS_GLOBAL_HOOK__&&"function"==typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE)try{__REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(e)}catch(e){console.error(e)}}(),e.exports=n(448)},921:(e,t)=>{"use strict";var n="function"==typeof Symbol&&Symbol.for,r=n?Symbol.for("react.element"):60103,s=n?Symbol.for("react.portal"):60106,l=n?Symbol.for("react.fragment"):60107,o=n?Symbol.for("react.strict_mode"):60108,a=n?Symbol.for("react.profiler"):60114,i=n?Symbol.for("react.provider"):60109,p=n?Symbol.for("react.context"):60110,u=n?Symbol.for("react.async_mode"):60111,c=n?Symbol.for("react.concurrent_mode"):60111,d=n?Symbol.for("react.forward_ref"):60112,f=n?Symbol.for("react.suspense"):60113,g=n?Symbol.for("react.suspense_list"):60120,h=n?Symbol.for("react.memo"):60115,v=n?Symbol.for("react.lazy"):60116,m=n?Symbol.for("react.block"):60121,y=n?Symbol.for("react.fundamental"):60117,b=n?Symbol.for("react.responder"):60118,w=n?Symbol.for("react.scope"):60119;function k(e){if("object"==typeof e&&null!==e){var t=e.$$typeof;switch(t){case r:switch(e=e.type){case u:case c:case l:case a:case o:case f:return e;default:switch(e=e&&e.$$typeof){case p:case d:case v:case h:case i:return e;default:return t}}case s:return t}}}function x(e){return k(e)===c}t.AsyncMode=u,t.ConcurrentMode=c,t.ContextConsumer=p,t.ContextProvider=i,t.Element=r,t.ForwardRef=d,t.Fragment=l,t.Lazy=v,t.Memo=h,t.Portal=s,t.Profiler=a,t.StrictMode=o,t.Suspense=f,t.isAsyncMode=function(e){return x(e)||k(e)===u},t.isConcurrentMode=x,t.isContextConsumer=function(e){return k(e)===p},t.isContextProvider=function(e){return k(e)===i},t.isElement=function(e){return"object"==typeof e&&null!==e&&e.$$typeof===r},t.isForwardRef=function(e){return k(e)===d},t.isFragment=function(e){return k(e)===l},t.isLazy=function(e){return k(e)===v},t.isMemo=function(e){return k(e)===h},t.isPortal=function(e){return k(e)===s},t.isProfiler=function(e){return k(e)===a},t.isStrictMode=function(e){return k(e)===o},t.isSuspense=function(e){return k(e)===f},t.isValidElementType=function(e){return"string"==typeof e||"function"==typeof e||e===l||e===c||e===a||e===o||e===f||e===g||"object"==typeof e&&null!==e&&(e.$$typeof===v||e.$$typeof===h||e.$$typeof===i||e.$$typeof===p||e.$$typeof===d||e.$$typeof===y||e.$$typeof===b||e.$$typeof===w||e.$$typeof===m)},t.typeOf=k},864:(e,t,n)=>{"use strict";e.exports=n(921)},359:(e,t)=>{"use strict";if("function"==typeof Symbol&&Symbol.for){var n=Symbol.for;n("react.element"),n("react.portal"),n("react.fragment"),n("react.strict_mode"),n("react.profiler"),n("react.provider"),n("react.context"),n("react.forward_ref"),n("react.suspense"),n("react.suspense_list"),n("react.memo"),n("react.lazy"),n("react.block"),n("react.server.block"),n("react.fundamental"),n("react.debug_trace_mode"),n("react.legacy_hidden")}},973:(e,t,n)=>{"use strict";n(359)},251:(e,t,n)=>{"use strict";n(418);var r=n(294),s=60103;if("function"==typeof Symbol&&Symbol.for){var l=Symbol.for;s=l("react.element"),l("react.fragment")}var o=r.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,a=Object.prototype.hasOwnProperty,i={key:!0,ref:!0,__self:!0,__source:!0};function p(e,t,n){var r,l={},p=null,u=null;for(r in void 0!==n&&(p=""+n),void 0!==t.key&&(p=""+t.key),void 0!==t.ref&&(u=t.ref),t)a.call(t,r)&&!i.hasOwnProperty(r)&&(l[r]=t[r]);if(e&&e.defaultProps)for(r in t=e.defaultProps)void 0===l[r]&&(l[r]=t[r]);return{$$typeof:s,type:e,key:p,ref:u,props:l,_owner:o.current}}t.jsx=p,t.jsxs=p},408:(e,t,n)=>{"use strict";var r=n(418),s=60103,l=60106;t.Fragment=60107,t.StrictMode=60108,t.Profiler=60114;var o=60109,a=60110,i=60112;t.Suspense=60113;var p=60115,u=60116;if("function"==typeof Symbol&&Symbol.for){var c=Symbol.for;s=c("react.element"),l=c("react.portal"),t.Fragment=c("react.fragment"),t.StrictMode=c("react.strict_mode"),t.Profiler=c("react.profiler"),o=c("react.provider"),a=c("react.context"),i=c("react.forward_ref"),t.Suspense=c("react.suspense"),p=c("react.memo"),u=c("react.lazy")}var d="function"==typeof Symbol&&Symbol.iterator;function f(e){for(var t="https://reactjs.org/docs/error-decoder.html?invariant="+e,n=1;n<arguments.length;n++)t+="&args[]="+encodeURIComponent(arguments[n]);return"Minified React error #"+e+"; visit "+t+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}var g={isMounted:function(){return!1},enqueueForceUpdate:function(){},enqueueReplaceState:function(){},enqueueSetState:function(){}},h={};function v(e,t,n){this.props=e,this.context=t,this.refs=h,this.updater=n||g}function m(){}function y(e,t,n){this.props=e,this.context=t,this.refs=h,this.updater=n||g}v.prototype.isReactComponent={},v.prototype.setState=function(e,t){if("object"!=typeof e&&"function"!=typeof e&&null!=e)throw Error(f(85));this.updater.enqueueSetState(this,e,t,"setState")},v.prototype.forceUpdate=function(e){this.updater.enqueueForceUpdate(this,e,"forceUpdate")},m.prototype=v.prototype;var b=y.prototype=new m;b.constructor=y,r(b,v.prototype),b.isPureReactComponent=!0;var w={current:null},k=Object.prototype.hasOwnProperty,x={key:!0,ref:!0,__self:!0,__source:!0};function j(e,t,n){var r,l={},o=null,a=null;if(null!=t)for(r in void 0!==t.ref&&(a=t.ref),void 0!==t.key&&(o=""+t.key),t)k.call(t,r)&&!x.hasOwnProperty(r)&&(l[r]=t[r]);var i=arguments.length-2;if(1===i)l.children=n;else if(1<i){for(var p=Array(i),u=0;u<i;u++)p[u]=arguments[u+2];l.children=p}if(e&&e.defaultProps)for(r in i=e.defaultProps)void 0===l[r]&&(l[r]=i[r]);return{$$typeof:s,type:e,key:o,ref:a,props:l,_owner:w.current}}function S(e){return"object"==typeof e&&null!==e&&e.$$typeof===s}var E=/\/+/g;function O(e,t){return"object"==typeof e&&null!==e&&null!=e.key?function(e){var t={"=":"=0",":":"=2"};return"$"+e.replace(/[=:]/g,(function(e){return t[e]}))}(""+e.key):t.toString(36)}function C(e,t,n,r,o){var a=typeof e;"undefined"!==a&&"boolean"!==a||(e=null);var i=!1;if(null===e)i=!0;else switch(a){case"string":case"number":i=!0;break;case"object":switch(e.$$typeof){case s:case l:i=!0}}if(i)return o=o(i=e),e=""===r?"."+O(i,0):r,Array.isArray(o)?(n="",null!=e&&(n=e.replace(E,"$&/")+"/"),C(o,t,n,"",(function(e){return e}))):null!=o&&(S(o)&&(o=function(e,t){return{$$typeof:s,type:e.type,key:t,ref:e.ref,props:e.props,_owner:e._owner}}(o,n+(!o.key||i&&i.key===o.key?"":(""+o.key).replace(E,"$&/")+"/")+e)),t.push(o)),1;if(i=0,r=""===r?".":r+":",Array.isArray(e))for(var p=0;p<e.length;p++){var u=r+O(a=e[p],p);i+=C(a,t,n,u,o)}else if(u=function(e){return null===e||"object"!=typeof e?null:"function"==typeof(e=d&&e[d]||e["@@iterator"])?e:null}(e),"function"==typeof u)for(e=u.call(e),p=0;!(a=e.next()).done;)i+=C(a=a.value,t,n,u=r+O(a,p++),o);else if("object"===a)throw t=""+e,Error(f(31,"[object Object]"===t?"object with keys {"+Object.keys(e).join(", ")+"}":t));return i}function P(e,t,n){if(null==e)return e;var r=[],s=0;return C(e,r,"","",(function(e){return t.call(n,e,s++)})),r}function A(e){if(-1===e._status){var t=e._result;t=t(),e._status=0,e._result=t,t.then((function(t){0===e._status&&(t=t.default,e._status=1,e._result=t)}),(function(t){0===e._status&&(e._status=2,e._result=t)}))}if(1===e._status)return e._result;throw e._result}var _={current:null};function L(){var e=_.current;if(null===e)throw Error(f(321));return e}var N={ReactCurrentDispatcher:_,ReactCurrentBatchConfig:{transition:0},ReactCurrentOwner:w,IsSomeRendererActing:{current:!1},assign:r};t.Children={map:P,forEach:function(e,t,n){P(e,(function(){t.apply(this,arguments)}),n)},count:function(e){var t=0;return P(e,(function(){t++})),t},toArray:function(e){return P(e,(function(e){return e}))||[]},only:function(e){if(!S(e))throw Error(f(143));return e}},t.Component=v,t.PureComponent=y,t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=N,t.cloneElement=function(e,t,n){if(null==e)throw Error(f(267,e));var l=r({},e.props),o=e.key,a=e.ref,i=e._owner;if(null!=t){if(void 0!==t.ref&&(a=t.ref,i=w.current),void 0!==t.key&&(o=""+t.key),e.type&&e.type.defaultProps)var p=e.type.defaultProps;for(u in t)k.call(t,u)&&!x.hasOwnProperty(u)&&(l[u]=void 0===t[u]&&void 0!==p?p[u]:t[u])}var u=arguments.length-2;if(1===u)l.children=n;else if(1<u){p=Array(u);for(var c=0;c<u;c++)p[c]=arguments[c+2];l.children=p}return{$$typeof:s,type:e.type,key:o,ref:a,props:l,_owner:i}},t.createContext=function(e,t){return void 0===t&&(t=null),(e={$$typeof:a,_calculateChangedBits:t,_currentValue:e,_currentValue2:e,_threadCount:0,Provider:null,Consumer:null}).Provider={$$typeof:o,_context:e},e.Consumer=e},t.createElement=j,t.createFactory=function(e){var t=j.bind(null,e);return t.type=e,t},t.createRef=function(){return{current:null}},t.forwardRef=function(e){return{$$typeof:i,render:e}},t.isValidElement=S,t.lazy=function(e){return{$$typeof:u,_payload:{_status:-1,_result:e},_init:A}},t.memo=function(e,t){return{$$typeof:p,type:e,compare:void 0===t?null:t}},t.useCallback=function(e,t){return L().useCallback(e,t)},t.useContext=function(e,t){return L().useContext(e,t)},t.useDebugValue=function(){},t.useEffect=function(e,t){return L().useEffect(e,t)},t.useImperativeHandle=function(e,t,n){return L().useImperativeHandle(e,t,n)},t.useLayoutEffect=function(e,t){return L().useLayoutEffect(e,t)},t.useMemo=function(e,t){return L().useMemo(e,t)},t.useReducer=function(e,t,n){return L().useReducer(e,t,n)},t.useRef=function(e){return L().useRef(e)},t.useState=function(e){return L().useState(e)},t.version="17.0.2"},294:(e,t,n)=>{"use strict";e.exports=n(408)},893:(e,t,n)=>{"use strict";e.exports=n(251)},53:(e,t)=>{"use strict";var n,r,s,l;if("object"==typeof performance&&"function"==typeof performance.now){var o=performance;t.unstable_now=function(){return o.now()}}else{var a=Date,i=a.now();t.unstable_now=function(){return a.now()-i}}if("undefined"==typeof window||"function"!=typeof MessageChannel){var p=null,u=null,c=function(){if(null!==p)try{var e=t.unstable_now();p(!0,e),p=null}catch(e){throw setTimeout(c,0),e}};n=function(e){null!==p?setTimeout(n,0,e):(p=e,setTimeout(c,0))},r=function(e,t){u=setTimeout(e,t)},s=function(){clearTimeout(u)},t.unstable_shouldYield=function(){return!1},l=t.unstable_forceFrameRate=function(){}}else{var d=window.setTimeout,f=window.clearTimeout;if("undefined"!=typeof console){var g=window.cancelAnimationFrame;"function"!=typeof window.requestAnimationFrame&&console.error("This browser doesn't support requestAnimationFrame. Make sure that you load a polyfill in older browsers. https://reactjs.org/link/react-polyfills"),"function"!=typeof g&&console.error("This browser doesn't support cancelAnimationFrame. Make sure that you load a polyfill in older browsers. https://reactjs.org/link/react-polyfills")}var h=!1,v=null,m=-1,y=5,b=0;t.unstable_shouldYield=function(){return t.unstable_now()>=b},l=function(){},t.unstable_forceFrameRate=function(e){0>e||125<e?console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"):y=0<e?Math.floor(1e3/e):5};var w=new MessageChannel,k=w.port2;w.port1.onmessage=function(){if(null!==v){var e=t.unstable_now();b=e+y;try{v(!0,e)?k.postMessage(null):(h=!1,v=null)}catch(e){throw k.postMessage(null),e}}else h=!1},n=function(e){v=e,h||(h=!0,k.postMessage(null))},r=function(e,n){m=d((function(){e(t.unstable_now())}),n)},s=function(){f(m),m=-1}}function x(e,t){var n=e.length;e.push(t);e:for(;;){var r=n-1>>>1,s=e[r];if(!(void 0!==s&&0<E(s,t)))break e;e[r]=t,e[n]=s,n=r}}function j(e){return void 0===(e=e[0])?null:e}function S(e){var t=e[0];if(void 0!==t){var n=e.pop();if(n!==t){e[0]=n;e:for(var r=0,s=e.length;r<s;){var l=2*(r+1)-1,o=e[l],a=l+1,i=e[a];if(void 0!==o&&0>E(o,n))void 0!==i&&0>E(i,o)?(e[r]=i,e[a]=n,r=a):(e[r]=o,e[l]=n,r=l);else{if(!(void 0!==i&&0>E(i,n)))break e;e[r]=i,e[a]=n,r=a}}}return t}return null}function E(e,t){var n=e.sortIndex-t.sortIndex;return 0!==n?n:e.id-t.id}var O=[],C=[],P=1,A=null,_=3,L=!1,N=!1,T=!1;function R(e){for(var t=j(C);null!==t;){if(null===t.callback)S(C);else{if(!(t.startTime<=e))break;S(C),t.sortIndex=t.expirationTime,x(O,t)}t=j(C)}}function D(e){if(T=!1,R(e),!N)if(null!==j(O))N=!0,n(I);else{var t=j(C);null!==t&&r(D,t.startTime-e)}}function I(e,n){N=!1,T&&(T=!1,s()),L=!0;var l=_;try{for(R(n),A=j(O);null!==A&&(!(A.expirationTime>n)||e&&!t.unstable_shouldYield());){var o=A.callback;if("function"==typeof o){A.callback=null,_=A.priorityLevel;var a=o(A.expirationTime<=n);n=t.unstable_now(),"function"==typeof a?A.callback=a:A===j(O)&&S(O),R(n)}else S(O);A=j(O)}if(null!==A)var i=!0;else{var p=j(C);null!==p&&r(D,p.startTime-n),i=!1}return i}finally{A=null,_=l,L=!1}}var B=l;t.unstable_IdlePriority=5,t.unstable_ImmediatePriority=1,t.unstable_LowPriority=4,t.unstable_NormalPriority=3,t.unstable_Profiling=null,t.unstable_UserBlockingPriority=2,t.unstable_cancelCallback=function(e){e.callback=null},t.unstable_continueExecution=function(){N||L||(N=!0,n(I))},t.unstable_getCurrentPriorityLevel=function(){return _},t.unstable_getFirstCallbackNode=function(){return j(O)},t.unstable_next=function(e){switch(_){case 1:case 2:case 3:var t=3;break;default:t=_}var n=_;_=t;try{return e()}finally{_=n}},t.unstable_pauseExecution=function(){},t.unstable_requestPaint=B,t.unstable_runWithPriority=function(e,t){switch(e){case 1:case 2:case 3:case 4:case 5:break;default:e=3}var n=_;_=e;try{return t()}finally{_=n}},t.unstable_scheduleCallback=function(e,l,o){var a=t.unstable_now();switch(o="object"==typeof o&&null!==o&&"number"==typeof(o=o.delay)&&0<o?a+o:a,e){case 1:var i=-1;break;case 2:i=250;break;case 5:i=1073741823;break;case 4:i=1e4;break;default:i=5e3}return e={id:P++,callback:l,priorityLevel:e,startTime:o,expirationTime:i=o+i,sortIndex:-1},o>a?(e.sortIndex=o,x(C,e),null===j(O)&&e===j(C)&&(T?s():T=!0,r(D,o-a))):(e.sortIndex=i,x(O,e),N||L||(N=!0,n(I))),e},t.unstable_wrapCallback=function(e){var t=_;return function(){var n=_;_=t;try{return e.apply(this,arguments)}finally{_=n}}}},840:(e,t,n)=>{"use strict";e.exports=n(53)},154:(e,t,n)=>{var r;if("function"==typeof fetch&&(void 0!==n.g&&n.g.fetch?r=n.g.fetch:"undefined"!=typeof window&&window.fetch&&(r=window.fetch)),"undefined"==typeof window||void 0===window.document){var s=r||n(98);s.default&&(s=s.default),t.default=s,e.exports=t.default}}},r={};function s(e){var t=r[e];if(void 0!==t)return t.exports;var l=r[e]={exports:{}};return n[e].call(l.exports,l,l.exports,s),l.exports}t=Object.getPrototypeOf?e=>Object.getPrototypeOf(e):e=>e.__proto__,s.t=function(n,r){if(1&r&&(n=this(n)),8&r)return n;if("object"==typeof n&&n){if(4&r&&n.__esModule)return n;if(16&r&&"function"==typeof n.then)return n}var l=Object.create(null);s.r(l);var o={};e=e||[null,t({}),t([]),t(t)];for(var a=2&r&&n;"object"==typeof a&&!~e.indexOf(a);a=t(a))Object.getOwnPropertyNames(a).forEach((e=>o[e]=()=>n[e]));return o.default=()=>n,s.d(l,o),l},s.d=(e,t)=>{for(var n in t)s.o(t,n)&&!s.o(e,n)&&Object.defineProperty(e,n,{enumerable:!0,get:t[n]})},s.g=function(){if("object"==typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(e){if("object"==typeof window)return window}}(),s.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),s.r=e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},(()=>{"use strict";var e,t=s(893),n=s(935),r=s(294);function l(){return l=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var r in n)Object.prototype.hasOwnProperty.call(n,r)&&(e[r]=n[r])}return e},l.apply(this,arguments)}!function(e){e.Pop="POP",e.Push="PUSH",e.Replace="REPLACE"}(e||(e={}));var o="beforeunload";function a(e){e.preventDefault(),e.returnValue=""}function i(){var e=[];return{get length(){return e.length},push:function(t){return e.push(t),function(){e=e.filter((function(e){return e!==t}))}},call:function(t){e.forEach((function(e){return e&&e(t)}))}}}function p(e){var t={};if(e){var n=e.indexOf("#");n>=0&&(t.hash=e.substr(n),e=e.substr(0,n));var r=e.indexOf("?");r>=0&&(t.search=e.substr(r),e=e.substr(0,r)),e&&(t.pathname=e)}return t}const u=(0,r.createContext)(null),c=(0,r.createContext)(null);function d(t){let{basename:n="/",children:s=null,location:l,navigationType:o=e.Pop,navigator:a,static:i=!1}=t;null!=(0,r.useContext)(c)&&function(e,t){if(!e)throw new Error(t)}(!1);let d=f(n),g=(0,r.useMemo)((()=>({basename:d,navigator:a,static:i})),[d,a,i]);"string"==typeof l&&(l=p(l));let{pathname:h="/",search:v="",hash:m="",state:y=null,key:b="default"}=l,w=(0,r.useMemo)((()=>{let e=function(e,t){if("/"===t)return e;if(!e.toLowerCase().startsWith(t.toLowerCase()))return null;let n=e.charAt(t.length);return n&&"/"!==n?null:e.slice(t.length)||"/"}(h,d);return null==e?null:{pathname:e,search:v,hash:m,state:y,key:b}}),[d,h,v,m,y,b]);return null==w?null:(0,r.createElement)(u.Provider,{value:g},(0,r.createElement)(c.Provider,{children:s,value:{location:w,navigationType:o}}))}const f=e=>e.replace(/\/+$/,"").replace(/^\/*/,"/");var g;!function(e){e.LIGHT="app_light_theme",e.DARK="app_dark_theme"}(g||(g={}));var h=(0,r.createContext)({}),v="theme",m=function(){return m=Object.assign||function(e){for(var t,n=1,r=arguments.length;n<r;n++)for(var s in t=arguments[n])Object.prototype.hasOwnProperty.call(t,s)&&(e[s]=t[s]);return e},m.apply(this,arguments)},y=localStorage.getItem(v)||g.LIGHT;var b=r.createContext(null),w=function(e){e()},k=function(){return w},x={notify:function(){},get:function(){return[]}};var j="undefined"!=typeof window&&void 0!==window.document&&void 0!==window.document.createElement?r.useLayoutEffect:r.useEffect;const S=function(e){var t=e.store,n=e.context,s=e.children,l=(0,r.useMemo)((function(){var e=function(e,t){var n,r=x;function s(){o.onStateChange&&o.onStateChange()}function l(){n||(n=t?t.addNestedSub(s):e.subscribe(s),r=function(){var e=k(),t=null,n=null;return{clear:function(){t=null,n=null},notify:function(){e((function(){for(var e=t;e;)e.callback(),e=e.next}))},get:function(){for(var e=[],n=t;n;)e.push(n),n=n.next;return e},subscribe:function(e){var r=!0,s=n={callback:e,next:null,prev:n};return s.prev?s.prev.next=s:t=s,function(){r&&null!==t&&(r=!1,s.next?s.next.prev=s.prev:n=s.prev,s.prev?s.prev.next=s.next:t=s.next)}}}}())}var o={addNestedSub:function(e){return l(),r.subscribe(e)},notifyNestedSubs:function(){r.notify()},handleChangeWrapper:s,isSubscribed:function(){return Boolean(n)},trySubscribe:l,tryUnsubscribe:function(){n&&(n(),n=void 0,r.clear(),r=x)},getListeners:function(){return r}};return o}(t);return e.onStateChange=e.notifyNestedSubs,{store:t,subscription:e}}),[t]),o=(0,r.useMemo)((function(){return t.getState()}),[t]);j((function(){var e=l.subscription;return e.trySubscribe(),o!==t.getState()&&e.notifyNestedSubs(),function(){e.tryUnsubscribe(),e.onStateChange=null}}),[l,o]);var a=n||b;return r.createElement(a.Provider,{value:l},s)};function E(){return(0,r.useContext)(b)}function O(e){void 0===e&&(e=b);var t=e===b?E:function(){return(0,r.useContext)(e)};return function(){return t().store}}s(679),s(973);var C=O();function P(e){void 0===e&&(e=b);var t=e===b?C:O(e);return function(){return t().dispatch}}var A,_=P();function L(e){for(var t=arguments.length,n=Array(t>1?t-1:0),r=1;r<t;r++)n[r-1]=arguments[r];throw Error("[Immer] minified error nr: "+e+(n.length?" "+n.map((function(e){return"'"+e+"'"})).join(","):"")+". Find the full error at: https://bit.ly/3cXEKWf")}function N(e){return!!e&&!!e[ye]}function T(e){return!!e&&(function(e){if(!e||"object"!=typeof e)return!1;var t=Object.getPrototypeOf(e);if(null===t)return!0;var n=Object.hasOwnProperty.call(t,"constructor")&&t.constructor;return n===Object||"function"==typeof n&&Function.toString.call(n)===be}(e)||Array.isArray(e)||!!e[me]||!!e.constructor[me]||F(e)||q(e))}function R(e,t,n){void 0===n&&(n=!1),0===D(e)?(n?Object.keys:we)(e).forEach((function(r){n&&"symbol"==typeof r||t(r,e[r],e)})):e.forEach((function(n,r){return t(r,n,e)}))}function D(e){var t=e[ye];return t?t.i>3?t.i-4:t.i:Array.isArray(e)?1:F(e)?2:q(e)?3:0}function I(e,t){return 2===D(e)?e.has(t):Object.prototype.hasOwnProperty.call(e,t)}function B(e,t,n){var r=D(e);2===r?e.set(t,n):3===r?(e.delete(t),e.add(n)):e[t]=n}function M(e,t){return e===t?0!==e||1/e==1/t:e!=e&&t!=t}function F(e){return fe&&e instanceof Map}function q(e){return ge&&e instanceof Set}function z(e){return e.o||e.t}function U(e){if(Array.isArray(e))return Array.prototype.slice.call(e);var t=ke(e);delete t[ye];for(var n=we(t),r=0;r<n.length;r++){var s=n[r],l=t[s];!1===l.writable&&(l.writable=!0,l.configurable=!0),(l.get||l.set)&&(t[s]={configurable:!0,writable:!0,enumerable:l.enumerable,value:e[s]})}return Object.create(Object.getPrototypeOf(e),t)}function H(e,t){return void 0===t&&(t=!1),Q(e)||N(e)||!T(e)||(D(e)>1&&(e.set=e.add=e.clear=e.delete=V),Object.freeze(e),t&&R(e,(function(e,t){return H(t,!0)}),!0)),e}function V(){L(2)}function Q(e){return null==e||"object"!=typeof e||Object.isFrozen(e)}function $(e){var t=xe[e];return t||L(18,e),t}function W(){return ce}function X(e,t){t&&($("Patches"),e.u=[],e.s=[],e.v=t)}function K(e){Y(e),e.p.forEach(J),e.p=null}function Y(e){e===ce&&(ce=e.l)}function G(e){return ce={p:[],l:ce,h:e,m:!0,_:0}}function J(e){var t=e[ye];0===t.i||1===t.i?t.j():t.O=!0}function Z(e,t){t._=t.p.length;var n=t.p[0],r=void 0!==e&&e!==n;return t.h.g||$("ES5").S(t,e,r),r?(n[ye].P&&(K(t),L(4)),T(e)&&(e=ee(t,e),t.l||ne(t,e)),t.u&&$("Patches").M(n[ye].t,e,t.u,t.s)):e=ee(t,n,[]),K(t),t.u&&t.v(t.u,t.s),e!==ve?e:void 0}function ee(e,t,n){if(Q(t))return t;var r=t[ye];if(!r)return R(t,(function(s,l){return te(e,r,t,s,l,n)}),!0),t;if(r.A!==e)return t;if(!r.P)return ne(e,r.t,!0),r.t;if(!r.I){r.I=!0,r.A._--;var s=4===r.i||5===r.i?r.o=U(r.k):r.o;R(3===r.i?new Set(s):s,(function(t,l){return te(e,r,s,t,l,n)})),ne(e,s,!1),n&&e.u&&$("Patches").R(r,n,e.u,e.s)}return r.o}function te(e,t,n,r,s,l){if(N(s)){var o=ee(e,s,l&&t&&3!==t.i&&!I(t.D,r)?l.concat(r):void 0);if(B(n,r,o),!N(o))return;e.m=!1}if(T(s)&&!Q(s)){if(!e.h.F&&e._<1)return;ee(e,s),t&&t.A.l||ne(e,s)}}function ne(e,t,n){void 0===n&&(n=!1),e.h.F&&e.m&&H(t,n)}function re(e,t){var n=e[ye];return(n?z(n):e)[t]}function se(e,t){if(t in e)for(var n=Object.getPrototypeOf(e);n;){var r=Object.getOwnPropertyDescriptor(n,t);if(r)return r;n=Object.getPrototypeOf(n)}}function le(e){e.P||(e.P=!0,e.l&&le(e.l))}function oe(e){e.o||(e.o=U(e.t))}function ae(e,t,n){var r=F(t)?$("MapSet").N(t,n):q(t)?$("MapSet").T(t,n):e.g?function(e,t){var n=Array.isArray(e),r={i:n?1:0,A:t?t.A:W(),P:!1,I:!1,D:{},l:t,t:e,k:null,o:null,j:null,C:!1},s=r,l=je;n&&(s=[r],l=Se);var o=Proxy.revocable(s,l),a=o.revoke,i=o.proxy;return r.k=i,r.j=a,i}(t,n):$("ES5").J(t,n);return(n?n.A:W()).p.push(r),r}function ie(e){return N(e)||L(22,e),function e(t){if(!T(t))return t;var n,r=t[ye],s=D(t);if(r){if(!r.P&&(r.i<4||!$("ES5").K(r)))return r.t;r.I=!0,n=pe(t,s),r.I=!1}else n=pe(t,s);return R(n,(function(t,s){r&&function(e,t){return 2===D(e)?e.get(t):e[t]}(r.t,t)===s||B(n,t,e(s))})),3===s?new Set(n):n}(e)}function pe(e,t){switch(t){case 2:return new Map(e);case 3:return Array.from(e)}return U(e)}A=n.unstable_batchedUpdates,w=A;var ue,ce,de="undefined"!=typeof Symbol&&"symbol"==typeof Symbol("x"),fe="undefined"!=typeof Map,ge="undefined"!=typeof Set,he="undefined"!=typeof Proxy&&void 0!==Proxy.revocable&&"undefined"!=typeof Reflect,ve=de?Symbol.for("immer-nothing"):((ue={})["immer-nothing"]=!0,ue),me=de?Symbol.for("immer-draftable"):"__$immer_draftable",ye=de?Symbol.for("immer-state"):"__$immer_state",be=("undefined"!=typeof Symbol&&Symbol.iterator,""+Object.prototype.constructor),we="undefined"!=typeof Reflect&&Reflect.ownKeys?Reflect.ownKeys:void 0!==Object.getOwnPropertySymbols?function(e){return Object.getOwnPropertyNames(e).concat(Object.getOwnPropertySymbols(e))}:Object.getOwnPropertyNames,ke=Object.getOwnPropertyDescriptors||function(e){var t={};return we(e).forEach((function(n){t[n]=Object.getOwnPropertyDescriptor(e,n)})),t},xe={},je={get:function(e,t){if(t===ye)return e;var n=z(e);if(!I(n,t))return function(e,t,n){var r,s=se(t,n);return s?"value"in s?s.value:null===(r=s.get)||void 0===r?void 0:r.call(e.k):void 0}(e,n,t);var r=n[t];return e.I||!T(r)?r:r===re(e.t,t)?(oe(e),e.o[t]=ae(e.A.h,r,e)):r},has:function(e,t){return t in z(e)},ownKeys:function(e){return Reflect.ownKeys(z(e))},set:function(e,t,n){var r=se(z(e),t);if(null==r?void 0:r.set)return r.set.call(e.k,n),!0;if(!e.P){var s=re(z(e),t),l=null==s?void 0:s[ye];if(l&&l.t===n)return e.o[t]=n,e.D[t]=!1,!0;if(M(n,s)&&(void 0!==n||I(e.t,t)))return!0;oe(e),le(e)}return e.o[t]===n&&"number"!=typeof n&&(void 0!==n||t in e.o)||(e.o[t]=n,e.D[t]=!0,!0)},deleteProperty:function(e,t){return void 0!==re(e.t,t)||t in e.t?(e.D[t]=!1,oe(e),le(e)):delete e.D[t],e.o&&delete e.o[t],!0},getOwnPropertyDescriptor:function(e,t){var n=z(e),r=Reflect.getOwnPropertyDescriptor(n,t);return r?{writable:!0,configurable:1!==e.i||"length"!==t,enumerable:r.enumerable,value:n[t]}:r},defineProperty:function(){L(11)},getPrototypeOf:function(e){return Object.getPrototypeOf(e.t)},setPrototypeOf:function(){L(12)}},Se={};R(je,(function(e,t){Se[e]=function(){return arguments[0]=arguments[0][0],t.apply(this,arguments)}})),Se.deleteProperty=function(e,t){return Se.set.call(this,e,t,void 0)},Se.set=function(e,t,n){return je.set.call(this,e[0],t,n,e[0])};var Ee=function(){function e(e){var t=this;this.g=he,this.F=!0,this.produce=function(e,n,r){if("function"==typeof e&&"function"!=typeof n){var s=n;n=e;var l=t;return function(e){var t=this;void 0===e&&(e=s);for(var r=arguments.length,o=Array(r>1?r-1:0),a=1;a<r;a++)o[a-1]=arguments[a];return l.produce(e,(function(e){var r;return(r=n).call.apply(r,[t,e].concat(o))}))}}var o;if("function"!=typeof n&&L(6),void 0!==r&&"function"!=typeof r&&L(7),T(e)){var a=G(t),i=ae(t,e,void 0),p=!0;try{o=n(i),p=!1}finally{p?K(a):Y(a)}return"undefined"!=typeof Promise&&o instanceof Promise?o.then((function(e){return X(a,r),Z(e,a)}),(function(e){throw K(a),e})):(X(a,r),Z(o,a))}if(!e||"object"!=typeof e){if(void 0===(o=n(e))&&(o=e),o===ve&&(o=void 0),t.F&&H(o,!0),r){var u=[],c=[];$("Patches").M(e,o,u,c),r(u,c)}return o}L(21,e)},this.produceWithPatches=function(e,n){if("function"==typeof e)return function(n){for(var r=arguments.length,s=Array(r>1?r-1:0),l=1;l<r;l++)s[l-1]=arguments[l];return t.produceWithPatches(n,(function(t){return e.apply(void 0,[t].concat(s))}))};var r,s,l=t.produce(e,n,(function(e,t){r=e,s=t}));return"undefined"!=typeof Promise&&l instanceof Promise?l.then((function(e){return[e,r,s]})):[l,r,s]},"boolean"==typeof(null==e?void 0:e.useProxies)&&this.setUseProxies(e.useProxies),"boolean"==typeof(null==e?void 0:e.autoFreeze)&&this.setAutoFreeze(e.autoFreeze)}var t=e.prototype;return t.createDraft=function(e){T(e)||L(8),N(e)&&(e=ie(e));var t=G(this),n=ae(this,e,void 0);return n[ye].C=!0,Y(t),n},t.finishDraft=function(e,t){var n=(e&&e[ye]).A;return X(n,t),Z(void 0,n)},t.setAutoFreeze=function(e){this.F=e},t.setUseProxies=function(e){e&&!he&&L(20),this.g=e},t.applyPatches=function(e,t){var n;for(n=t.length-1;n>=0;n--){var r=t[n];if(0===r.path.length&&"replace"===r.op){e=r.value;break}}n>-1&&(t=t.slice(n+1));var s=$("Patches").$;return N(e)?s(e,t):this.produce(e,(function(e){return s(e,t)}))},e}(),Oe=new Ee,Ce=Oe.produce;Oe.produceWithPatches.bind(Oe),Oe.setAutoFreeze.bind(Oe),Oe.setUseProxies.bind(Oe),Oe.applyPatches.bind(Oe),Oe.createDraft.bind(Oe),Oe.finishDraft.bind(Oe);const Pe=Ce;function Ae(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function _e(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function Le(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?_e(Object(n),!0).forEach((function(t){Ae(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):_e(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function Ne(e){return"Minified Redux error #"+e+"; visit https://redux.js.org/Errors?code="+e+" for the full message or use the non-minified dev environment for full errors. "}var Te="function"==typeof Symbol&&Symbol.observable||"@@observable",Re=function(){return Math.random().toString(36).substring(7).split("").join(".")},De={INIT:"@@redux/INIT"+Re(),REPLACE:"@@redux/REPLACE"+Re(),PROBE_UNKNOWN_ACTION:function(){return"@@redux/PROBE_UNKNOWN_ACTION"+Re()}};function Ie(e){if("object"!=typeof e||null===e)return!1;for(var t=e;null!==Object.getPrototypeOf(t);)t=Object.getPrototypeOf(t);return Object.getPrototypeOf(e)===t}function Be(e,t,n){var r;if("function"==typeof t&&"function"==typeof n||"function"==typeof n&&"function"==typeof arguments[3])throw new Error(Ne(0));if("function"==typeof t&&void 0===n&&(n=t,t=void 0),void 0!==n){if("function"!=typeof n)throw new Error(Ne(1));return n(Be)(e,t)}if("function"!=typeof e)throw new Error(Ne(2));var s=e,l=t,o=[],a=o,i=!1;function p(){a===o&&(a=o.slice())}function u(){if(i)throw new Error(Ne(3));return l}function c(e){if("function"!=typeof e)throw new Error(Ne(4));if(i)throw new Error(Ne(5));var t=!0;return p(),a.push(e),function(){if(t){if(i)throw new Error(Ne(6));t=!1,p();var n=a.indexOf(e);a.splice(n,1),o=null}}}function d(e){if(!Ie(e))throw new Error(Ne(7));if(void 0===e.type)throw new Error(Ne(8));if(i)throw new Error(Ne(9));try{i=!0,l=s(l,e)}finally{i=!1}for(var t=o=a,n=0;n<t.length;n++)(0,t[n])();return e}function f(e){if("function"!=typeof e)throw new Error(Ne(10));s=e,d({type:De.REPLACE})}function g(){var e,t=c;return(e={subscribe:function(e){if("object"!=typeof e||null===e)throw new Error(Ne(11));function n(){e.next&&e.next(u())}return n(),{unsubscribe:t(n)}}})[Te]=function(){return this},e}return d({type:De.INIT}),(r={dispatch:d,subscribe:c,getState:u,replaceReducer:f})[Te]=g,r}function Me(e){for(var t=Object.keys(e),n={},r=0;r<t.length;r++){var s=t[r];"function"==typeof e[s]&&(n[s]=e[s])}var l,o=Object.keys(n);try{!function(e){Object.keys(e).forEach((function(t){var n=e[t];if(void 0===n(void 0,{type:De.INIT}))throw new Error(Ne(12));if(void 0===n(void 0,{type:De.PROBE_UNKNOWN_ACTION()}))throw new Error(Ne(13))}))}(n)}catch(e){l=e}return function(e,t){if(void 0===e&&(e={}),l)throw l;for(var r=!1,s={},a=0;a<o.length;a++){var i=o[a],p=n[i],u=e[i],c=p(u,t);if(void 0===c)throw t&&t.type,new Error(Ne(14));s[i]=c,r=r||c!==u}return(r=r||o.length!==Object.keys(e).length)?s:e}}function Fe(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];return 0===t.length?function(e){return e}:1===t.length?t[0]:t.reduce((function(e,t){return function(){return e(t.apply(void 0,arguments))}}))}function qe(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];return function(e){return function(){var n=e.apply(void 0,arguments),r=function(){throw new Error(Ne(15))},s={getState:n.getState,dispatch:function(){return r.apply(void 0,arguments)}},l=t.map((function(e){return e(s)}));return r=Fe.apply(void 0,l)(n.dispatch),Le(Le({},n),{},{dispatch:r})}}}function ze(e){return function(t){var n=t.dispatch,r=t.getState;return function(t){return function(s){return"function"==typeof s?s(n,r,e):t(s)}}}}var Ue=ze();Ue.withExtraArgument=ze;const He=Ue;var Ve,Qe=(Ve=function(e,t){return Ve=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,t){e.__proto__=t}||function(e,t){for(var n in t)Object.prototype.hasOwnProperty.call(t,n)&&(e[n]=t[n])},Ve(e,t)},function(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Class extends value "+String(t)+" is not a constructor or null");function n(){this.constructor=e}Ve(e,t),e.prototype=null===t?Object.create(t):(n.prototype=t.prototype,new n)}),$e=function(e,t){for(var n=0,r=t.length,s=e.length;n<r;n++,s++)e[s]=t[n];return e},We=Object.defineProperty,Xe=(Object.defineProperties,Object.getOwnPropertyDescriptors,Object.getOwnPropertySymbols),Ke=Object.prototype.hasOwnProperty,Ye=Object.prototype.propertyIsEnumerable,Ge=function(e,t,n){return t in e?We(e,t,{enumerable:!0,configurable:!0,writable:!0,value:n}):e[t]=n},Je=function(e,t){for(var n in t||(t={}))Ke.call(t,n)&&Ge(e,n,t[n]);if(Xe)for(var r=0,s=Xe(t);r<s.length;r++)n=s[r],Ye.call(t,n)&&Ge(e,n,t[n]);return e},Ze="undefined"!=typeof window&&window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__?window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__:function(){if(0!==arguments.length)return"object"==typeof arguments[0]?Fe:Fe.apply(null,arguments)};"undefined"!=typeof window&&window.__REDUX_DEVTOOLS_EXTENSION__&&window.__REDUX_DEVTOOLS_EXTENSION__;var et=function(e){function t(){for(var n=[],r=0;r<arguments.length;r++)n[r]=arguments[r];var s=e.apply(this,n)||this;return Object.setPrototypeOf(s,t.prototype),s}return Qe(t,e),Object.defineProperty(t,Symbol.species,{get:function(){return t},enumerable:!1,configurable:!0}),t.prototype.concat=function(){for(var t=[],n=0;n<arguments.length;n++)t[n]=arguments[n];return e.prototype.concat.apply(this,t)},t.prototype.prepend=function(){for(var e=[],n=0;n<arguments.length;n++)e[n]=arguments[n];return 1===e.length&&Array.isArray(e[0])?new(t.bind.apply(t,$e([void 0],e[0].concat(this)))):new(t.bind.apply(t,$e([void 0],e.concat(this))))},t}(Array);function tt(e){var t,n=function(e){return function(e){void 0===e&&(e={});var t=e.thunk,n=void 0===t||t,r=(e.immutableCheck,e.serializableCheck,new et);return n&&(function(e){return"boolean"==typeof e}(n)?r.push(He):r.push(He.withExtraArgument(n.extraArgument))),r}(e)},r=e||{},s=r.reducer,l=void 0===s?void 0:s,o=r.middleware,a=void 0===o?n():o,i=r.devTools,p=void 0===i||i,u=r.preloadedState,c=void 0===u?void 0:u,d=r.enhancers,f=void 0===d?void 0:d;if("function"==typeof l)t=l;else{if(!function(e){if("object"!=typeof e||null===e)return!1;var t=Object.getPrototypeOf(e);if(null===t)return!0;for(var n=t;null!==Object.getPrototypeOf(n);)n=Object.getPrototypeOf(n);return t===n}(l))throw new Error('"reducer" is a required argument, and must be a function or an object of functions that can be passed to combineReducers');t=Me(l)}var g=a;"function"==typeof g&&(g=g(n));var h=qe.apply(void 0,g),v=Fe;p&&(v=Ze(Je({trace:!1},"object"==typeof p&&p)));var m=[h];return Array.isArray(f)?m=$e([h],f):"function"==typeof f&&(m=f(m)),Be(t,c,v.apply(void 0,m))}function nt(e,t){function n(){for(var n=[],r=0;r<arguments.length;r++)n[r]=arguments[r];if(t){var s=t.apply(void 0,n);if(!s)throw new Error("prepareAction did not return an object");return Je(Je({type:e,payload:s.payload},"meta"in s&&{meta:s.meta}),"error"in s&&{error:s.error})}return{type:e,payload:n[0]}}return n.toString=function(){return""+e},n.type=e,n.match=function(t){return t.type===e},n}function rt(e){var t,n={},r=[],s={addCase:function(e,t){var r="string"==typeof e?e:e.type;if(r in n)throw new Error("addCase cannot be called with two reducers for the same action type");return n[r]=t,s},addMatcher:function(e,t){return r.push({matcher:e,reducer:t}),s},addDefaultCase:function(e){return t=e,s}};return e(s),[n,r,t]}function st(e){var t=e.name;if(!t)throw new Error("`name` is a required option for createSlice");var n,r="function"==typeof e.initialState?e.initialState:Pe(e.initialState,(function(){})),s=e.reducers||{},l=Object.keys(s),o={},a={},i={};function p(){var t="function"==typeof e.extraReducers?rt(e.extraReducers):[e.extraReducers],n=t[0],s=void 0===n?{}:n,l=t[1],o=void 0===l?[]:l,i=t[2],p=void 0===i?void 0:i,u=Je(Je({},s),a);return function(e,t,n,r){void 0===n&&(n=[]);var s,l="function"==typeof t?rt(t):[t,n,r],o=l[0],a=l[1],i=l[2];if(function(e){return"function"==typeof e}(e))s=function(){return Pe(e(),(function(){}))};else{var p=Pe(e,(function(){}));s=function(){return p}}function u(e,t){void 0===e&&(e=s());var n=$e([o[t.type]],a.filter((function(e){return(0,e.matcher)(t)})).map((function(e){return e.reducer})));return 0===n.filter((function(e){return!!e})).length&&(n=[i]),n.reduce((function(e,n){if(n){var r;if(N(e))return void 0===(r=n(e,t))?e:r;if(T(e))return Pe(e,(function(e){return n(e,t)}));if(void 0===(r=n(e,t))){if(null===e)return e;throw Error("A case reducer on a non-draftable value must not return undefined")}return r}return e}),e)}return u.getInitialState=s,u}(r,u,o,p)}return l.forEach((function(e){var n,r,l=s[e],p=function(e,t){return e+"/"+t}(t,e);"reducer"in l?(n=l.reducer,r=l.prepare):n=l,o[e]=n,a[p]=n,i[e]=r?nt(p,r):nt(p)})),{name:t,reducer:function(e,t){return n||(n=p()),n(e,t)},actions:i,caseReducers:o,getInitialState:function(){return n||(n=p()),n.getInitialState()}}}Object.assign;var lt="listenerMiddleware";nt(lt+"/add"),nt(lt+"/removeAll"),nt(lt+"/remove"),function(){function e(e,t){var n=s[e];return n?n.enumerable=t:s[e]=n={configurable:!0,enumerable:t,get:function(){var t=this[ye];return je.get(t,e)},set:function(t){var n=this[ye];je.set(n,e,t)}},n}function t(e){for(var t=e.length-1;t>=0;t--){var s=e[t][ye];if(!s.P)switch(s.i){case 5:r(s)&&le(s);break;case 4:n(s)&&le(s)}}}function n(e){for(var t=e.t,n=e.k,r=we(n),s=r.length-1;s>=0;s--){var l=r[s];if(l!==ye){var o=t[l];if(void 0===o&&!I(t,l))return!0;var a=n[l],i=a&&a[ye];if(i?i.t!==o:!M(a,o))return!0}}var p=!!t[ye];return r.length!==we(t).length+(p?0:1)}function r(e){var t=e.k;if(t.length!==e.t.length)return!0;var n=Object.getOwnPropertyDescriptor(t,t.length-1);if(n&&!n.get)return!0;for(var r=0;r<t.length;r++)if(!t.hasOwnProperty(r))return!0;return!1}var s={};!function(e,t){xe[e]||(xe[e]=t)}("ES5",{J:function(t,n){var r=Array.isArray(t),s=function(t,n){if(t){for(var r=Array(n.length),s=0;s<n.length;s++)Object.defineProperty(r,""+s,e(s,!0));return r}var l=ke(n);delete l[ye];for(var o=we(l),a=0;a<o.length;a++){var i=o[a];l[i]=e(i,t||!!l[i].enumerable)}return Object.create(Object.getPrototypeOf(n),l)}(r,t),l={i:r?5:4,A:n?n.A:W(),P:!1,I:!1,D:{},l:n,t,k:s,o:null,O:!1,C:!1};return Object.defineProperty(s,ye,{value:l,writable:!0}),s},S:function(e,n,s){s?N(n)&&n[ye].A===e&&t(e.p):(e.u&&function e(t){if(t&&"object"==typeof t){var n=t[ye];if(n){var s=n.t,l=n.k,o=n.D,a=n.i;if(4===a)R(l,(function(t){t!==ye&&(void 0!==s[t]||I(s,t)?o[t]||e(l[t]):(o[t]=!0,le(n)))})),R(s,(function(e){void 0!==l[e]||I(l,e)||(o[e]=!1,le(n))}));else if(5===a){if(r(n)&&(le(n),o.length=!0),l.length<s.length)for(var i=l.length;i<s.length;i++)o[i]=!1;else for(var p=s.length;p<l.length;p++)o[p]=!0;for(var u=Math.min(l.length,s.length),c=0;c<u;c++)l.hasOwnProperty(c)||(o[c]=!0),void 0===o[c]&&e(l[c])}}}}(e.p[0]),t(e.p))},K:function(e){return 4===e.i?n(e):r(e)}})}();var ot=st({name:"counter",initialState:{value:0},reducers:{increment:function(e){e.value+=1},decrement:function(e){e.value-=1}}}),at=(ot.actions,ot.reducer),it=function(e,t,n){if(n||2===arguments.length)for(var r,s=0,l=t.length;s<l;s++)!r&&s in t||(r||(r=Array.prototype.slice.call(t,0,s)),r[s]=t[s]);return e.concat(r||Array.prototype.slice.call(t))};function pt(e,t,n){return void 0===t&&(t={}),void 0===n&&(n=[]),it(it([e],n.filter(Boolean),!0),Object.entries(t).filter((function(e){e[0];var t=e[1];return Boolean(t)})).map((function(e){return e[0]})),!0).join(" ")}const ut={Button:"a4nOaSMD",clear:"FAEtIpnJ",clearInverted:"DYECq6t7",outline:"pxBl_FAS",background:"nXdyjtYb",backgroundInverted:"EXVU3xfn",square:"pKS1Awqk",size_m:"xvXQXBtA",size_l:"rsm7T6wj",size_xl:"WJ8HetTm",disabled:"AeTCGE3z"};var ct,dt,ft=function(){return ft=Object.assign||function(e){for(var t,n=1,r=arguments.length;n<r;n++)for(var s in t=arguments[n])Object.prototype.hasOwnProperty.call(t,s)&&(e[s]=t[s]);return e},ft.apply(this,arguments)};!function(e){e.CLEAR="clear",e.CLEAR_INVERTED="clearInverted",e.OUTLINE="outline",e.BACKGROUND="background",e.BACKGROUND_INVERTED="backgroundInverted"}(ct||(ct={})),function(e){e.M="size_m",e.L="size_l",e.XL="size_xl"}(dt||(dt={}));var gt=(0,r.memo)((function(e){var n,r=e.className,s=e.children,l=e.theme,o=e.square,a=e.disabled,i=e.size,p=void 0===i?dt.M:i,u=function(e,t){var n={};for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&t.indexOf(r)<0&&(n[r]=e[r]);if(null!=e&&"function"==typeof Object.getOwnPropertySymbols){var s=0;for(r=Object.getOwnPropertySymbols(e);s<r.length;s++)t.indexOf(r[s])<0&&Object.prototype.propertyIsEnumerable.call(e,r[s])&&(n[r[s]]=e[r[s]])}return n}(e,["className","children","theme","square","disabled","size"]),c=((n={})[ut[l]]=!0,n[ut.square]=o,n[ut[p]]=!0,n[ut.disabled]=a,n);return(0,t.jsx)("button",ft({type:"button",className:pt(ut.Button,c,[r]),disabled:a},u,{children:s}),void 0)})),ht="NOT_FOUND",vt=function(e,t){return e===t};function mt(e,t){var n,r,s="object"==typeof t?t:{equalityCheck:t},l=s.equalityCheck,o=void 0===l?vt:l,a=s.maxSize,i=void 0===a?1:a,p=s.resultEqualityCheck,u=function(e){return function(t,n){if(null===t||null===n||t.length!==n.length)return!1;for(var r=t.length,s=0;s<r;s++)if(!e(t[s],n[s]))return!1;return!0}}(o),c=1===i?(n=u,{get:function(e){return r&&n(r.key,e)?r.value:ht},put:function(e,t){r={key:e,value:t}},getEntries:function(){return r?[r]:[]},clear:function(){r=void 0}}):function(e,t){var n=[];function r(e){var r=n.findIndex((function(n){return t(e,n.key)}));if(r>-1){var s=n[r];return r>0&&(n.splice(r,1),n.unshift(s)),s.value}return ht}return{get:r,put:function(t,s){r(t)===ht&&(n.unshift({key:t,value:s}),n.length>e&&n.pop())},getEntries:function(){return n},clear:function(){n=[]}}}(i,u);function d(){var t=c.get(arguments);if(t===ht){if(t=e.apply(null,arguments),p){var n=c.getEntries(),r=n.find((function(e){return p(e.value,t)}));r&&(t=r.value)}c.put(arguments,t)}return t}return d.clearCache=function(){return c.clear()},d}function yt(e){var t=Array.isArray(e[0])?e[0]:e;if(!t.every((function(e){return"function"==typeof e}))){var n=t.map((function(e){return"function"==typeof e?"function "+(e.name||"unnamed")+"()":typeof e})).join(", ");throw new Error("createSelector expects all input-selectors to be functions, but received the following types: ["+n+"]")}return t}function bt(e){for(var t=arguments.length,n=new Array(t>1?t-1:0),r=1;r<t;r++)n[r-1]=arguments[r];var s=function(){for(var t=arguments.length,r=new Array(t),s=0;s<t;s++)r[s]=arguments[s];var l,o=0,a={memoizeOptions:void 0},i=r.pop();if("object"==typeof i&&(a=i,i=r.pop()),"function"!=typeof i)throw new Error("createSelector expects an output function after the inputs, but received: ["+typeof i+"]");var p=a,u=p.memoizeOptions,c=void 0===u?n:u,d=Array.isArray(c)?c:[c],f=yt(r),g=e.apply(void 0,[function(){return o++,i.apply(null,arguments)}].concat(d)),h=e((function(){for(var e=[],t=f.length,n=0;n<t;n++)e.push(f[n].apply(null,arguments));return l=g.apply(null,e)}));return Object.assign(h,{resultFunc:i,memoizedResultFunc:g,dependencies:f,lastResult:function(){return l},recomputations:function(){return o},resetRecomputations:function(){return o=0}}),h};return s}var wt=(bt(mt)((function(e){return e.counter}),(function(e){return e.value})),"user"),kt=st({name:"user",initialState:{},reducers:{setAuthData:function(e,t){e.authData=t.payload},initAuthData:function(e){var t=localStorage.getItem(wt);t&&(e.authData=JSON.parse(t))},logout:function(e){e.authData=void 0,localStorage.removeItem(wt)}}}),xt=kt.actions,jt=kt.reducer,St=function(){return St=Object.assign||function(e){for(var t,n=1,r=arguments.length;n<r;n++)for(var s in t=arguments[n])Object.prototype.hasOwnProperty.call(t,s)&&(e[s]=t[s]);return e},St.apply(this,arguments)},Et=function(){return Et=Object.assign||function(e){for(var t,n=1,r=arguments.length;n<r;n++)for(var s in t=arguments[n])Object.prototype.hasOwnProperty.call(t,s)&&(e[s]=t[s]);return e},Et.apply(this,arguments)};var Ot=function(){return Ot=Object.assign||function(e){for(var t,n=1,r=arguments.length;n<r;n++)for(var s in t=arguments[n])Object.prototype.hasOwnProperty.call(t,s)&&(e[s]=t[s]);return e},Ot.apply(this,arguments)},Ct=function(){return Ct=Object.assign||function(e){for(var t,n=1,r=arguments.length;n<r;n++)for(var s in t=arguments[n])Object.prototype.hasOwnProperty.call(t,s)&&(e[s]=t[s]);return e},Ct.apply(this,arguments)};const Pt=function(e){var n=e.isActive,s=e.setIsActive,l=e.changeable,o=e.text,a=(0,r.useCallback)((function(){s((function(e){return!e}))}),[s]);return(0,t.jsxs)("button",Ct({onClick:a},{children:[n?l[0]:l[1]," ",o]}),void 0)},At=JSON.parse('{"Введение в программную инженерию":[["Введение в программную инженерию. Понятие ПИ.","<div class=\\"markdown prose w-full break-words dark:prose-invert light\\"><p>Программная инженерия (ПИ) - это область знаний и практическая деятельность, связанная с разработкой и поддержкой программного обеспечения. Понятие программной инженерии охватывает процессы и методы, которые применяются при создании программных продуктов, а также управление жизненным циклом программных систем.</p><p>Этот подход к разработке программного обеспечения включает в себя систематические методы, техники и инструменты, которые позволяют разработчикам эффективно и качественно создавать программы, учитывая различные аспекты, такие как требования заказчиков, проектирование, тестирование, сопровождение и обновление.</p><p>Важными аспектами программной инженерии являются коллективная работа, использование стандартов и практик, а также стремление к повторному использованию кода и минимизации ошибок через систематические подходы к разработке и тестированию. Это помогает обеспечить надежность, масштабируемость и поддерживаемость программных продуктов в долгосрочной перспективе.</p></div>"],["Стандарты и методологии разработки программного обеспечения. Свойства программного обеспечения.","<div class=\\"markdown prose w-full break-words dark:prose-invert light\\"><p>Стандарты и методологии разработки программного обеспечения (ПО) являются важными инструментами, которые обеспечивают структурированный и систематический подход к созданию программных продуктов. Они помогают улучшить качество, надежность и эффективность разработки, а также способствуют снижению рисков и затрат.</p><p>Стандарты разработки ПО определяют правила, нормы и рекомендации, которые разработчики должны соблюдать в процессе создания программных продуктов. Это могут быть стандарты на уровне компании или отраслевые международные стандарты. Например, стандарт ISO/IEC 12207 определяет процессы жизненного цикла программного обеспечения, включая его разработку, тестирование, управление конфигурацией и сопровождение.</p><p>Методологии разработки ПО представляют собой наборы процедур, инструментов и правил, которые определяют, каким образом будет проходить процесс разработки. К ним относятся Agile (гибкая разработка), Waterfall (каскадная модель), Scrum, и другие. Каждая из методологий имеет свои преимущества и подходит для различных типов проектов.</p><p>Свойства программного обеспечения обусловливают его качество и способность удовлетворить потребности пользователей. Вот некоторые из основных свойств программного обеспечения:</p><ol><li><p>Функциональность: Способность программы выполнять свои предназначенные задачи и функции согласно требованиям.</p></li><li><p>Надежность: Способность программы работать без сбоев и ошибок в течение определенного периода времени (uptime).</p></li><li><p>Эффективность: Уровень ресурсоэффективности программы, такой как использование памяти и процессорного времени.</p></li><li><p>Удобство использования: Простота взаимодействия пользователя с программой и понимания ее интерфейса.</p></li><li><p>Устойчивость к изменениям: Способность программы адаптироваться к изменениям в требованиях и окружающей среде.</p></li><li><p>Поддерживаемость: Легкость поддержки и обновления программного обеспечения.</p></li><li><p>Переносимость: Возможность программы работать на различных платформах и операционных системах без изменений.</p></li></ol><p>Эти свойства являются основой для оценки качества программного обеспечения и определяют его ценность для пользователей и заказчиков.</p></div>"],["Классические процессы и модели.","<div class=\\"markdown prose w-full break-words dark:prose-invert light\\"><p>Классические процессы и модели в программной инженерии представляют собой подходы к разработке программного обеспечения, которые были разработаны в прошлом и оказали значительное влияние на индустрию. Вот некоторые из них:</p><ol><li><p>Модель Waterfall (Каскадная модель):\\nМодель Waterfall - одна из самых старых и простых моделей разработки ПО. Она предполагает последовательное выполнение этапов разработки: определение требований, проектирование, реализация, тестирование и сопровождение. Каждый этап завершается перед переходом к следующему. Такой линейный подход может быть эффективен для маленьких проектов с четкими и стабильными требованиями, но неэффективен для больших и сложных проектов, где изменения требований более вероятны.</p></li><li><p>Модель V-образ (V-модель):\\nМодель V-образ - это улучшенная версия каскадной модели. Каждый этап разработки имеет соответствующий этап тестирования. Таким образом, сразу после завершения этапа разработки, выполняется этап соответствующего тестирования. Это позволяет своевременно выявлять ошибки и обеспечивать более надежное программное обеспечение.</p></li><li><p>Модель спирального развития:\\nМодель спирального развития - это итеративная модель, которая объединяет в себе элементы каскадной модели и итерационного подхода. Проект проходит чередующиеся циклы разработки, включающие планирование, риски, разработку, тестирование и оценку. Этот подход позволяет быстрее реагировать на изменения и учитывать обратную связь от пользователей.</p></li><li><p>Методология Agile (Гибкая разработка):\\nAgile - это семейство методологий разработки ПО, которые акцентируют внимание на гибкости и адаптивности. Agile-подходы включают Scrum, Kanban, XP (экстремальное программирование) и другие. Основной принцип Agile заключается в частых итерациях разработки с активным участием заказчика и команды разработчиков. Этот подход позволяет быстрее реагировать на изменения требований и более гибко управлять проектом.</p></li></ol><p>Каждая из этих классических процессов и моделей имеет свои преимущества и ограничения. Выбор конкретной модели зависит от характера проекта, его объема, сложности, требований и специфических потребностей команды разработчиков и заказчика. Применение адекватной модели разработки ПО помогает улучшить качество продукта, управление рисками и сроки разработки.</p></div>"],["Основные компоненты технологии создания программного продукта.","<div class=\\"markdown prose w-full break-words dark:prose-invert light\\"><p>Основные компоненты технологии создания программного продукта включают в себя различные этапы и инструменты, которые используются в процессе разработки программного обеспечения. Вот основные компоненты:</p><ol><li><p>Требования:\\nЭтот компонент представляет собой процесс сбора, анализа и документирования требований к программному продукту. Здесь определяются функциональные и нефункциональные требования, которые должны быть учтены в процессе разработки.</p></li><li><p>Проектирование:\\nПроектирование - это этап, на котором разрабатывается архитектура программного продукта. Здесь определяются структура, компоненты, интерфейсы, а также взаимодействие между ними. Проектирование позволяет создать план, который будет использоваться в процессе разработки программы.</p></li><li><p>Реализация (кодирование):\\nЭтот этап представляет собой создание фактического исходного кода программы на основе разработанных архитектурных решений и спецификаций. Разработчики пишут код на выбранном языке программирования и используют различные инструменты для обеспечения качества кода.</p></li><li><p>Тестирование:\\nТестирование - это процесс проверки программного продукта на соответствие требованиям и выявление ошибок и дефектов. Тестирование включает различные виды тестов, такие как модульное тестирование, интеграционное тестирование, системное тестирование и приемочное тестирование.</p></li><li><p>Внедрение и сопровождение:\\nЭтот этап связан с развертыванием программного продукта и его внедрением в реальную рабочую среду. После внедрения следует сопровождение, которое включает поддержку и обновление программного обеспечения, а также исправление выявленных ошибок в процессе эксплуатации.</p></li><li><p>Управление конфигурацией:\\nУправление конфигурацией - это процесс контроля и учета всех элементов, входящих в программный продукт, включая исходный код, документацию, библиотеки и т.д. Это помогает обеспечить целостность и возможность отслеживания изменений в продукте.</p></li><li><p>Документация:\\nДокументация является важным компонентом, который описывает процессы разработки, архитектуру, использование и обслуживание программного продукта. Хорошо составленная документация упрощает сопровождение и поддержку продукта в долгосрочной перспективе.</p></li></ol><p>Все эти компоненты технологии создания программного продукта взаимосвязаны и важны для успешного завершения проекта. Комбинация правильных методологий и инструментов позволяет эффективно разрабатывать качественное программное обеспечение, соответствующее требованиям заказчика.</p></div>"],["Модель технологического процесса создания программного продукта.","<div class=\\"markdown prose w-full break-words dark:prose-invert light\\"><p>Модель технологического процесса создания программного продукта обычно описывает последовательность шагов, которые выполняются в процессе разработки программного обеспечения. Одной из наиболее распространенных моделей технологического процесса является \\"модель жизненного цикла программного обеспечения\\". Эта модель охватывает различные фазы разработки ПО. Вот основные этапы модели жизненного цикла программного обеспечения:</p><ol><li><p>Анализ и сбор требований:\\nНа этом этапе определяются требования заказчика к программному продукту. Это включает сбор и анализ функциональных и нефункциональных требований, а также установление ограничений и возможностей продукта.</p></li><li><p>Проектирование:\\nНа этапе проектирования создается общая архитектура программного продукта. Здесь определяются компоненты, структура, интерфейсы и взаимосвязи между ними.</p></li><li><p>Реализация (кодирование):\\nНа этом этапе разработчики создают фактический исходный код программы, руководствуясь требованиями и архитектурой, определенными на предыдущих этапах.</p></li><li><p>Тестирование:\\nПосле завершения разработки программного продукта, он проходит через различные виды тестирования, чтобы обеспечить соответствие требованиям и выявить и исправить ошибки и дефекты.</p></li><li><p>Внедрение и сопровождение:\\nНа этапе внедрения программный продукт разворачивается и внедряется в реальную рабочую среду. После внедрения следует сопровождение, которое включает поддержку и обновление программного обеспечения.</p></li><li><p>Управление конфигурацией и документация:\\nВ процессе разработки ПО важно управлять конфигурацией, чтобы отслеживать изменения и обеспечивать целостность продукта. Также, составление документации, описывающей процессы разработки и работу программного продукта, является важным компонентом.</p></li></ol><p>Важно отметить, что существует множество моделей технологического процесса разработки ПО, таких как Agile, Spiral, V-модель и другие. Выбор конкретной модели зависит от характеристик проекта, его размера, сложности, требований и предпочтений команды разработчиков и заказчика.</p></div>"],["Методология моделирования IDEF0.","<div class=\\"markdown prose w-full break-words dark:prose-invert light\\"><p>Методология моделирования IDEF0 (Integration Definition for Function Modeling) представляет собой инструмент для функционального моделирования и анализа систем. Она была разработана в США в рамках программы IDEF (Integration Definition for Function Modeling) в начале 1980-х годов и стала широко используемой в инженерии и управлении проектами.</p><p>Основной целью методологии IDEF0 является предоставление формального и универсального способа описания функциональных характеристик системы или процесса. Она позволяет строить графические модели, которые иллюстрируют структуру и связи между функциями системы.</p><p>Основные характеристики методологии IDEF0:</p><ol><li><p>Диаграммы IDEF0:\\nМетодология использует блок-схемы для представления функциональных моделей. Диаграммы IDEF0 состоят из блоков, стрелок и текстовых обозначений, которые помогают визуализировать структуру и взаимосвязи функций системы.</p></li><li><p>Функциональный подход:\\nIDEF0 сосредотачивается на функциональных характеристиках системы или процесса. Это позволяет выделить ключевые элементы и процессы, улучшить понимание системы и производительности.</p></li><li><p>Иерархическая структура:\\nМодели, созданные с помощью IDEF0, могут быть организованы в иерархическую структуру, что упрощает анализ и понимание сложных систем.</p></li><li><p>Системный анализ и оптимизация:\\nМетодология IDEF0 позволяет проводить анализ функциональных моделей, выявлять узкие места и оптимизировать процессы.</p></li><li><p>Стандартизация:\\nIDEF0 является стандартизированным методом моделирования, что обеспечивает единый подход к описанию функциональных характеристик системы или процесса.</p></li></ol><p>Методология моделирования IDEF0 находит широкое применение в различных областях, таких как управление проектами, бизнес-процессы, системный анализ, разработка программного обеспечения и другие сферы, где важна четкая и структурированная модель функциональности системы или процесса.</p></div>"],["Объектно-ориентированное моделирование.","<div class=\\"markdown prose w-full break-words dark:prose-invert light\\"><p>Объектно-ориентированное моделирование (ООМ) - это подход к анализу, проектированию и разработке программного обеспечения, основанный на парадигме объектно-ориентированного программирования (ООП). ООМ позволяет структурировать систему в виде взаимосвязанных объектов, которые взаимодействуют друг с другом для выполнения функций и предоставления услуг.</p><p>Основные принципы и характеристики объекто-ориентированного моделирования:</p><ol><li><p>Объекты и классы:\\nОсновной элемент ООМ - это объекты и классы. Класс - это шаблон или чертеж для создания объектов, которые обладают определенными свойствами (полями) и поведением (методами). Объект - это экземпляр класса, который может принимать значения своих полей и выполнять методы.</p></li><li><p>Инкапсуляция:\\nИнкапсуляция означает скрытие внутренней реализации объектов и предоставление доступа только к необходимому функционалу через публичные методы. Это обеспечивает контролируемый доступ к данным и поведению объектов.</p></li><li><p>Наследование:\\nНаследование позволяет создавать новые классы на основе существующих, унаследовав их свойства и методы. Это позволяет создавать иерархии классов, что способствует повторному использованию кода и структурированию системы.</p></li><li><p>Полиморфизм:\\nПолиморфизм позволяет объектам одного класса проявлять различное поведение на основе контекста. Это может быть реализовано через перегрузку методов, интерфейсы и виртуальные методы.</p></li><li><p>Абстракция:\\nАбстракция позволяет выделять сущности и функциональность системы, которые имеют значение в контексте анализа и проектирования, игнорируя детали реализации. Абстракция помогает создавать более понятные и удобные модели системы.</p></li></ol><p>Преимущества использования объектно-ориентированного моделирования включают повышение читаемости, поддерживаемости и расширяемости кода, а также облегчение сопровождения и масштабирования проектов. ООМ также способствует повторному использованию кода и упрощению процесса разработки. Этот подход широко применяется в современной разработке программного обеспечения и считается одним из важных методов инженерии программного обеспечения.</p></div>"],["Case-технологии создания программного продукта.","<div class=\\"markdown prose w-full break-words dark:prose-invert light\\"><p>Case-технологии (Computer-Aided Software Engineering) - это инструменты и методы, которые предназначены для автоматизации различных этапов процесса разработки программного обеспечения. Они помогают программистам и инженерам улучшить производительность, качество и эффективность разработки программного продукта.</p><p>Вот некоторые основные характеристики и применение Case-технологий:</p><ol><li><p>Моделирование и анализ: Case-инструменты позволяют создавать графические модели для анализа требований, проектирования архитектуры и визуализации процессов разработки. Это помогает лучше понять структуру и взаимосвязи в системе.</p></li><li><p>Кодогенерация: Некоторые Case-технологии предоставляют возможность автоматически генерировать код на основе созданных моделей, что позволяет существенно сократить время разработки и снизить вероятность ошибок.</p></li><li><p>Управление требованиями: Case-системы позволяют эффективно управлять требованиями, их изменениями и версиями, что упрощает процесс коммуникации с заказчиками.</p></li><li><p>Управление конфигурацией: Case-технологии также поддерживают управление конфигурацией, что позволяет контролировать изменения в исходном коде и других артефактах проекта.</p></li><li><p>Тестирование: Некоторые Case-инструменты обеспечивают поддержку автоматизации тестирования, что упрощает создание тестовых сценариев и улучшает качество тестирования.</p></li><li><p>Управление проектом: Case-технологии также предоставляют функциональности для управления проектом, включая планирование, распределение задач, контроль прогресса и оценку рисков.</p></li></ol><p>Применение Case-технологий в разработке программного обеспечения улучшает производительность команды разработчиков, облегчает совместную работу и позволяет сосредоточиться на более творческих и аналитических задачах, а также снизить вероятность ошибок. Однако следует отметить, что Case-технологии не заменяют умения и опыт разработчиков, а лишь являются поддерживающими инструментами для оптимизации процесса создания программного продукта.</p></div>"]],"Дискретная математика":[["Определение понятия множества. Способы задания множества. Конечные и бесконечные множества. Пустое множество. Равенство множеств.","<div class=\\"markdown prose w-full break-words dark:prose-invert light\\"><p>Множество - это математический объект, который представляет собой совокупность различных элементов, объединенных общим свойством или характеристикой. Элементы множества могут быть числами, буквами, объектами или другими объектами.</p><p>Способы задания множества:</p><ol><li><p>Перечисление элементов: Множество может быть задано перечислением всех его элементов в фигурных скобках. Например, множество натуральных чисел до 5: {1, 2, 3, 4, 5}.</p></li><li><p>Описание свойств: Множество может быть определено через описание свойств его элементов. Например, множество простых чисел: {x | x - простое число}.</p></li><li><p>Диапазон значений: В числовых множествах можно задать диапазон значений. Например, множество натуральных чисел до 10: {x | x ∈ N, 1 ≤ x ≤ 10}.</p></li></ol><p>Конечное множество - это множество, содержащее определенное количество элементов, которое может быть перечислено. Например, множество {1, 2, 3, 4, 5} является конечным.</p><p>Бесконечное множество - это множество, содержащее бесконечное количество элементов и его нельзя перечислить. Например, множество всех натуральных чисел {1, 2, 3, ...} является бесконечным.</p><p>Пустое множество (обозначается как ∅) - это множество, не содержащее ни одного элемента. Оно является частным случаем конечного множества.</p><p>Равенство множеств - это отношение между двумя множествами, когда они содержат одни и те же элементы. Множества A и B равны, если для всех элементов x выполняется условие: x ∈ A тогда и только тогда, когда x ∈ B. Обозначается как A = B.</p></div>"],["Понятие подмножества. Количество k–элементных подмножеств множества из n элементов.","<div class=\\"markdown prose w-full break-words dark:prose-invert light\\"><p>Подмножество - это множество, элементы которого являются частью другого множества. Формально, множество A является подмножеством множества B (обозначается как A ⊆ B), если каждый элемент A также присутствует в B.</p><p>Количество k-элементных подмножеств множества из n элементов можно вычислить с помощью сочетаний. Комбинаторно, число k-элементных подмножеств (комбинаций) из множества из n элементов вычисляется по формуле сочетаний:</p><p>C(n, k) = n! / (k! * (n-k)!)</p><p>Где:\\nn - общее количество элементов в множестве,\\nk - количество элементов в подмножестве,\\n! - обозначает факториал.</p><p>Формула сочетаний позволяет определить количество различных комбинаций, которые можно сформировать, выбирая k элементов из множества из n элементов без повторений и без учета порядка.</p><p>Например, если у нас есть множество из 5 элементов {a, b, c, d, e}, и мы хотим найти количество 3-элементных подмножеств, мы можем использовать формулу сочетаний:</p><p>C(5, 3) = 5! / (3! * (5-3)!) = 10</p><p>Таким образом, в данном случае у нас будет 10 различных 3-элементных подмножеств для данного множества. Это подмножества: {a, b, c}, {a, b, d}, {a, b, e}, {a, c, d}, {a, c, e}, {a, d, e}, {b, c, d}, {b, c, e}, {b, d, e}, {c, d, e}.</p></div>"],["Операции над множествами. Универсальное множество. Дополнение множества. Диаграмма Эйлера-Венна.","<div class=\\"markdown prose w-full break-words dark:prose-invert light\\"><p>Операции над множествами - это действия, которые позволяют создавать новые множества на основе данных исходных множеств. Основные операции над множествами включают:</p><ol><li><p>Объединение (обозначается как ∪): Объединение двух множеств A и B - это множество, которое содержит все элементы из обоих множеств. Формально, A ∪ B = {x | x ∈ A или x ∈ B}.</p></li><li><p>Пересечение (обозначается как ∩): Пересечение двух множеств A и B - это множество, которое содержит только те элементы, которые принадлежат обоим множествам. Формально, A ∩ B = {x | x ∈ A и x ∈ B}.</p></li><li><p>Разность (обозначается как \\\\ или -): Разность двух множеств A и B - это множество, которое содержит все элементы из A, но не содержит элементы из B. Формально, A \\\\ B = {x | x ∈ A и x ∉ B}.</p></li><li><p>Дополнение (обозначается как \' или с чертой сверху): Дополнение множества A - это множество, которое содержит все элементы универсального множества U, но не содержит элементы из A. Формально, A\' = {x | x ∈ U и x ∉ A}.</p></li></ol><p>Универсальное множество - это множество, которое содержит все возможные элементы, используемые в рассматриваемой задаче или контексте. Обозначается как U.</p><p>Диаграмма Эйлера-Венна - это графическое представление множеств и их операций с использованием пересекающихся кругов. Каждый круг представляет множество, а область пересечения кругов показывает результат операции между множествами.</p><p>Например, если у нас есть множества A = {1, 2, 3} и B = {3, 4, 5}, то их объединение (A ∪ B) будет {1, 2, 3, 4, 5}, пересечение (A ∩ B) будет {3}, а разность (A \\\\ B) будет {1, 2}.</p><p>Диаграмма Эйлера-Венна покажет эти операции следующим образом:</p><pre><div class=\\"bg-black rounded-md mb-4\\"><div class=\\"flex items-center relative text-gray-200 bg-gray-800 px-4 py-2 text-xs font-sans justify-between rounded-t-md\\"><span>css</span><button class=\\"flex ml-auto gap-2\\"><svg stroke=\\"currentColor\\" fill=\\"none\\" stroke-width=\\"2\\" viewBox=\\"0 0 24 24\\" stroke-linecap=\\"round\\" stroke-linejoin=\\"round\\" class=\\"h-4 w-4\\" height=\\"1em\\" width=\\"1em\\" xmlns=\\"http://www.w3.org/2000/svg\\"><path d=\\"M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2\\"></path><rect x=\\"8\\" y=\\"2\\" width=\\"8\\" height=\\"4\\" rx=\\"1\\" ry=\\"1\\"></rect></svg>Copy code</button></div><div class=\\"p-4 overflow-y-auto\\"><code class=\\"!whitespace-pre hljs language-css\\">   <span class=\\"hljs-selector-tag\\">A</span>              <span class=\\"hljs-selector-tag\\">B</span>\\n  ┌───┐        ┌───┐\\n  │ <span class=\\"hljs-number\\">1</span> │        │ <span class=\\"hljs-number\\">3</span> │\\n  ├───┤        ├───┤\\n  │ <span class=\\"hljs-number\\">2</span> │        │ <span class=\\"hljs-number\\">4</span> │\\n  ├───┤        ├───┤\\n  │ <span class=\\"hljs-number\\">3</span> │        │ <span class=\\"hljs-number\\">5</span> │\\n  └───┘        └───┘\\n\\n   <span class=\\"hljs-selector-tag\\">A</span> ∪ <span class=\\"hljs-selector-tag\\">B</span>              <span class=\\"hljs-selector-tag\\">A</span> ∩ <span class=\\"hljs-selector-tag\\">B</span>            <span class=\\"hljs-selector-tag\\">A</span> \\\\ <span class=\\"hljs-selector-tag\\">B</span>\\n  ┌───────┐        ┌───┐        ┌───────┐\\n  │   <span class=\\"hljs-number\\">1</span>   │        │ <span class=\\"hljs-number\\">3</span> │        │   <span class=\\"hljs-number\\">1</span>   │\\n  ├───────┤        ├───┤        ├───────┤\\n  │   <span class=\\"hljs-number\\">2</span>   │        │   │        │   <span class=\\"hljs-number\\">2</span>   │\\n  ├───────┤        ├───────┤    ├───────┤\\n  │   <span class=\\"hljs-number\\">3</span>   │        │   <span class=\\"hljs-number\\">3</span>   │    │       │\\n  ├───────┤        ├───────┤    ├───────┤\\n  │   <span class=\\"hljs-number\\">4</span>   │        │       │    │       │\\n  ├───────┤        ├───────┤    ├───────┤\\n  │   <span class=\\"hljs-number\\">5</span>   │        │       │    │       │\\n  └───────┘        └───────┘    └───────┘\\n</code></div></div></pre><p>Таким образом, диаграмма Эйлера-Венна помогает визуализировать результаты операций над множеств</p></div>"],["Прямое (декартово) произведение множеств. Определение, формула.","<div class=\\"markdown prose w-full break-words dark:prose-invert light\\"><p>Прямое (декартово) произведение множеств - это операция, которая позволяет объединить все возможные упорядоченные пары элементов из двух множеств. Если у нас есть два множества A и B, то прямое произведение обозначается как A × B и представляет собой новое множество, состоящее из всех упорядоченных пар (a, b), где a ∈ A и b ∈ B.</p><p>Формально, прямое произведение множеств A и B определяется следующим образом:</p><p>A × B = {(a, b) | a ∈ A и b ∈ B}</p><p>Здесь (a, b) - упорядоченная пара, где a является элементом из множества A, а b - элементом из множества B.</p><p>Например, если у нас есть два множества A = {1, 2} и B = {3, 4}, то их прямое произведение A × B будет следующим:</p><p>A × B = {(1, 3), (1, 4), (2, 3), (2, 4)}</p><p>Таким образом, прямое произведение множеств позволяет создать новое множество из всех возможных упорядоченных пар элементов из исходных множеств. Количество элементов в прямом произведении равно произведению количества элементов в каждом из исходных множеств. В примере выше, у нас было 2 элемента в множестве A и 2 элемента в множестве B, что дало нам 2 * 2 = 4 упорядоченных пар в прямом произведении.</p></div>"],["Упорядоченное множество, определение, число упорядоченных множеств и Теоретико-множественное определение функции алгебры логики (ФАЛ).","<div class=\\"markdown prose w-full break-words dark:prose-invert light\\"><ol><li><p>Упорядоченное множество - это множество, в котором определено отношение \\"меньше или равно\\" (≤), которое устанавливает частичный порядок на элементах множества. В упорядоченном множестве каждая пара элементов сравнивается по отношению ≤, и каждый элемент может быть сравним только с другими элементами.</p></li><li><p>Число упорядоченных множеств - количество упорядоченных множеств зависит от количества элементов в множестве и типа упорядочивания. Для конечных множеств число упорядоченных множеств можно вычислить с помощью факториала. Например, для множества из n элементов число упорядоченных множеств будет n!.</p></li><li><p>Теоретико-множественное определение функции алгебры логики (ФАЛ) - Функция алгебры логики - это функция, которая принимает логические значения (истина или ложь) в качестве аргументов и возвращает логические значения в качестве результата. Функции алгебры логики могут быть определены на булевых множествах, где значения переменных и результаты функции ограничены значениями \\"истина\\" (1) или \\"ложь\\" (0).</p></li></ol><p>Например, рассмотрим ФАЛ AND (логическое умножение). Операция AND принимает два аргумента и возвращает \\"истина\\" только в том случае, когда оба аргумента равны \\"истина\\", иначе результат будет \\"ложь\\". Таким образом, функция AND может быть определена как:</p><p>AND(0, 0) = 0\\nAND(0, 1) = 0\\nAND(1, 0) = 0\\nAND(1, 1) = 1</p><p>Аналогично, для других логических функций, таких как OR (логическое сложение), NOT (логическое отрицание) и других, можно определить их значения на булевых множествах. Функции алгебры логики имеют важное применение в цифровой логике, математической логике и различных областях информатики.</p></div>"],["Элементарные двуместные булевы функции (при n=2), обозначения, таблицы истинности.","<div class=\\"markdown prose w-full break-words dark:prose-invert light\\"><p>Элементарные двуместные булевы функции при n=2 - это булевы функции, которые принимают два аргумента и возвращают логическое значение (истина или ложь). В данном случае, n=2, значит, у нас два булевых аргумента.</p><p>Существует четыре элементарные двуместные булевы функции, и каждая из них имеет своё обозначение и таблицу истинности:</p><ol><li>Конъюнкция (AND): Обозначается символом \\"∧\\" или \\"*\\", представляет логическое умножение.\\nТаблица истинности:</li></ol><pre><div class=\\"bg-black rounded-md mb-4\\"><div class=\\"flex items-center relative text-gray-200 bg-gray-800 px-4 py-2 text-xs font-sans justify-between rounded-t-md\\"><span>css</span><button class=\\"flex ml-auto gap-2\\"><svg stroke=\\"currentColor\\" fill=\\"none\\" stroke-width=\\"2\\" viewBox=\\"0 0 24 24\\" stroke-linecap=\\"round\\" stroke-linejoin=\\"round\\" class=\\"h-4 w-4\\" height=\\"1em\\" width=\\"1em\\" xmlns=\\"http://www.w3.org/2000/svg\\"><path d=\\"M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2\\"></path><rect x=\\"8\\" y=\\"2\\" width=\\"8\\" height=\\"4\\" rx=\\"1\\" ry=\\"1\\"></rect></svg>Copy code</button></div><div class=\\"p-4 overflow-y-auto\\"><code class=\\"!whitespace-pre hljs language-css\\"><span class=\\"hljs-selector-tag\\">A</span>  <span class=\\"hljs-selector-tag\\">B</span>  <span class=\\"hljs-selector-tag\\">A</span> ∧ <span class=\\"hljs-selector-tag\\">B</span>\\n<span class=\\"hljs-number\\">0</span>  <span class=\\"hljs-number\\">0</span>   <span class=\\"hljs-number\\">0</span>\\n<span class=\\"hljs-number\\">0</span>  <span class=\\"hljs-number\\">1</span>   <span class=\\"hljs-number\\">0</span>\\n<span class=\\"hljs-number\\">1</span>  <span class=\\"hljs-number\\">0</span>   <span class=\\"hljs-number\\">0</span>\\n<span class=\\"hljs-number\\">1</span>  <span class=\\"hljs-number\\">1</span>   <span class=\\"hljs-number\\">1</span>\\n</code></div></div></pre><ol start=\\"2\\"><li>Дизъюнкция (OR): Обозначается символом \\"∨\\" или \\"+\\", представляет логическое сложение.\\nТаблица истинности:</li></ol><pre><div class=\\"bg-black rounded-md mb-4\\"><div class=\\"flex items-center relative text-gray-200 bg-gray-800 px-4 py-2 text-xs font-sans justify-between rounded-t-md\\"><span>css</span><button class=\\"flex ml-auto gap-2\\"><svg stroke=\\"currentColor\\" fill=\\"none\\" stroke-width=\\"2\\" viewBox=\\"0 0 24 24\\" stroke-linecap=\\"round\\" stroke-linejoin=\\"round\\" class=\\"h-4 w-4\\" height=\\"1em\\" width=\\"1em\\" xmlns=\\"http://www.w3.org/2000/svg\\"><path d=\\"M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2\\"></path><rect x=\\"8\\" y=\\"2\\" width=\\"8\\" height=\\"4\\" rx=\\"1\\" ry=\\"1\\"></rect></svg>Copy code</button></div><div class=\\"p-4 overflow-y-auto\\"><code class=\\"!whitespace-pre hljs language-css\\"><span class=\\"hljs-selector-tag\\">A</span>  <span class=\\"hljs-selector-tag\\">B</span>  <span class=\\"hljs-selector-tag\\">A</span> ∨ <span class=\\"hljs-selector-tag\\">B</span>\\n<span class=\\"hljs-number\\">0</span>  <span class=\\"hljs-number\\">0</span>   <span class=\\"hljs-number\\">0</span>\\n<span class=\\"hljs-number\\">0</span>  <span class=\\"hljs-number\\">1</span>   <span class=\\"hljs-number\\">1</span>\\n<span class=\\"hljs-number\\">1</span>  <span class=\\"hljs-number\\">0</span>   <span class=\\"hljs-number\\">1</span>\\n<span class=\\"hljs-number\\">1</span>  <span class=\\"hljs-number\\">1</span>   <span class=\\"hljs-number\\">1</span>\\n</code></div></div></pre><ol start=\\"3\\"><li>Исключающее ИЛИ (XOR): Обозначается символом \\"⊕\\", представляет исключающее логическое сложение.\\nТаблица истинности:</li></ol><pre><div class=\\"bg-black rounded-md mb-4\\"><div class=\\"flex items-center relative text-gray-200 bg-gray-800 px-4 py-2 text-xs font-sans justify-between rounded-t-md\\"><span>css</span><button class=\\"flex ml-auto gap-2\\"><svg stroke=\\"currentColor\\" fill=\\"none\\" stroke-width=\\"2\\" viewBox=\\"0 0 24 24\\" stroke-linecap=\\"round\\" stroke-linejoin=\\"round\\" class=\\"h-4 w-4\\" height=\\"1em\\" width=\\"1em\\" xmlns=\\"http://www.w3.org/2000/svg\\"><path d=\\"M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2\\"></path><rect x=\\"8\\" y=\\"2\\" width=\\"8\\" height=\\"4\\" rx=\\"1\\" ry=\\"1\\"></rect></svg>Copy code</button></div><div class=\\"p-4 overflow-y-auto\\"><code class=\\"!whitespace-pre hljs language-css\\"><span class=\\"hljs-selector-tag\\">A</span>  <span class=\\"hljs-selector-tag\\">B</span>  <span class=\\"hljs-selector-tag\\">A</span> ⊕ <span class=\\"hljs-selector-tag\\">B</span>\\n<span class=\\"hljs-number\\">0</span>  <span class=\\"hljs-number\\">0</span>   <span class=\\"hljs-number\\">0</span>\\n<span class=\\"hljs-number\\">0</span>  <span class=\\"hljs-number\\">1</span>   <span class=\\"hljs-number\\">1</span>\\n<span class=\\"hljs-number\\">1</span>  <span class=\\"hljs-number\\">0</span>   <span class=\\"hljs-number\\">1</span>\\n<span class=\\"hljs-number\\">1</span>  <span class=\\"hljs-number\\">1</span>   <span class=\\"hljs-number\\">0</span>\\n</code></div></div></pre><ol start=\\"4\\"><li>Импликация (→): Обозначается символом \\"→\\", представляет логическую импликацию (следование).\\nТаблица истинности:</li></ol><pre><div class=\\"bg-black rounded-md mb-4\\"><div class=\\"flex items-center relative text-gray-200 bg-gray-800 px-4 py-2 text-xs font-sans justify-between rounded-t-md\\"><span>css</span><button class=\\"flex ml-auto gap-2\\"><svg stroke=\\"currentColor\\" fill=\\"none\\" stroke-width=\\"2\\" viewBox=\\"0 0 24 24\\" stroke-linecap=\\"round\\" stroke-linejoin=\\"round\\" class=\\"h-4 w-4\\" height=\\"1em\\" width=\\"1em\\" xmlns=\\"http://www.w3.org/2000/svg\\"><path d=\\"M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2\\"></path><rect x=\\"8\\" y=\\"2\\" width=\\"8\\" height=\\"4\\" rx=\\"1\\" ry=\\"1\\"></rect></svg>Copy code</button></div><div class=\\"p-4 overflow-y-auto\\"><code class=\\"!whitespace-pre hljs language-css\\"><span class=\\"hljs-selector-tag\\">A</span>  <span class=\\"hljs-selector-tag\\">B</span>  <span class=\\"hljs-selector-tag\\">A</span> → <span class=\\"hljs-selector-tag\\">B</span>\\n<span class=\\"hljs-number\\">0</span>  <span class=\\"hljs-number\\">0</span>   <span class=\\"hljs-number\\">1</span>\\n<span class=\\"hljs-number\\">0</span>  <span class=\\"hljs-number\\">1</span>   <span class=\\"hljs-number\\">1</span>\\n<span class=\\"hljs-number\\">1</span>  <span class=\\"hljs-number\\">0</span>   <span class=\\"hljs-number\\">0</span>\\n<span class=\\"hljs-number\\">1</span>  <span class=\\"hljs-number\\">1</span>   <span class=\\"hljs-number\\">1</span>\\n</code></div></div></pre><p>Эти элементарные двуместные булевы функции образуют основу для построения более сложных функций и используются в цифровой логике, математической логике, программировании и других областях информатики. Они играют важную роль в построении и анализе логических выражений и операций.</p></div>"],["Основные законы булевой алгебры.","<div class=\\"markdown prose w-full break-words dark:prose-invert light\\"><p>Основные законы булевой алгебры - это набор правил и тождеств, которые применяются к булевым функциям. Законы булевой алгебры играют важную роль в упрощении и анализе логических выражений. Вот основные законы булевой алгебры:</p><ol><li><p>Законы идемпотентности:</p><ul><li>A ∨ A = A (Идемпотентность дизъюнкции)</li><li>A ∧ A = A (Идемпотентность конъюнкции)</li></ul></li><li><p>Законы ассоциативности:</p><ul><li>(A ∨ B) ∨ C = A ∨ (B ∨ C) (Ассоциативность дизъюнкции)</li><li>(A ∧ B) ∧ C = A ∧ (B ∧ C) (Ассоциативность конъюнкции)</li></ul></li><li><p>Законы коммутативности:</p><ul><li>A ∨ B = B ∨ A (Коммутативность дизъюнкции)</li><li>A ∧ B = B ∧ A (Коммутативность конъюнкции)</li></ul></li><li><p>Законы дистрибутивности:</p><ul><li>A ∨ (B ∧ C) = (A ∨ B) ∧ (A ∨ C) (Дистрибутивность дизъюнкции относительно конъюнкции)</li><li>A ∧ (B ∨ C) = (A ∧ B) ∨ (A ∧ C) (Дистрибутивность конъюнкции относительно дизъюнкции)</li></ul></li><li><p>Закон поглощения:</p><ul><li>A ∨ (A ∧ B) = A (Закон поглощения дизъюнкции)</li><li>A ∧ (A ∨ B) = A (Закон поглощения конъюнкции)</li></ul></li><li><p>Закон отрицания:</p><ul><li>A ∨ ¬A = 1 (Закон исключения третьего)</li><li>A ∧ ¬A = 0 (Закон противоречия)</li></ul></li><li><p>Законы единицы и нуля:</p><ul><li>A ∨ 0 = A (Единичный элемент дизъюнкции)</li><li>A ∧ 1 = A (Единичный элемент конъюнкции)</li><li>A ∨ 1 = 1 (Нулевой элемент дизъюнкции)</li><li>A ∧ 0 = 0 (Нулевой элемент конъюнкции)</li></ul></li></ol><p>Эти законы позволяют упрощать логические выражения, преобразовывать их и находить равносильные выражения. Они являются основой для работы с булевыми функциями в цифровой логике, программировании и других областях, где логические операции широко используются для анализа и управления информацией.</p></div>"],["Понятие функционально-полной системы элементарных функций. Теорема Поста – Яблонского. Понятие базиса.","<div class=\\"markdown prose w-full break-words dark:prose-invert light\\"><p>Понятие функционально-полной системы элементарных функций:</p><p>Функционально-полная система элементарных функций (или просто функционально-полная система) - это система булевых функций, которая обладает свойством, что любую другую булеву функцию можно выразить с помощью комбинаций (композиций) функций из этой системы. Другими словами, система функций считается функционально-полной, если с её помощью можно получить все возможные булевы функции.</p><p>Теорема Поста-Яблонского:</p><p>Теорема Поста-Яблонского устанавливает необходимое и достаточное условие для функциональной полноты системы булевых функций. Теорема утверждает, что система функций является функционально-полной тогда и только тогда, когда она не содержит ни одной из следующих трёх функций: константную 0 (отрицание), константную 1 (тождество) и операцию конъюнкции (логическое И).</p><p>Понятие базиса:</p><p>В контексте функционально-полных систем элементарных функций, базис - это минимальный набор функций, который обладает свойствами функциональной полноты. То есть это такая система функций, которая образует функционально-полную систему, и не содержит лишних функций. Если какая-то функция исключается из базиса, система перестает быть функционально-полной, а если добавляется лишняя функция, то система становится избыточной.</p><p>Например, система функций {И, ИЛИ} является базисом, так как с помощью этих функций можно выразить все булевы функции. А система функций {И, НЕ} также является базисом, так как можно выразить отсутствующую функцию ИЛИ через другие функции.</p><p>Таким образом, понятие функционально-полной системы элементарных функций и теорема Поста-Яблонского позволяют определить, какие наборы функций обладают свойством функциональной полноты, и каким образом можно выражать любую другую функцию с помощью данного базиса.</p></div>"],["Базисы Буля, Шеффера, Пирса, Жегалкина.","<div class=\\"markdown prose w-full break-words dark:prose-invert light\\"><p>Базисы Буля, Шеффера, Пирса и Жегалкина - это четыре различных набора булевых функций, которые образуют функционально-полные системы, то есть с помощью них можно выразить любую другую булевую функцию. Давайте рассмотрим каждый из них:</p><ol><li><p>Базис Буля:\\nБазис Буля состоит из двух элементарных булевых функций: {И (логическое И), НЕ (логическое отрицание)}. Это один из самых простых базисов, так как он содержит всего две функции, которые легко комбинировать для построения любой другой булевой функции.</p></li><li><p>Базис Шеффера:\\nБазис Шеффера состоит всего из одной функции: {НЕХ (логическое НЕ-ИЛИ, также известное как стрелка Пирса)}. Функция Шеффера обладает следующим свойством: любая булева функция может быть выражена через функцию Шеффера. Это достаточно удивительное свойство одной функции.</p></li><li><p>Базис Пирса:\\nБазис Пирса состоит из одной функции: {НЕИ (логическое НЕ-И)}. Функция Пирса обладает аналогичным свойством, как и функция Шеффера: любая булева функция может быть выражена через функцию Пирса.</p></li><li><p>Базис Жегалкина:\\nБазис Жегалкина (также известный как полиномиальный базис) состоит из всех одночленов над булевыми переменными и операции сложения (исключающего ИЛИ). Это означает, что все одночлены вида x1 * x2 * ... * xn, где xi - это булева переменная, и операция сложения, которая соответствует операции исключающего ИЛИ, образуют функционально-полную систему.</p></li></ol><p>Эти базисы имеют важное значение в цифровой логике и теории алгоритмов, так как они демонстрируют, каким образом можно использовать ограниченное количество функций для построения любой другой булевой функции. Это позволяет разрабатывать компактные и эффективные схемы для выполнения логических операций в цифровых системах.</p></div>"],["Основные определения и способы задания. Определение графа. Ориентированные и неориентированные графы. Понятие мультиграфа, подграфа, дополнения, смежности, инцидентности","<div class=\\"markdown prose w-full break-words dark:prose-invert light\\"><p>Определение графа:</p><p>Граф - это абстрактная структура данных, которая состоит из двух основных элементов: множества вершин (или узлов) и множества рёбер (или связей). Граф представляет собой совокупность объектов (вершин), связанных отношениями (рёбрами). Графы широко используются для моделирования и представления различных сетей, систем и взаимосвязей в различных областях, таких как компьютерные сети, социальные сети, транспортные маршруты и т.д.</p><p>Ориентированные и неориентированные графы:</p><ol><li><p>Неориентированный граф: В неориентированном графе каждое ребро представляет собой неупорядоченную пару вершин. Это означает, что связь между двумя вершинами является взаимной и не имеет направления. В неориентированных графах рёбра представляют просто связи между вершинами, без учёта направления.</p></li><li><p>Ориентированный граф: В ориентированном графе каждое ребро имеет направление и представляет собой упорядоченную пару вершин. Это означает, что связь между двумя вершинами имеет определённое направление от одной вершины к другой.</p></li></ol><p>Понятие мультиграфа:</p><p>Мультиграф - это граф, который может содержать несколько рёбер, соединяющих одни и те же вершины. В обычных графах между двумя вершинами может быть только одно ребро, но в мультиграфе между ними может быть несколько параллельных рёбер.</p><p>Понятие подграфа:</p><p>Подграф - это граф, который является частью другого графа. Если у нас есть граф G с множеством вершин V и множеством рёбер E, и некоторое подмножество вершин V\' ⊆ V и подмножество рёбер E\' ⊆ E, то G\' = (V\', E\') называется подграфом графа G.</p><p>Понятие дополнения:</p><p>Дополнение графа - это граф, который содержит те же вершины, что и исходный граф, но все отсутствующие в исходном графе рёбра включаются в дополнение, и наоборот. Таким образом, если у исходного графа есть ребро между двумя вершинами, то в дополнении это ребро отсутствует, и наоборот.</p><p>Понятие смежности:</p><p>В графе вершины называются смежными (или соседними), если они соединены ребром. В ориентированном графе смежность означает, что ребро исходит из одной вершины и входит в другую. В неориентированном графе смежность означает, что ребро связывает две вершины без учёта направления.</p><p>Понятие инцидентности:</p><p>Ребро называется инцидентным вершине, если оно связывает данную вершину с другой вершиной. В ориентированных графах инцидентность имеет направление (ребро направлено от одной вершины к другой). В неориентированных графах ребро инцидентно двум вершинам, связывая их друг с другом.</p></div>"],["Структурные характеристики графов. Дать определение понятиям: цепь, цикл, путь, контур графа, длина пути. Привести примеры. Симметричные и ассиметричные графы.","<div class=\\"markdown prose w-full break-words dark:prose-invert light\\"><p>Структурные характеристики графов:</p><ol><li>Цепь:\\nЦепь в графе - это последовательность рёбер и вершин, такая что каждое ребро соединяет две соседние вершины в последовательности. В цепи все вершины могут быть различными, а рёбра могут повторяться. Цепь может быть как простой (каждое ребро встречается не более одного раза), так и не простой (когда рёбра повторяются).</li></ol><p>Пример цепи: В неориентированном графе цепь может быть представлена, например, как последовательность вершин A - B - C - D, соединённых рёбрами.</p><ol start=\\"2\\"><li>Цикл:\\nЦикл (или замкнутая цепь) - это цепь, в которой первая и последняя вершины совпадают. То есть цикл образует замкнутую петлю.</li></ol><p>Пример цикла: В неориентированном графе цикл может быть представлен, например, как последовательность вершин A - B - C - D - A, соединённых рёбрами.</p><ol start=\\"3\\"><li>Путь:\\nПуть в графе - это последовательность рёбер и вершин, такая что каждое ребро соединяет две соседние вершины в последовательности, и все вершины пути различны. Путь может быть простым или не простым.</li></ol><p>Пример пути: В неориентированном графе путь может быть представлен, например, как последовательность вершин A - B - C, соединённых рёбрами.</p><ol start=\\"4\\"><li>Контур графа:\\nКонтур (или цикл) графа - это замкнутый путь, в котором все вершины различны, кроме первой и последней вершин, которые совпадают.</li></ol><p>Пример контура: В неориентированном графе контур может быть представлен, например, как последовательность вершин A - B - C - D - A, соединённых рёбрами.</p><ol start=\\"5\\"><li>Длина пути:\\nДлина пути в графе - это количество рёбер в пути, т.е. число связанных рёбер, которые приводят от одной вершины к другой.</li></ol><p>Пример длины пути: В неориентированном графе длина пути между вершинами A и C равна 2, если существует путь A - B - C.</p><p>Симметричные и асимметричные графы:</p><ol><li><p>Симметричный граф:\\nСимметричный граф - это неориентированный граф, в котором для каждого ребра (u, v) существует также ребро (v, u). Таким образом, связь между вершинами в симметричном графе двусторонняя и не зависит от направления.</p></li><li><p>Асимметричный граф:\\nАсимметричный граф - это ориентированный граф, в котором для каждого ребра (u, v) не существует ребра (v, u). В асимметричном графе связь между вершинами зависит от направления, и ребра имеют строго определённое направление.</p></li></ol><p>Примеры:</p><ul><li>Неориентированный симметричный граф: граф дружбы в социальной сети, где связи между пользователями взаимные.</li><li>Ориентированный асимметричный граф: граф направлений движения транспортных маршрутов, где направление движения одностороннее.</li></ul></div>"],["Матричное представление графов. Четыре вида матриц. Привести пример.","<div class=\\"markdown prose w-full break-words dark:prose-invert light\\"><p>Матричное представление графов:</p><p>Графы можно представить с помощью матриц, что облегчает их анализ и обработку. Существуют четыре основных вида матриц для представления графов:</p><ol><li>Матрица смежности:\\nМатрица смежности представляет граф в виде квадратной матрицы, где строки и столбцы соответствуют вершинам графа, а элементы матрицы указывают наличие (или отсутствие) рёбер между вершинами. Если между вершинами i и j есть ребро, то элемент матрицы a[i][j] принимает значение 1, в противном случае - 0.</li></ol><p>Пример матрицы смежности для неориентированного графа с вершинами A, B, C и D:</p><pre><div class=\\"bg-black rounded-md mb-4\\"><div class=\\"flex items-center relative text-gray-200 bg-gray-800 px-4 py-2 text-xs font-sans justify-between rounded-t-md\\"><span>css</span><button class=\\"flex ml-auto gap-2\\"><svg stroke=\\"currentColor\\" fill=\\"none\\" stroke-width=\\"2\\" viewBox=\\"0 0 24 24\\" stroke-linecap=\\"round\\" stroke-linejoin=\\"round\\" class=\\"h-4 w-4\\" height=\\"1em\\" width=\\"1em\\" xmlns=\\"http://www.w3.org/2000/svg\\"><path d=\\"M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2\\"></path><rect x=\\"8\\" y=\\"2\\" width=\\"8\\" height=\\"4\\" rx=\\"1\\" ry=\\"1\\"></rect></svg>Copy code</button></div><div class=\\"p-4 overflow-y-auto\\"><code class=\\"!whitespace-pre hljs language-css\\">    <span class=\\"hljs-selector-tag\\">A</span>  <span class=\\"hljs-selector-tag\\">B</span>  C  D\\n<span class=\\"hljs-selector-tag\\">A</span>   <span class=\\"hljs-number\\">0</span>  <span class=\\"hljs-number\\">1</span>  <span class=\\"hljs-number\\">1</span>  <span class=\\"hljs-number\\">0</span>\\n<span class=\\"hljs-selector-tag\\">B</span>   <span class=\\"hljs-number\\">1</span>  <span class=\\"hljs-number\\">0</span>  <span class=\\"hljs-number\\">0</span>  <span class=\\"hljs-number\\">1</span>\\nC   <span class=\\"hljs-number\\">1</span>  <span class=\\"hljs-number\\">0</span>  <span class=\\"hljs-number\\">0</span>  <span class=\\"hljs-number\\">1</span>\\nD   <span class=\\"hljs-number\\">0</span>  <span class=\\"hljs-number\\">1</span>  <span class=\\"hljs-number\\">1</span>  <span class=\\"hljs-number\\">0</span>\\n</code></div></div></pre><ol start=\\"2\\"><li>Матрица инцидентности:\\nМатрица инцидентности представляет граф в виде матрицы, где строки соответствуют вершинам, а столбцы - рёбрам. Элементы матрицы указывают, инцидентна ли вершина ребру. Если вершина i инцидентна ребру j, то элемент матрицы a[i][j] принимает значение 1, в противном случае - 0.</li></ol><p>Пример матрицы инцидентности для неориентированного графа с вершинами A, B, C и рёбрами a, b, c:</p><pre><div class=\\"bg-black rounded-md mb-4\\"><div class=\\"flex items-center relative text-gray-200 bg-gray-800 px-4 py-2 text-xs font-sans justify-between rounded-t-md\\"><span>css</span><button class=\\"flex ml-auto gap-2\\"><svg stroke=\\"currentColor\\" fill=\\"none\\" stroke-width=\\"2\\" viewBox=\\"0 0 24 24\\" stroke-linecap=\\"round\\" stroke-linejoin=\\"round\\" class=\\"h-4 w-4\\" height=\\"1em\\" width=\\"1em\\" xmlns=\\"http://www.w3.org/2000/svg\\"><path d=\\"M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2\\"></path><rect x=\\"8\\" y=\\"2\\" width=\\"8\\" height=\\"4\\" rx=\\"1\\" ry=\\"1\\"></rect></svg>Copy code</button></div><div class=\\"p-4 overflow-y-auto\\"><code class=\\"!whitespace-pre hljs language-css\\">    <span class=\\"hljs-selector-tag\\">a</span>  <span class=\\"hljs-selector-tag\\">b</span>  c\\n<span class=\\"hljs-selector-tag\\">A</span>   <span class=\\"hljs-number\\">1</span>  <span class=\\"hljs-number\\">1</span>  <span class=\\"hljs-number\\">0</span>\\n<span class=\\"hljs-selector-tag\\">B</span>   <span class=\\"hljs-number\\">1</span>  <span class=\\"hljs-number\\">0</span>  <span class=\\"hljs-number\\">1</span>\\nC   <span class=\\"hljs-number\\">0</span>  <span class=\\"hljs-number\\">1</span>  <span class=\\"hljs-number\\">1</span>\\n</code></div></div></pre><ol start=\\"3\\"><li>Матрица достижимости:\\nМатрица достижимости представляет ориентированный граф в виде матрицы, где элементы a[i][j] равны 1, если существует путь от вершины i к вершине j, и 0 в противном случае.</li></ol><p>Пример матрицы достижимости для ориентированного графа с вершинами A, B, C и рёбрами (A, B), (B, C), (C, A):</p><pre><div class=\\"bg-black rounded-md mb-4\\"><div class=\\"flex items-center relative text-gray-200 bg-gray-800 px-4 py-2 text-xs font-sans justify-between rounded-t-md\\"><span>css</span><button class=\\"flex ml-auto gap-2\\"><svg stroke=\\"currentColor\\" fill=\\"none\\" stroke-width=\\"2\\" viewBox=\\"0 0 24 24\\" stroke-linecap=\\"round\\" stroke-linejoin=\\"round\\" class=\\"h-4 w-4\\" height=\\"1em\\" width=\\"1em\\" xmlns=\\"http://www.w3.org/2000/svg\\"><path d=\\"M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2\\"></path><rect x=\\"8\\" y=\\"2\\" width=\\"8\\" height=\\"4\\" rx=\\"1\\" ry=\\"1\\"></rect></svg>Copy code</button></div><div class=\\"p-4 overflow-y-auto\\"><code class=\\"!whitespace-pre hljs language-css\\">    <span class=\\"hljs-selector-tag\\">A</span>  <span class=\\"hljs-selector-tag\\">B</span>  C\\n<span class=\\"hljs-selector-tag\\">A</span>   <span class=\\"hljs-number\\">1</span>  <span class=\\"hljs-number\\">1</span>  <span class=\\"hljs-number\\">1</span>\\n<span class=\\"hljs-selector-tag\\">B</span>   <span class=\\"hljs-number\\">0</span>  <span class=\\"hljs-number\\">1</span>  <span class=\\"hljs-number\\">1</span>\\nC   <span class=\\"hljs-number\\">1</span>  <span class=\\"hljs-number\\">0</span>  <span class=\\"hljs-number\\">1</span>\\n</code></div></div></pre><ol start=\\"4\\"><li>Матрица весов:\\nМатрица весов используется взвешенных графах, где рёбрам присвоены числовые значения (веса). Элемент матрицы a[i][j] представляет вес ребра между вершинами i и j.</li></ol><p>Пример матрицы весов для взвешенного графа с вершинами A, B, C и рёбрами (A, B), (B, C), (C, A) с весами 2, 3 и 1 соответственно:</p><pre><div class=\\"bg-black rounded-md mb-4\\"><div class=\\"flex items-center relative text-gray-200 bg-gray-800 px-4 py-2 text-xs font-sans justify-between rounded-t-md\\"><span>css</span><button class=\\"flex ml-auto gap-2\\"><svg stroke=\\"currentColor\\" fill=\\"none\\" stroke-width=\\"2\\" viewBox=\\"0 0 24 24\\" stroke-linecap=\\"round\\" stroke-linejoin=\\"round\\" class=\\"h-4 w-4\\" height=\\"1em\\" width=\\"1em\\" xmlns=\\"http://www.w3.org/2000/svg\\"><path d=\\"M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2\\"></path><rect x=\\"8\\" y=\\"2\\" width=\\"8\\" height=\\"4\\" rx=\\"1\\" ry=\\"1\\"></rect></svg>Copy code</button></div><div class=\\"p-4 overflow-y-auto\\"><code class=\\"!whitespace-pre hljs language-css\\">    <span class=\\"hljs-selector-tag\\">A</span>  <span class=\\"hljs-selector-tag\\">B</span>  C\\n<span class=\\"hljs-selector-tag\\">A</span>   <span class=\\"hljs-number\\">0</span>  <span class=\\"hljs-number\\">2</span>  <span class=\\"hljs-number\\">1</span>\\n<span class=\\"hljs-selector-tag\\">B</span>   <span class=\\"hljs-number\\">0</span>  <span class=\\"hljs-number\\">0</span>  <span class=\\"hljs-number\\">3</span>\\nC   <span class=\\"hljs-number\\">0</span>  <span class=\\"hljs-number\\">0</span>  <span class=\\"hljs-number\\">0</span>\\n</code></div></div></pre><p>Эти матрицы предоставляют различные способы представления графов и позволяют выполнять различные операции с графами, такие как поиск путей, определение связности, и т.д.</p></div>"],["Задача определения путей и кратчайших путей на графах. Алгоритмы решения задачи.","<div class=\\"markdown prose w-full break-words dark:prose-invert light\\"><p>Задача определения путей и кратчайших путей на графах:</p><p>Одной из важных задач в анализе графов является определение путей между вершинами и поиск кратчайших путей - путей с минимальной суммой весов рёбер. Эти задачи имеют много применений, например, в построении маршрутов в сетях, обработке данных и оптимизации.</p><p>Алгоритмы решения задачи:</p><ol><li>Поиск путей:</li></ol><ul><li><p>Глубина-первый поиск (Depth-First Search, DFS): Этот алгоритм начинает с одной из вершин и исследует как можно дальше по каждому ребру, пока не достигнет конечной вершины или не вернется к уже посещенной вершине. DFS обходит все возможные пути до тех пор, пока не будет найден путь между начальной и конечной вершинами.</p></li><li><p>Ширина-первый поиск (Breadth-First Search, BFS): В отличие от DFS, этот алгоритм исследует все соседние вершины перед тем, как переходить к следующей уровню графа. BFS находит кратчайший путь между вершинами, так как он исследует ближайшие вершины перед тем, как исследовать более удаленные.</p></li></ul><ol start=\\"2\\"><li>Поиск кратчайших путей:</li></ol><ul><li><p>Алгоритм Дейкстры (Dijkstra\'s algorithm): Этот алгоритм находит кратчайшие пути от одной из вершин графа до всех остальных вершин. Алгоритм Дейкстры работает с неотрицательными весами рёбер. Начиная с начальной вершины, он находит кратчайшие расстояния до всех других вершин, постепенно просматривая ближайшие вершины.</p></li><li><p>Алгоритм Флойда-Уоршелла (Floyd-Warshall algorithm): Этот алгоритм находит кратчайшие пути между всеми парами вершин в ориентированном или неориентированном графе, даже если рёбра могут иметь отрицательные веса (но не должны образовывать циклы отрицательного веса). Алгоритм Флойда-Уоршелла применяется для поиска кратчайших путей в плотных графах.</p></li></ul><p>Эти алгоритмы позволяют находить пути и кратчайшие пути в графах различных типов, что делает их важным инструментом в анализе и оптимизации различных систем и процессов, основанных на графовой структуре данных.</p></div>"],["Алгоритм Дейкстры.","<div class=\\"markdown prose w-full break-words dark:prose-invert light\\"><p>Алгоритм Дейкстры - это алгоритм поиска кратчайшего пути от одной вершины графа до всех остальных вершин с неотрицательными весами рёбер. Он является одним из наиболее распространенных алгоритмов для решения задачи нахождения кратчайшего пути в графе.</p><p>Шаги алгоритма Дейкстры:</p><ol><li><p>Инициализация: Задать начальную вершину, для которой ищется кратчайший путь. Установить расстояние от начальной вершины до неё же равным 0, а все остальные расстояния до других вершин равны бесконечности.</p></li><li><p>Выбор ближайшей вершины: Выбрать вершину с минимальным расстоянием из множества вершин, для которых еще не найден кратчайший путь.</p></li><li><p>Релаксация: Для выбранной вершины пересчитать расстояние до соседних вершин. Если новое расстояние меньше текущего, то обновить его.</p></li><li><p>Повторение шагов 2 и 3: Повторять шаги 2 и 3 для всех оставшихся вершин, пока не будут найдены кратчайшие пути до всех вершин.</p></li></ol><p>Алгоритм Дейкстры гарантирует нахождение кратчайших путей в графе с неотрицательными весами. Однако он может работать неэффективно в графах с большим количеством рёбер и вершин, особенно в плотных графах. В таких случаях могут использоваться более оптимизированные алгоритмы, такие как алгоритм Флойда-Уоршелла или алгоритмы на основе структур данных \\"куча\\" (heap), например, алгоритм Дейкстры с использованием кучи (Dijkstra\'s algorithm with heap).</p><p>Пример работы алгоритма Дейкстры:</p><p>Рассмотрим следующий ориентированный граф с неотрицательными весами рёбер:</p><pre><div class=\\"bg-black rounded-md mb-4\\"><div class=\\"flex items-center relative text-gray-200 bg-gray-800 px-4 py-2 text-xs font-sans justify-between rounded-t-md\\"><span>css</span><button class=\\"flex ml-auto gap-2\\"><svg stroke=\\"currentColor\\" fill=\\"none\\" stroke-width=\\"2\\" viewBox=\\"0 0 24 24\\" stroke-linecap=\\"round\\" stroke-linejoin=\\"round\\" class=\\"h-4 w-4\\" height=\\"1em\\" width=\\"1em\\" xmlns=\\"http://www.w3.org/2000/svg\\"><path d=\\"M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2\\"></path><rect x=\\"8\\" y=\\"2\\" width=\\"8\\" height=\\"4\\" rx=\\"1\\" ry=\\"1\\"></rect></svg>Copy code</button></div><div class=\\"p-4 overflow-y-auto\\"><code class=\\"!whitespace-pre hljs language-css\\">   <span class=\\"hljs-selector-tag\\">A</span> --<span class=\\"hljs-number\\">2</span>--&gt; <span class=\\"hljs-selector-tag\\">B</span>\\n   |       ^\\n   |       |\\n   v       |\\n   C --<span class=\\"hljs-number\\">1</span>---+\\n</code></div></div></pre><p>Пусть начальная вершина - A. Запустим алгоритм Дейкстры:</p><ol><li>Начальное состояние:</li></ol><pre><div class=\\"bg-black rounded-md mb-4\\"><div class=\\"flex items-center relative text-gray-200 bg-gray-800 px-4 py-2 text-xs font-sans justify-between rounded-t-md\\"><span>css</span><button class=\\"flex ml-auto gap-2\\"><svg stroke=\\"currentColor\\" fill=\\"none\\" stroke-width=\\"2\\" viewBox=\\"0 0 24 24\\" stroke-linecap=\\"round\\" stroke-linejoin=\\"round\\" class=\\"h-4 w-4\\" height=\\"1em\\" width=\\"1em\\" xmlns=\\"http://www.w3.org/2000/svg\\"><path d=\\"M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2\\"></path><rect x=\\"8\\" y=\\"2\\" width=\\"8\\" height=\\"4\\" rx=\\"1\\" ry=\\"1\\"></rect></svg>Copy code</button></div><div class=\\"p-4 overflow-y-auto\\"><code class=\\"!whitespace-pre hljs language-css\\">    Вершина    | Расстояние от <span class=\\"hljs-selector-tag\\">A</span>\\n    -----------------------------\\n    <span class=\\"hljs-selector-tag\\">A</span>          | <span class=\\"hljs-number\\">0</span>\\n    <span class=\\"hljs-selector-tag\\">B</span>          | ∞\\n    C          | ∞\\n</code></div></div></pre><ol start=\\"2\\"><li><p>Выбор ближайшей вершины: Выбираем вершину A, так как она имеет минимальное расстояние (0).</p></li><li><p>Релаксация: Обновляем расстояния до соседних вершин:</p></li></ol><pre><div class=\\"bg-black rounded-md mb-4\\"><div class=\\"flex items-center relative text-gray-200 bg-gray-800 px-4 py-2 text-xs font-sans justify-between rounded-t-md\\"><span>css</span><button class=\\"flex ml-auto gap-2\\"><svg stroke=\\"currentColor\\" fill=\\"none\\" stroke-width=\\"2\\" viewBox=\\"0 0 24 24\\" stroke-linecap=\\"round\\" stroke-linejoin=\\"round\\" class=\\"h-4 w-4\\" height=\\"1em\\" width=\\"1em\\" xmlns=\\"http://www.w3.org/2000/svg\\"><path d=\\"M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2\\"></path><rect x=\\"8\\" y=\\"2\\" width=\\"8\\" height=\\"4\\" rx=\\"1\\" ry=\\"1\\"></rect></svg>Copy code</button></div><div class=\\"p-4 overflow-y-auto\\"><code class=\\"!whitespace-pre hljs language-css\\">    Вершина    | Расстояние от <span class=\\"hljs-selector-tag\\">A</span>\\n    -----------------------------\\n    <span class=\\"hljs-selector-tag\\">A</span>          | <span class=\\"hljs-number\\">0</span>\\n    <span class=\\"hljs-selector-tag\\">B</span>          | <span class=\\"hljs-number\\">2</span> (расстояние от <span class=\\"hljs-selector-tag\\">A</span> + вес ребра <span class=\\"hljs-selector-tag\\">A</span>-&gt;<span class=\\"hljs-selector-tag\\">B</span>)\\n    C          | <span class=\\"hljs-number\\">1</span> (расстояние от <span class=\\"hljs-selector-tag\\">A</span> + вес ребра <span class=\\"hljs-selector-tag\\">A</span>-&gt;C)\\n</code></div></div></pre><ol start=\\"4\\"><li><p>Выбор ближайшей вершины: Выбираем вершину C, так как она имеет минимальное расстояние (1).</p></li><li><p>Релаксация: Обновляем расстояния до соседних вершин:</p></li></ol><pre><div class=\\"bg-black rounded-md mb-4\\"><div class=\\"flex items-center relative text-gray-200 bg-gray-800 px-4 py-2 text-xs font-sans justify-between rounded-t-md\\"><span>css</span><button class=\\"flex ml-auto gap-2\\"><svg stroke=\\"currentColor\\" fill=\\"none\\" stroke-width=\\"2\\" viewBox=\\"0 0 24 24\\" stroke-linecap=\\"round\\" stroke-linejoin=\\"round\\" class=\\"h-4 w-4\\" height=\\"1em\\" width=\\"1em\\" xmlns=\\"http://www.w3.org/2000/svg\\"><path d=\\"M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2\\"></path><rect x=\\"8\\" y=\\"2\\" width=\\"8\\" height=\\"4\\" rx=\\"1\\" ry=\\"1\\"></rect></svg>Copy code</button></div><div class=\\"p-4 overflow-y-auto\\"><code class=\\"!whitespace-pre hljs language-css\\">    Вершина    | Расстояние от <span class=\\"hljs-selector-tag\\">A</span>\\n    -----------------------------\\n    <span class=\\"hljs-selector-tag\\">A</span>          | <span class=\\"hljs-number\\">0</span>\\n    <span class=\\"hljs-selector-tag\\">B</span>          | <span class=\\"hljs-number\\">2</span>\\n    C          | <span class=\\"hljs-number\\">1</span>\\n</code></div></div></pre><ol start=\\"6\\"><li><p>Выбор ближайшей вершины: Выбираем вершину B, так как она имеет минимальное расстояние (2).</p></li><li><p>Релаксация: Не нужно, так как все соседние вершины уже были рассмотрены.</p></li></ol><p>После завершения алгоритма Дейк</p></div>"],["Определение центра и периферийных вершин графа.","<div class=\\"markdown prose w-full break-words dark:prose-invert light\\"><p>Центр и периферийные вершины графа - это характеристики, которые определяют степень важности и централизации вершин в графе.</p><ol><li><p>Центр графа:\\nЦентр графа - это вершина (или вершины), которая имеет минимальную сумму расстояний до всех остальных вершин в графе. В центре графа концентрируется наибольшее количество кратчайших путей от данной вершины ко всем остальным вершинам.</p></li><li><p>Периферийные вершины графа:\\nПериферийные вершины графа - это вершины, которые имеют максимальное расстояние от одной из вершин графа. Они являются наиболее удаленными вершинами от других вершин в графе.</p></li></ol><p>Определение центра и периферийных вершин является важным аспектом в анализе графов, так как они помогают понять структуру и свойства графа. Центральные вершины обычно имеют большую важность и влияние на граф, а периферийные вершины могут оказывать незначительное влияние на связность и доступность в графе. Определение центра и периферийных вершин может быть полезным, например, при проектировании сетей или при анализе социальных связей.</p></div>"]],"Математическая логика и теория алгоритмов":[["Высказывания и высказывательные функции. Логические связи, их логический смысл (как читаются на естественном языке) и порядок выполнения","<div class=\\"markdown prose w-full break-words dark:prose-invert light\\"><p>Высказывания и высказывательные функции:</p><ol><li><p>Высказывание:\\nВысказывание - это утверждение или утвердительное предложение, которое может быть истинным или ложным, но не одновременно истинным и ложным. Высказываниями могут быть простые утверждения, такие как \\"Солнце светит\\", \\"2 + 2 = 4\\", \\"Москва - столица России\\". Высказывание обозначается буквами p, q, r и т.д.</p></li><li><p>Высказывательная функция:\\nВысказывательная функция - это функция, которая принимает одно или несколько высказываний и возвращает другое высказывание. Высказывательные функции обозначаются символами ¬ (отрицание), ∧ (логическое \\"и\\"), ∨ (логическое \\"или\\"), → (импликация), ↔ (эквиваленция) и т.д.</p></li></ol><p>Логические связи, их логический смысл и порядок выполнения:</p><ol><li>Отрицание (¬):\\nОтрицание (¬) - это высказывательная функция, которая принимает одно высказывание и возвращает его отрицание. Если высказывание истинно, то его отрицание ложно, и наоборот.</li></ol><p>Логический смысл: Если p - \\"Сегодня солнечный день\\", то ¬p - \\"Сегодня не солнечный день\\".</p><ol start=\\"2\\"><li>Конъюнкция (логическое \\"и\\") (∧):\\nКонъюнкция (∧) - это высказывательная функция, которая принимает два высказывания и возвращает истину, если оба высказывания истинны, и ложь в противном случае.</li></ol><p>Логический смысл: Если p - \\"Температура выше нуля\\", а q - \\"Небо ясное\\", то p ∧ q - \\"Температура выше нуля и небо ясное\\".</p><ol start=\\"3\\"><li>Дизъюнкция (логическое \\"или\\") (∨):\\nДизъюнкция (∨) - это высказывательная функция, которая принимает два высказывания и возвращает истину, если хотя бы одно из высказываний истинно, и ложь, если оба высказывания ложны.</li></ol><p>Логический смысл: Если p - \\"Дождь идет\\", а q - \\"Температура ниже нуля\\", то p ∨ q - \\"Дождь идет или температура ниже нуля\\".</p><ol start=\\"4\\"><li>Импликация (→):\\nИмпликация (→) - это высказывательная функция, которая принимает два высказывания и возвращает ложь только в том случае, когда первое высказывание истинно, а второе ложно. В остальных случаях импликация истинна.</li></ol><p>Логический смысл: Если p - \\"Сегодня праздник\\", а q - \\"Магазины закрыты\\", то p → q - \\"Если сегодня праздник, то магазины закрыты\\".</p><ol start=\\"5\\"><li>Эквиваленция (↔):\\nЭквиваленция (↔) - это высказывательная функция, которая принимает два высказывания и возвращает истину, если оба высказывания имеют одинаковую истинность, и ложь в противном случае.</li></ol><p>Логический смысл: Если p - \\"Температура выше нуля\\", а q - \\"Температура не ниже нуля\\", то p ↔ q - \\"Температура выше нуля тогда и только тогда, когда температура не ниже нуля\\".</p><p>Порядок выполнения логических связей зависит от приоритета операций, который определяется стандартными правилами математической логики, такими как выполнение операций в скобках, отрицание, конъ</p></div>"],["Истинностные таблицы высказываний для основных логических операций.","<div class=\\"markdown prose w-full break-words dark:prose-invert light\\"><p>Истинностные таблицы высказываний для основных логических операций:</p><p>Истинностные таблицы используются для представления и вычисления логических операций. В таблицах указываются все возможные комбинации значений исходных высказываний и результат соответствующей логической операции. Основные логические операции включают отрицание (¬), конъюнкцию (∧), дизъюнкцию (∨), импликацию (→) и эквиваленцию (↔).</p><p>Для каждой операции в таблице используются значения \\"Истина\\" (T) и \\"Ложь\\" (F). Количество строк в таблице зависит от числа исходных высказываний (пропозициональных переменных).</p><ol><li>Отрицание (¬):\\nТаблица отрицания имеет одну пропозициональную переменную и один столбец:</li></ol><pre><div class=\\"bg-black rounded-md mb-4\\"><div class=\\"flex items-center relative text-gray-200 bg-gray-800 px-4 py-2 text-xs font-sans justify-between rounded-t-md\\"><span>r</span><button class=\\"flex ml-auto gap-2\\"><svg stroke=\\"currentColor\\" fill=\\"none\\" stroke-width=\\"2\\" viewBox=\\"0 0 24 24\\" stroke-linecap=\\"round\\" stroke-linejoin=\\"round\\" class=\\"h-4 w-4\\" height=\\"1em\\" width=\\"1em\\" xmlns=\\"http://www.w3.org/2000/svg\\"><path d=\\"M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2\\"></path><rect x=\\"8\\" y=\\"2\\" width=\\"8\\" height=\\"4\\" rx=\\"1\\" ry=\\"1\\"></rect></svg>Copy code</button></div><div class=\\"p-4 overflow-y-auto\\"><code class=\\"!whitespace-pre hljs language-r\\"><span class=\\"hljs-operator\\">|</span> P <span class=\\"hljs-operator\\">|</span> ¬P <span class=\\"hljs-operator\\">|</span>\\n<span class=\\"hljs-operator\\">|</span><span class=\\"hljs-operator\\">-</span><span class=\\"hljs-operator\\">-</span><span class=\\"hljs-operator\\">-</span><span class=\\"hljs-operator\\">|</span><span class=\\"hljs-operator\\">-</span><span class=\\"hljs-operator\\">-</span><span class=\\"hljs-operator\\">-</span><span class=\\"hljs-operator\\">-</span><span class=\\"hljs-operator\\">|</span>\\n<span class=\\"hljs-operator\\">|</span> <span class=\\"hljs-built_in\\">T</span> <span class=\\"hljs-operator\\">|</span>  <span class=\\"hljs-built_in\\">F</span> <span class=\\"hljs-operator\\">|</span>\\n<span class=\\"hljs-operator\\">|</span> <span class=\\"hljs-built_in\\">F</span> <span class=\\"hljs-operator\\">|</span>  <span class=\\"hljs-built_in\\">T</span> <span class=\\"hljs-operator\\">|</span>\\n</code></div></div></pre><ol start=\\"2\\"><li>Конъюнкция (∧):\\nТаблица конъюнкции имеет две пропозициональные переменные и один столбец для результата:</li></ol><pre><div class=\\"bg-black rounded-md mb-4\\"><div class=\\"flex items-center relative text-gray-200 bg-gray-800 px-4 py-2 text-xs font-sans justify-between rounded-t-md\\"><span>r</span><button class=\\"flex ml-auto gap-2\\"><svg stroke=\\"currentColor\\" fill=\\"none\\" stroke-width=\\"2\\" viewBox=\\"0 0 24 24\\" stroke-linecap=\\"round\\" stroke-linejoin=\\"round\\" class=\\"h-4 w-4\\" height=\\"1em\\" width=\\"1em\\" xmlns=\\"http://www.w3.org/2000/svg\\"><path d=\\"M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2\\"></path><rect x=\\"8\\" y=\\"2\\" width=\\"8\\" height=\\"4\\" rx=\\"1\\" ry=\\"1\\"></rect></svg>Copy code</button></div><div class=\\"p-4 overflow-y-auto\\"><code class=\\"!whitespace-pre hljs language-r\\"><span class=\\"hljs-operator\\">|</span> P <span class=\\"hljs-operator\\">|</span> Q <span class=\\"hljs-operator\\">|</span> P ∧ Q <span class=\\"hljs-operator\\">|</span>\\n<span class=\\"hljs-operator\\">|</span><span class=\\"hljs-operator\\">-</span><span class=\\"hljs-operator\\">-</span><span class=\\"hljs-operator\\">-</span><span class=\\"hljs-operator\\">|</span><span class=\\"hljs-operator\\">-</span><span class=\\"hljs-operator\\">-</span><span class=\\"hljs-operator\\">-</span><span class=\\"hljs-operator\\">|</span><span class=\\"hljs-operator\\">-</span><span class=\\"hljs-operator\\">-</span><span class=\\"hljs-operator\\">-</span><span class=\\"hljs-operator\\">-</span><span class=\\"hljs-operator\\">-</span><span class=\\"hljs-operator\\">-</span><span class=\\"hljs-operator\\">-</span><span class=\\"hljs-operator\\">|</span>\\n<span class=\\"hljs-operator\\">|</span> <span class=\\"hljs-built_in\\">T</span> <span class=\\"hljs-operator\\">|</span> <span class=\\"hljs-built_in\\">T</span> <span class=\\"hljs-operator\\">|</span>   <span class=\\"hljs-built_in\\">T</span>   <span class=\\"hljs-operator\\">|</span>\\n<span class=\\"hljs-operator\\">|</span> <span class=\\"hljs-built_in\\">T</span> <span class=\\"hljs-operator\\">|</span> <span class=\\"hljs-built_in\\">F</span> <span class=\\"hljs-operator\\">|</span>   <span class=\\"hljs-built_in\\">F</span>   <span class=\\"hljs-operator\\">|</span>\\n<span class=\\"hljs-operator\\">|</span> <span class=\\"hljs-built_in\\">F</span> <span class=\\"hljs-operator\\">|</span> <span class=\\"hljs-built_in\\">T</span> <span class=\\"hljs-operator\\">|</span>   <span class=\\"hljs-built_in\\">F</span>   <span class=\\"hljs-operator\\">|</span>\\n<span class=\\"hljs-operator\\">|</span> <span class=\\"hljs-built_in\\">F</span> <span class=\\"hljs-operator\\">|</span> <span class=\\"hljs-built_in\\">F</span> <span class=\\"hljs-operator\\">|</span>   <span class=\\"hljs-built_in\\">F</span>   <span class=\\"hljs-operator\\">|</span>\\n</code></div></div></pre><ol start=\\"3\\"><li>Дизъюнкция (∨):\\nТаблица дизъюнкции имеет две пропозициональные переменные и один столбец для результата:</li></ol><pre><div class=\\"bg-black rounded-md mb-4\\"><div class=\\"flex items-center relative text-gray-200 bg-gray-800 px-4 py-2 text-xs font-sans justify-between rounded-t-md\\"><span>r</span><button class=\\"flex ml-auto gap-2\\"><svg stroke=\\"currentColor\\" fill=\\"none\\" stroke-width=\\"2\\" viewBox=\\"0 0 24 24\\" stroke-linecap=\\"round\\" stroke-linejoin=\\"round\\" class=\\"h-4 w-4\\" height=\\"1em\\" width=\\"1em\\" xmlns=\\"http://www.w3.org/2000/svg\\"><path d=\\"M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2\\"></path><rect x=\\"8\\" y=\\"2\\" width=\\"8\\" height=\\"4\\" rx=\\"1\\" ry=\\"1\\"></rect></svg>Copy code</button></div><div class=\\"p-4 overflow-y-auto\\"><code class=\\"!whitespace-pre hljs language-r\\"><span class=\\"hljs-operator\\">|</span> P <span class=\\"hljs-operator\\">|</span> Q <span class=\\"hljs-operator\\">|</span> P ∨ Q <span class=\\"hljs-operator\\">|</span>\\n<span class=\\"hljs-operator\\">|</span><span class=\\"hljs-operator\\">-</span><span class=\\"hljs-operator\\">-</span><span class=\\"hljs-operator\\">-</span><span class=\\"hljs-operator\\">|</span><span class=\\"hljs-operator\\">-</span><span class=\\"hljs-operator\\">-</span><span class=\\"hljs-operator\\">-</span><span class=\\"hljs-operator\\">|</span><span class=\\"hljs-operator\\">-</span><span class=\\"hljs-operator\\">-</span><span class=\\"hljs-operator\\">-</span><span class=\\"hljs-operator\\">-</span><span class=\\"hljs-operator\\">-</span><span class=\\"hljs-operator\\">-</span><span class=\\"hljs-operator\\">-</span><span class=\\"hljs-operator\\">|</span>\\n<span class=\\"hljs-operator\\">|</span> <span class=\\"hljs-built_in\\">T</span> <span class=\\"hljs-operator\\">|</span> <span class=\\"hljs-built_in\\">T</span> <span class=\\"hljs-operator\\">|</span>   <span class=\\"hljs-built_in\\">T</span>   <span class=\\"hljs-operator\\">|</span>\\n<span class=\\"hljs-operator\\">|</span> <span class=\\"hljs-built_in\\">T</span> <span class=\\"hljs-operator\\">|</span> <span class=\\"hljs-built_in\\">F</span> <span class=\\"hljs-operator\\">|</span>   <span class=\\"hljs-built_in\\">T</span>   <span class=\\"hljs-operator\\">|</span>\\n<span class=\\"hljs-operator\\">|</span> <span class=\\"hljs-built_in\\">F</span> <span class=\\"hljs-operator\\">|</span> <span class=\\"hljs-built_in\\">T</span> <span class=\\"hljs-operator\\">|</span>   <span class=\\"hljs-built_in\\">T</span>   <span class=\\"hljs-operator\\">|</span>\\n<span class=\\"hljs-operator\\">|</span> <span class=\\"hljs-built_in\\">F</span> <span class=\\"hljs-operator\\">|</span> <span class=\\"hljs-built_in\\">F</span> <span class=\\"hljs-operator\\">|</span>   <span class=\\"hljs-built_in\\">F</span>   <span class=\\"hljs-operator\\">|</span>\\n</code></div></div></pre><ol start=\\"4\\"><li>Импликация (→):\\nТаблица импликации имеет две пропозициональные переменные и один столбец для результата:</li></ol><pre><div class=\\"bg-black rounded-md mb-4\\"><div class=\\"flex items-center relative text-gray-200 bg-gray-800 px-4 py-2 text-xs font-sans justify-between rounded-t-md\\"><span>r</span><button class=\\"flex ml-auto gap-2\\"><svg stroke=\\"currentColor\\" fill=\\"none\\" stroke-width=\\"2\\" viewBox=\\"0 0 24 24\\" stroke-linecap=\\"round\\" stroke-linejoin=\\"round\\" class=\\"h-4 w-4\\" height=\\"1em\\" width=\\"1em\\" xmlns=\\"http://www.w3.org/2000/svg\\"><path d=\\"M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2\\"></path><rect x=\\"8\\" y=\\"2\\" width=\\"8\\" height=\\"4\\" rx=\\"1\\" ry=\\"1\\"></rect></svg>Copy code</button></div><div class=\\"p-4 overflow-y-auto\\"><code class=\\"!whitespace-pre hljs language-r\\"><span class=\\"hljs-operator\\">|</span> P <span class=\\"hljs-operator\\">|</span> Q <span class=\\"hljs-operator\\">|</span> P → Q <span class=\\"hljs-operator\\">|</span>\\n<span class=\\"hljs-operator\\">|</span><span class=\\"hljs-operator\\">-</span><span class=\\"hljs-operator\\">-</span><span class=\\"hljs-operator\\">-</span><span class=\\"hljs-operator\\">|</span><span class=\\"hljs-operator\\">-</span><span class=\\"hljs-operator\\">-</span><span class=\\"hljs-operator\\">-</span><span class=\\"hljs-operator\\">|</span><span class=\\"hljs-operator\\">-</span><span class=\\"hljs-operator\\">-</span><span class=\\"hljs-operator\\">-</span><span class=\\"hljs-operator\\">-</span><span class=\\"hljs-operator\\">-</span><span class=\\"hljs-operator\\">-</span><span class=\\"hljs-operator\\">-</span><span class=\\"hljs-operator\\">|</span>\\n<span class=\\"hljs-operator\\">|</span> <span class=\\"hljs-built_in\\">T</span> <span class=\\"hljs-operator\\">|</span> <span class=\\"hljs-built_in\\">T</span> <span class=\\"hljs-operator\\">|</span>   <span class=\\"hljs-built_in\\">T</span>   <span class=\\"hljs-operator\\">|</span>\\n<span class=\\"hljs-operator\\">|</span> <span class=\\"hljs-built_in\\">T</span> <span class=\\"hljs-operator\\">|</span> <span class=\\"hljs-built_in\\">F</span> <span class=\\"hljs-operator\\">|</span>   <span class=\\"hljs-built_in\\">F</span>   <span class=\\"hljs-operator\\">|</span>\\n<span class=\\"hljs-operator\\">|</span> <span class=\\"hljs-built_in\\">F</span> <span class=\\"hljs-operator\\">|</span> <span class=\\"hljs-built_in\\">T</span> <span class=\\"hljs-operator\\">|</span>   <span class=\\"hljs-built_in\\">T</span>   <span class=\\"hljs-operator\\">|</span>\\n<span class=\\"hljs-operator\\">|</span> <span class=\\"hljs-built_in\\">F</span> <span class=\\"hljs-operator\\">|</span> <span class=\\"hljs-built_in\\">F</span> <span class=\\"hljs-operator\\">|</span>   <span class=\\"hljs-built_in\\">T</span>   <span class=\\"hljs-operator\\">|</span>\\n</code></div></div></pre><ol start=\\"5\\"><li>Эквиваленция (↔):\\nТаблица эквиваленции имеет две пропозициональные переменные и один столбец для результата:</li></ol><pre><div class=\\"bg-black rounded-md mb-4\\"><div class=\\"flex items-center relative text-gray-200 bg-gray-800 px-4 py-2 text-xs font-sans justify-between rounded-t-md\\"><span>r</span><button class=\\"flex ml-auto gap-2\\"><svg stroke=\\"currentColor\\" fill=\\"none\\" stroke-width=\\"2\\" viewBox=\\"0 0 24 24\\" stroke-linecap=\\"round\\" stroke-linejoin=\\"round\\" class=\\"h-4 w-4\\" height=\\"1em\\" width=\\"1em\\" xmlns=\\"http://www.w3.org/2000/svg\\"><path d=\\"M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2\\"></path><rect x=\\"8\\" y=\\"2\\" width=\\"8\\" height=\\"4\\" rx=\\"1\\" ry=\\"1\\"></rect></svg>Copy code</button></div><div class=\\"p-4 overflow-y-auto\\"><code class=\\"!whitespace-pre hljs language-r\\"><span class=\\"hljs-operator\\">|</span> P <span class=\\"hljs-operator\\">|</span> Q <span class=\\"hljs-operator\\">|</span> P ↔ Q <span class=\\"hljs-operator\\">|</span>\\n<span class=\\"hljs-operator\\">|</span><span class=\\"hljs-operator\\">-</span><span class=\\"hljs-operator\\">-</span><span class=\\"hljs-operator\\">-</span><span class=\\"hljs-operator\\">|</span><span class=\\"hljs-operator\\">-</span><span class=\\"hljs-operator\\">-</span><span class=\\"hljs-operator\\">-</span><span class=\\"hljs-operator\\">|</span><span class=\\"hljs-operator\\">-</span><span class=\\"hljs-operator\\">-</span><span class=\\"hljs-operator\\">-</span><span class=\\"hljs-operator\\">-</span><span class=\\"hljs-operator\\">-</span><span class=\\"hljs-operator\\">-</span><span class=\\"hljs-operator\\">-</span><span class=\\"hljs-operator\\">|</span>\\n<span class=\\"hljs-operator\\">|</span> <span class=\\"hljs-built_in\\">T</span> <span class=\\"hljs-operator\\">|</span> <span class=\\"hljs-built_in\\">T</span> <span class=\\"hljs-operator\\">|</span>   <span class=\\"hljs-built_in\\">T</span>   <span class=\\"hljs-operator\\">|</span>\\n<span class=\\"hljs-operator\\">|</span> <span class=\\"hljs-built_in\\">T</span> <span class=\\"hljs-operator\\">|</span> <span class=\\"hljs-built_in\\">F</span> <span class=\\"hljs-operator\\">|</span>   <span class=\\"hljs-built_in\\">F</span>   <span class=\\"hljs-operator\\">|</span>\\n<span class=\\"hljs-operator\\">|</span> <span class=\\"hljs-built_in\\">F</span> <span class=\\"hljs-operator\\">|</span> <span class=\\"hljs-built_in\\">T</span> <span class=\\"hljs-operator\\">|</span>   <span class=\\"hljs-built_in\\">F</span>   <span class=\\"hljs-operator\\">|</span>\\n<span class=\\"hljs-operator\\">|</span> <span class=\\"hljs-built_in\\">F</span> <span class=\\"hljs-operator\\">|</span> <span class=\\"hljs-built_in\\">F</span> <span class=\\"hljs-operator\\">|</span>   <span class=\\"hljs-built_in\\">T</span>   <span class=\\"hljs-operator\\">|</span>\\n</code></div></div></pre><p>Эти истинностные таблицы позволяют определить и понять результаты логических операций в зависимости от исходных значений высказываний.</p></div>"],["Формулы и формализация высказываний. Способы нахождения значений формулы","<div class=\\"markdown prose w-full break-words dark:prose-invert light\\"><p>Формулы и формализация высказываний:</p><ol><li>Формулы:\\nФормула - это последовательность символов, которая может быть составлена из пропозициональных переменных (переменных высказываний) и логических связок (¬ - отрицание, ∧ - конъюнкция, ∨ - дизъюнкция, → - импликация, ↔ - эквиваленция). Формула может быть составлена в соответствии с определенными правилами синтаксиса.</li></ol><p>Примеры формул:</p><ul><li>P ∧ Q</li><li>¬P ∨ (Q → R)</li><li>(P → Q) ↔ ¬R</li></ul><ol start=\\"2\\"><li>Формализация высказываний:\\nФормализация - это процесс перевода естественного языка в формулы математической логики. Высказывания в естественном языке могут быть нечеткими и многозначными, а формализация позволяет представить их в виде точных и четких формул.</li></ol><p>Примеры формализации:</p><ul><li>\\"Солнце светит\\" может быть формализовано как P, где P - пропозициональная переменная, представляющая утверждение \\"Солнце светит\\".</li><li>\\"Если завтра будет дождь, то я возьму зонтик\\" может быть формализовано как D → U, где D - пропозициональная переменная \\"Завтра будет дождь\\", а U - пропозициональная переменная \\"Я возьму зонтик\\".</li></ul><p>Способы нахождения значений формулы:</p><ol><li><p>Задание значений переменных: Для каждой пропозициональной переменной в формуле задаются значения \\"Истина\\" (T) или \\"Ложь\\" (F). Затем вычисляется значение всей формулы на основе значений переменных и логических связок.</p></li><li><p>Таблицы истинности: Составляются таблицы истинности для всех возможных комбинаций значений пропозициональных переменных в формуле. В таблице указываются значения высказывания при каждой комбинации значений переменных.</p></li><li><p>Правила вычисления: Используются правила логических связок для вычисления значения формулы. Например, значение конъюнкции P ∧ Q равно \\"Истина\\" (T) только если оба P и Q равны \\"Истина\\" (T).</p></li></ol><p>Способ нахождения значений формулы зависит от её сложности и конкретной ситуации. Например, для простых формул можно использовать метод задания значений переменных или таблицы истинности, а для более сложных формул могут применяться правила вычисления или более сложные методы анализа.</p></div>"],["Общезначимость (тождественность) формул в ИВ. Способы определения общезначимости формул.","<div class=\\"markdown prose w-full break-words dark:prose-invert light\\"><p>Общезначимость (тождественность) формул в исчислении высказываний (ИВ):</p><p>Общезначимая формула (также называемая тождественно истинной формулой) - это такая формула, которая истинна при любых значениях пропозициональных переменных в ней, независимо от их значений. То есть, независимо от того, какие значения принимают пропозициональные переменные в формуле, сама формула всегда будет истинной.</p><p>Способы определения общезначимости формул:</p><ol><li><p>Таблица истинности: Составляется таблица истинности для формулы, где указываются все возможные комбинации значений пропозициональных переменных. Если в каждой строке таблицы формула принимает значение \\"Истина\\" (T), то она является общезначимой.</p></li><li><p>Метод отрицания: Если можно доказать, что отрицание формулы (¬Ф) является невозможной (необщезначимой) формулой, то сама формула Ф является общезначимой.</p></li><li><p>Аксиоматический метод: Применяются аксиомы и правила вывода для доказательства общезначимости формул. Если можно вывести формулу из системы аксиом, то она считается общезначимой.</p></li><li><p>Метод семантических деревьев: Применяется метод семантических деревьев для проверки всех возможных комбинаций значений пропозициональных переменных в формуле. Если для всех комбинаций формула истинна, то она является общезначимой.</p></li><li><p>Метод канонических дизъюнктивных нормальных форм (КДНФ) и канонических конъюнктивных нормальных форм (ККНФ): Формула считается общезначимой, если её КДНФ представляет собой тождественно истинное выражение или её ККНФ представляет собой тождественно ложное выражение.</p></li></ol><p>Общезначимость формул в ИВ имеет важное значение в математической логике и теоретической информатике, так как позволяет определить некоторые особенности и свойства логических выражений.</p></div>"],["Правила получения общезначимости формул в ИВ. Понятие негатива формулы.","<div class=\\"markdown prose w-full break-words dark:prose-invert light\\"><p>Правила получения общезначимости формул в исчислении высказываний (ИВ):</p><ol><li><p>Правило тождества (Idempotency):\\nФормула A ∨ A является общезначимой. Это правило утверждает, что дизъюнкция высказывания с самим собой всегда истинна.</p></li><li><p>Правило идемпотентности (Idempotency):\\nФормула A ∧ A является общезначимой. Это правило утверждает, что конъюнкция высказывания с самим собой всегда истинна.</p></li><li><p>Правило идемпотентности отрицания (Double Negation):\\nФормула ¬¬A эквивалентна формуле A и является общезначимой. Это правило утверждает, что двойное отрицание высказывания эквивалентно самому высказыванию.</p></li><li><p>Правило исключения третьего (Law of Excluded Middle):\\nФормула A ∨ ¬A является общезначимой. Это правило утверждает, что каждое высказывание или его отрицание является истинным.</p></li><li><p>Правило противоречия (Law of Contradiction):\\nФормула A ∧ ¬A является общезначимой. Это правило утверждает, что высказывание и его отрицание не могут быть одновременно истинными.</p></li><li><p>Правила дистрибутивности (Distributive Laws):\\nФормулы, удовлетворяющие законам дистрибутивности, являются общезначимыми:</p><ul><li>A ∧ (B ∨ C) = (A ∧ B) ∨ (A ∧ C)</li><li>A ∨ (B ∧ C) = (A ∨ B) ∧ (A ∨ C)</li></ul></li></ol><p>Понятие негатива формулы:</p><p>В контексте математической логики, негатив формулы относится к отрицанию самой формулы. Например, если дана формула А, то негативом этой формулы будет ¬A. В некоторых случаях, понятие негатива может также применяться к компонентам формулы, например, к отрицанию переменной в конъюнкции или дизъюнкции.</p><p>Правило идемпотентности отрицания (Double Negation) утверждает, что двойное отрицание формулы эквивалентно самой формуле. Это означает, что формула A и её негатив ¬¬A эквивалентны и имеют одинаковое значение истинности.</p></div>"],["Логическая равносильность. Основные равносильности (законы) в ИВ.","<div class=\\"markdown prose w-full break-words dark:prose-invert light\\"><p>Логическая равносильность:</p><p>Логическая равносильность (также называемая эквивалентностью) - это отношение между двумя логическими высказываниями или формулами, которые имеют одинаковые значения истинности при всех возможных значениях пропозициональных переменных. Если две формулы A и B являются логически равносильными (A ≡ B), то это означает, что A и B истинны или ложны одновременно при всех значениях переменных.</p><p>Основные равносильности (законы) в исчислении высказываний (ИВ):</p><ol><li><p>Закон идемпотентности (Idempotent Law):</p><ul><li>A ∨ A ≡ A</li><li>A ∧ A ≡ A</li></ul></li><li><p>Закон коммутативности (Commutative Laws):</p><ul><li>A ∨ B ≡ B ∨ A</li><li>A ∧ B ≡ B ∧ A</li></ul></li><li><p>Закон ассоциативности (Associative Laws):</p><ul><li>(A ∨ B) ∨ C ≡ A ∨ (B ∨ C)</li><li>(A ∧ B) ∧ C ≡ A ∧ (B ∧ C)</li></ul></li><li><p>Закон дистрибутивности (Distributive Laws):</p><ul><li>A ∨ (B ∧ C) ≡ (A ∨ B) ∧ (A ∨ C)</li><li>A ∧ (B ∨ C) ≡ (A ∧ B) ∨ (A ∧ C)</li></ul></li><li><p>Закон идемпотентности отрицания (Double Negation):</p><ul><li>¬¬A ≡ A</li></ul></li><li><p>Закон противоречия (Law of Contradiction):</p><ul><li>A ∧ ¬A ≡ F (ложь)</li></ul></li><li><p>Закон исключения третьего (Law of Excluded Middle):</p><ul><li>A ∨ ¬A ≡ T (истина)</li></ul></li><li><p>Закон импликации (Implication Laws):</p><ul><li>A → B ≡ ¬A ∨ B</li><li>¬(A ∧ B) ≡ ¬A ∨ ¬B</li></ul></li><li><p>Закон эквиваленции (Equivalence Laws):</p><ul><li>A ↔ B ≡ (A → B) ∧ (B → A)</li></ul></li></ol><p>Законы логической равносильности используются для упрощения и преобразования логических выражений, и они играют важную роль в процессе доказательств и решения логических задач.</p></div>"],["Обратные и противоположные высказывания. Закон контрапозиции.","<div class=\\"markdown prose w-full break-words dark:prose-invert light\\"><p>Обратные и противоположные высказывания:</p><ol><li>Обратное высказывание:\\nОбратное высказывание к утверждению \\"если A, то B\\" имеет вид \\"если B, то A\\". Обратное высказывание не обязательно является истинным, даже если исходное утверждение истинно.</li></ol><p>Пример:\\nИсходное утверждение: Если сегодня идет дождь, то улицы мокрые.\\nОбратное утверждение: Если улицы мокрые, то сегодня идет дождь.</p><ol start=\\"2\\"><li>Противоположное высказывание:\\nПротивоположное высказывание к утверждению \\"если A, то B\\" имеет вид \\"если не A, то не B\\". Противоположное высказывание всегда является ложным, если исходное утверждение истинно.</li></ol><p>Пример:\\nИсходное утверждение: Если я ем мороженое, то я счастлив.\\nПротивоположное утверждение: Если я не ем мороженое, то я не счастлив.</p><p>Закон контрапозиции:</p><p>Закон контрапозиции утверждает, что если утверждение \\"если A, то B\\" истинно, то утверждение \\"если не B, то не A\\" также истинно. Этот закон позволяет заменить исходное утверждение на его контрапозицию без потери истинности.</p><p>Математический вид закона контрапозиции:\\nЕсли A → B, то ¬B → ¬A</p><p>Пример:\\nИсходное утверждение: Если число четное, то оно делится на 2.\\nКонтрапозиция: Если число не делится на 2, то оно нечетное.</p><p>Закон контрапозиции часто применяется в математических доказательствах для упрощения логических выражений и установления эквивалентности различных утверждений.</p></div>"],["Логическое следование: аргумент, посылка, заключение. Формальная запись аргумента.","<div class=\\"markdown prose w-full break-words dark:prose-invert light\\"><p>Логическое следование:</p><p>Логическое следование - это связь между посылкой (предпосылкой) и заключением в аргументе. Если из истинности посылки следует истинность заключения, то говорят, что заключение логически следует из посылки. Логическое следование обозначается символом \\"→\\" (импликация).</p><ul><li>Посылка: это высказывание или формула, которое служит предпосылкой для вывода заключения.</li><li>Заключение: это высказывание или формула, которое выводится на основе посылки.</li></ul><p>Формальная запись аргумента:</p><p>Аргумент - это логическая структура, состоящая из посылки и заключения. Аргументы могут быть представлены формально в виде:</p><p>Посылка → Заключение</p><p>Где \\"Посылка\\" представляет собой высказывание или формулу, которую мы принимаем как истинную, а \\"Заключение\\" - высказывание или формулу, которую мы выводим или заключаем на основе посылки.</p><p>Пример аргумента:</p><p>Посылка: Если сегодня идет дождь,\\nЗаключение: то улицы мокрые.</p><p>Формальная запись аргумента: Если сегодня идет дождь, то улицы мокрые.</p><p>Аргументы играют важную роль в логике, философии и математике, позволяя делать выводы на основе предпосылок и логических правил. Они помогают устанавливать отношения между утверждениями и рассуждать логически верно.</p></div>"],["Понятие предиката. Местность предиката. Тождественно истинные и тождественно ложные предикаты.","<div class=\\"markdown prose w-full break-words dark:prose-invert light\\"><p>Понятие предиката:</p><p>В математической логике и математике предикат - это выражение, содержащее переменные, которое становится истинным или ложным в зависимости от значений, подставленных вместо переменных. Предикаты используются для выражения отношений между объектами или свойств, которые могут быть верны или ложны для различных значений переменных.</p><p>Примеры предикатов:</p><ul><li>P(x): \\"x больше 5\\".</li><li>Q(x, y): \\"x делится на y\\".</li></ul><p>Местность предиката:</p><p>Местность (арность) предиката - это количество аргументов (переменных), которые принимает предикат. Местность предиката определяет, сколько переменных нужно подставить в предикат, чтобы получить истинное или ложное высказывание.</p><p>Например:</p><ul><li>Предикат P(x) имеет местность 1, так как принимает один аргумент (x).</li><li>Предикат Q(x, y) имеет местность 2, так как принимает два аргумента (x и y).</li></ul><p>Тождественно истинные и тождественно ложные предикаты:</p><p>Тождественно истинный предикат (тавтология) - это предикат, который истинен для всех возможных значений переменных. Вне зависимости от значений аргументов, тождественно истинный предикат всегда будет принимать значение \\"Истина\\" (T).</p><p>Пример тождественно истинного предиката:\\nПредикат P(x): \\"x + 2 &gt; x\\".</p><p>Тождественно ложный предикат (контрадикция) - это предикат, который ложен для всех возможных значений переменных. Вне зависимости от значений аргументов, тождественно ложный предикат всегда будет принимать значение \\"Ложь\\" (F).</p><p>Пример тождественно ложного предиката:\\nПредикат Q(x): \\"x &lt; x\\".</p><p>Тождественно истинные и тождественно ложные предикаты представляют особый интерес в математической логике, так как они устанавливаются на основе логических свойств выражений и не зависят от конкретных значений переменных.</p></div>"],["Логические операции над предикатами. Понятие связанных и свободных переменных.","<div class=\\"markdown prose w-full break-words dark:prose-invert light\\"><p>Логические операции над предикатами:</p><p>В математической логике выполняются различные логические операции над предикатами, такие как конъюнкция (логическое \\"и\\"), дизъюнкция (логическое \\"или\\"), отрицание (логическое \\"не\\") и импликация (логическое \\"если-то\\"). Эти операции позволяют строить более сложные высказывания на основе простых предикатов.</p><ol><li><p>Конъюнкция (AND): Обозначается символом \\"∧\\". Предикат A ∧ B истинен, если оба предиката A и B истинны.</p></li><li><p>Дизъюнкция (OR): Обозначается символом \\"∨\\". Предикат A ∨ B истинен, если хотя бы один из предикатов A или B истинен.</p></li><li><p>Отрицание (NOT): Обозначается символом \\"¬\\". Предикат ¬A истинен, если предикат A ложен.</p></li><li><p>Импликация (IF-THEN): Обозначается символом \\"→\\". Предикат A → B истинен, если из A следует B. Если A ложно, то предикат A → B всегда истинен.</p></li></ol><p>Понятие связанных и свободных переменных:</p><ol><li>Связанные переменные:\\nСвязанные переменные - это переменные в предикате, которые связаны кванторами и имеют определенную область действия внутри формулы. Кванторы, такие как \\"∀\\" (для всех) и \\"∃\\" (существует), связывают переменные и определяют, какие значения переменных рассматриваются внутри предиката.</li></ol><p>Пример:\\nВ предикате \\"∃x (x &gt; 0)\\" переменная \\"x\\" является связанной переменной, так как она связана квантором ∃ (существует) и имеет область действия ограниченную внутри предиката.</p><ol start=\\"2\\"><li>Свободные переменные:\\nСвободные переменные - это переменные в предикате, которые не связаны никакими кванторами и не имеют определенной области действия. Они могут принимать любые значения в контексте, в котором рассматривается предикат.</li></ol><p>Пример:\\nВ предикате \\"x &gt; 0\\" переменная \\"x\\" является свободной переменной, так как она не связана кванторами и может принимать любые значения.</p><p>Понимание связанных и свободных переменных важно для понимания кванторов и логических операций, так как они определяют область действия предикатов и правильное применение логических правил при работе с формулами.</p></div>"],["Язык предикатов первого порядка Синтаксис.","<div class=\\"markdown prose w-full break-words dark:prose-invert light\\"><p>Язык предикатов первого порядка - это формальный язык, используемый в математической логике и математике для формулировки высказываний и математических утверждений с использованием предикатов, функций и кванторов. Он расширяет язык исчисления высказываний (пропозициональной логики) путем введения переменных и кванторов, что позволяет более точно описывать математические структуры и свойства объектов.</p><p>Синтаксис языка предикатов первого порядка включает следующие элементы:</p><ol><li>Предикаты: Предикаты представляют отношения или свойства объектов и описывают, когда они являются истинными или ложными. Предикаты могут зависеть от одной или нескольких переменных.</li></ol><p>Примеры предикатов: P(x), Q(x, y)</p><ol start=\\"2\\"><li>Функции: Функции описывают преобразования или операции над объектами и могут зависеть от одной или нескольких переменных.</li></ol><p>Примеры функций: f(x), g(x, y)</p><ol start=\\"3\\"><li>Константы: Константы - это имена, которые представляют некоторые конкретные объекты в предметной области.</li></ol><p>Примеры констант: a, b, c</p><ol start=\\"4\\"><li>Переменные: Переменные - это символы, которые представляют элементы или объекты, область значений которых может быть определена в контексте формулы.</li></ol><p>Примеры переменных: x, y, z</p><ol start=\\"5\\"><li><p>Логические связки: Логические связки (конъюнкция, дизъюнкция, отрицание, импликация) используются для объединения предикатов и выражений.</p></li><li><p>Кванторы: Кванторы (универсальный квантор ∀ и существенный квантор ∃) используются для выражения утверждений, которые верны для всех элементов (универсальный квантор) или для некоторых элементов (существенный квантор) в предметной области.</p></li></ol><p>Примеры выражений с кванторами:</p><ul><li>∀x P(x) (для всех x, P(x) истинно)</li><li>∃x Q(x) (существует x, для которого Q(x) истинно)</li></ul><p>Синтаксис языка предикатов первого порядка позволяет формулировать сложные математические утверждения и рассуждения, что делает его мощным инструментом для работы с формальными математическими структурами.</p></div>"],["Язык предиката первого порядка. Семантика.","<div class=\\"markdown prose w-full break-words dark:prose-invert light\\"><p>Язык предикатов первого порядка имеет синтаксис, как описано в предыдущем вопросе (вопрос №11), и также имеет семантику. Семантика языка предикатов первого порядка определяет значения выражений этого языка и их интерпретацию в различных моделях. Она связывает синтаксические конструкции языка с их смысловыми значениями.</p><p>Элементы семантики языка предикатов первого порядка:</p><ol><li><p>Модель:\\nМодель - это математическая структура, которая определяет интерпретацию элементов языка предикатов первого порядка. В модели определены область объектов (универсум), значения предикатов и функций, а также значения констант и переменных.</p></li><li><p>Интерпретация предикатов и функций:\\nМодель определяет, каким образом интерпретируются предикаты (отношения) и функции (операции) языка. Каждому предикату приписывается набор элементов из универсума, для которых предикат истинен, а каждой функции - соответствующее правило вычисления значений.</p></li><li><p>Значения переменных:\\nМодель также определяет значения переменных внутри формулы. При оценке выражений с кванторами (универсальный и существенный) модель указывает, какие значения принимают переменные.</p></li><li><p>Истинность формул:\\nСемантика языка предикатов первого порядка позволяет определить, когда формула является истинной или ложной в данной модели. Истинность формулы зависит от значений предикатов, функций и переменных, заданных в модели.</p></li></ol><p>Семантика языка предикатов первого порядка играет ключевую роль в математической логике, так как она позволяет формально определить смысл высказываний и доказательств в этом языке. Это важно для корректного применения логических правил, рассуждений и доказательств в математике и других областях, где используется формальное логическое мышление.</p></div>"],["Интерпретация в логике предикатов первого порядка. Понятие универсума. Двойственность формул с кванторами общности и существования.","<div class=\\"markdown prose w-full break-words dark:prose-invert light\\"><p>Интерпретация в логике предикатов первого порядка:</p><p>Интерпретация в логике предикатов первого порядка - это процесс присвоения смысла (значения) элементам языка предикатов первого порядка в рамках конкретной модели. Она определяет, каким образом интерпретируются предикаты, функции, константы и переменные, а также определяет истинность формулы в этой модели.</p><p>Понятие универсума:</p><p>Универсум (также называемый доменом или областью предметной интерпретации) - это множество всех объектов, для которых определены предикаты и функции языка предикатов первого порядка в данной модели. Универсум представляет собой основное множество, в котором выполняются операции и отношения. Это может быть любое множество объектов, такое как множество натуральных чисел, множество людей или множество всех точек в пространстве.</p><p>Двойственность формул с кванторами общности и существования:</p><p>Кванторы общности (∀ - \\"для всех\\") и существования (∃ - \\"существует\\") являются основными кванторами языка предикатов первого порядка и позволяют выражать утверждения, относящиеся к множествам элементов.</p><p>Двойственность формул с кванторами общности и существования заключается в следующем:</p><ol><li>Формула с квантором общности (∀x) утверждает, что утверждение верно для всех элементов универсума. Если формула с квантором общности истинна, это означает, что утверждение верно для каждого элемента из универсума.</li></ol><p>Пример: ∀x (x &gt; 0) - \\"Для всех x верно, что x больше 0.\\"</p><ol start=\\"2\\"><li>Формула с квантором существования (∃x) утверждает, что утверждение верно хотя бы для одного элемента универсума. Если формула с квантором существования истинна, это означает, что существует хотя бы один элемент, для которого утверждение истинно.</li></ol><p>Пример: ∃x (x &gt; 0) - \\"Существует x, такой что x больше 0.\\"</p><p>Таким образом, двойственность кванторов общности и существования выражает различные виды утверждений относительно множества элементов универсума: либо для всех, либо хотя бы для одного.</p></div>"],["Определение формулы в исчислении предикатов первого порядка: простые и составные (термы, атомы, формулы)","<div class=\\"markdown prose w-full break-words dark:prose-invert light\\"><p>В исчислении предикатов первого порядка формулы могут быть простыми или составными. Давайте определим каждый из этих типов формул:</p><ol><li>Простые формулы:\\nПростые формулы включают в себя термы и атомы.</li></ol><ul><li>Терм: Терм представляет собой выражение, которое обозначает объект или значение в предметной области. Термы могут быть переменными, константами или результатами функций, примененных к аргументам. Термы не содержат логических связок.</li></ul><p>Примеры термов:\\na (константа)\\nx (переменная)\\nf(x, y) (функция с аргументами x и y)</p><ul><li>Атом: Атом - это предикат, примененный к аргументам (термам). Он представляет собой утверждение или отношение между объектами. Атомы могут быть истинными или ложными в зависимости от значений аргументов и интерпретации предикатов.</li></ul><p>Примеры атомов:\\nP(x) (Предикат P с аргументом x)\\nQ(x, y) (Предикат Q с аргументами x и y)</p><ol start=\\"2\\"><li>Составные формулы:\\nСоставные формулы строятся с использованием логических связок (конъюнкция, дизъюнкция, отрицание, импликация) и кванторов (общности и существования) над простыми формулами. Они позволяют строить более сложные высказывания и утверждения.</li></ol><p>Примеры составных формул:</p><ul><li>P(x) ∧ Q(y) (конъюнкция атомов P(x) и Q(y))</li><li>∀x P(x) (утверждение, что P(x) истинно для всех значений x)</li><li>∃y Q(y) (утверждение, что существует значение y, для которого Q(y) истинно)</li></ul><p>В исчислении предикатов первого порядка формулы позволяют формально описывать свойства, отношения и действия в математике и других областях, используя логические операции и кванторы для выражения утверждений о множествах объектов и их свойствах.</p></div>"],["Машина Поста и машина Тьюринга, отличительные особенности. Связь с определением алгоритма (свойства, параметры)","<div class=\\"markdown prose w-full break-words dark:prose-invert light\\"><p>Машина Поста и машина Тьюринга являются формальными моделями вычислений, которые имеют свои отличительные особенности. Обе модели связаны с определением алгоритма и представляют абстрактные устройства для решения вычислительных задач.</p><p>Машина Поста:</p><ol><li>Особенности:</li></ol><ul><li>Машина Поста - это простая абстрактная модель, представляющая собой ленту с бесконечным количеством ячеек и головку, которая может перемещаться влево или вправо по ленте.</li><li>В каждой ячейке ленты может быть символ из некоторого алфавита.</li><li>Машина Поста имеет ограниченное количество внутренних состояний, которые определяют ее поведение.</li><li>Правила перехода определяют, как машина изменяет свое состояние и символы на ленте в зависимости от текущего состояния и символа под головкой.</li></ul><ol start=\\"2\\"><li>Связь с определением алгоритма:</li></ol><ul><li>Машина Поста представляет абстрактную модель вычислений и позволяет формализовать простые алгоритмические процессы.</li><li>Правила перехода в машине Поста эквивалентны шагам алгоритма, которые изменяют состояние и данные на каждом шаге выполнения.</li></ul><p>Машина Тьюринга:</p><ol><li>Особенности:</li></ol><ul><li>Машина Тьюринга - это более мощная абстрактная модель вычислений, представляющая собой ленту с бесконечным количеством ячеек и головку, которая может перемещаться влево или вправо по ленте.</li><li>Каждая ячейка ленты может содержать символ из некоторого алфавита.</li><li>Машина Тьюринга также имеет внутреннее состояние, которое определяет ее поведение.</li><li>Правила перехода определяют, как машина изменяет свое состояние и символы на ленте в зависимости от текущего состояния и символа под головкой.</li></ul><ol start=\\"2\\"><li>Связь с определением алгоритма:</li></ol><ul><li>Машина Тьюринга является универсальной абстрактной моделью вычислений, что означает, что она может моделировать любой алгоритм или вычислительный процесс.</li><li>Машина Тьюринга связана с определением алгоритма в том смысле, что любой алгоритм, который можно выполнить на компьютере или в программировании, может быть смоделирован с помощью машины Тьюринга. Это свойство называется тезисом Чёрча-Тьюринга.</li></ul><p>В целом, как машина Поста, так и машина Тьюринга представляют универсальные абстрактные модели вычислений и играют важную роль в теории вычислимости и формальных основах алгоритмов. Однако машина Тьюринга, благодаря своей универсальности, является более широко используемой в теоретическом анализе алгоритмов и компьютерных наук.</p></div>"],["Нормальные алгоритм Маркова. Связь с определением алгоритма (свойства, параметры).","<div class=\\"markdown prose w-full break-words dark:prose-invert light\\"><p>Нормальные алгоритмы Маркова (НАМ) - это универсальные вычислительные устройства, представляющие собой абстрактные модели вычислений, которые состоят из конечного набора правил или инструкций для изменения состояния некоторой конфигурации данных. НАМ являются разновидностью машин Тьюринга и были предложены Андреем Марковым в 1961 году.</p><p>Особенности нормальных алгоритмов Маркова:</p><ol><li><p>Конфигурация: Конфигурация НАМ представляет собой последовательность символов (например, из некоторого алфавита) на ленте и текущее состояние (внутреннее состояние) машины.</p></li><li><p>Правила перехода: Нормальные алгоритмы Маркова имеют конечный набор правил перехода, каждое из которых состоит из двух частей - шаблона и замены. Шаблон представляет собой последовательность символов, которую нужно найти на ленте, и текущее состояние машины. Замена определяет, как изменить найденный шаблон и состояние на ленте. При выполнении правила, машина находит первое вхождение шаблона на ленте, заменяет его согласно правилу и переходит в новое состояние.</p></li><li><p>Остановка: Нормальный алгоритм Маркова завершает работу, когда не существует правила, которое применимо к текущей конфигурации. Таким образом, НАМ всегда останавливается после конечного числа шагов.</p></li></ol><p>Связь с определением алгоритма:</p><ul><li>Нормальные алгоритмы Маркова, как и машины Тьюринга, являются универсальными моделями вычислений, то есть они могут моделировать любой вычислительный процесс.</li><li>НАМ демонстрируют связь с определением алгоритма через конечный набор правил и инструкций для изменения состояния данных. Такие правила могут формировать последовательности шагов, которые представляют алгоритмическую логику для решения задачи.</li></ul><p>Нормальные алгоритмы Маркова обладают уникальными математическими свойствами и находят применение в теоретической информатике, теории формальных языков и исследованиях по вычислимости. Они представляют собой интересный объект изучения для исследователей, изучающих фундаментальные аспекты алгоритмов и вычислений.</p></div>"]],"Теория автоматов и формальных языков":[["Автоматы с магазинной памятью","<div class=\\"markdown prose w-full break-words dark:prose-invert light\\"><p>Автоматы с магазинной памятью (МП-автоматы) - это абстрактные вычислительные устройства, которые являются расширением конечных автоматов и обладают более высокой вычислительной мощностью. МП-автоматы используются в теории формальных языков и являются одним из типов автоматов, используемых для определения и распознавания контекстно-свободных языков.</p><p>Основные характеристики МП-автоматов:</p><ol><li><p>Магазинная память: Магазин представляет собой абстрактное устройство, которое может читать, записывать и хранить информацию в виде символов в стеке. Магазин используется для хранения промежуточных результатов и управления вычислениями автомата.</p></li><li><p>Состояния: МП-автоматы, как и конечные автоматы, имеют набор состояний, из которых одно состояние является начальным, и может быть также определено несколько конечных состояний.</p></li><li><p>Входной алфавит: Как и в конечных автоматах, МП-автомат работает с входными символами из некоторого входного алфавита.</p></li><li><p>Таблица переходов: В отличие от конечных автоматов, МП-автоматы используют таблицу переходов, которая определяет правила перехода из одного состояния в другое в зависимости от текущего символа на входе и символа на вершине стека. При переходе автомат может читать входной символ, изменять состояние и выполнять операции со стеком, такие как добавление, удаление или замена символов в магазине.</p></li><li><p>Принятие языков: МП-автоматы используются для определения и распознавания контекстно-свободных языков. Язык принимается МП-автоматом, если существует последовательность переходов и операций со стеком, которая позволяет автомату прочитать входное слово и опустошить магазин, достигнув одного из конечных состояний.</p></li></ol><p>МП-автоматы обладают более высокой вычислительной мощностью по сравнению с конечными автоматами и могут определять и распознавать широкий класс контекстно-свободных языков, что делает их важными в теории формальных языков и компиляторостроении. Однако они также сложнее в анализе и имеют некоторые ограничения в сравнении с машинами Тьюринга.</p></div>"],["Алгоритм абстрактного синтеза автоматов по графу регулярных выражений","<div class=\\"markdown prose w-full break-words dark:prose-invert light\\"><p>Алгоритм абстрактного синтеза автоматов по графу регулярных выражений - это алгоритм, который позволяет построить конечный автомат (конечный детерминированный автомат или КДА) по заданному графу регулярного выражения.</p><p>Основные шаги алгоритма абстрактного синтеза автоматов по графу регулярных выражений:</p><ol><li><p>Построение графа регулярного выражения: Изначально заданное регулярное выражение преобразуется в ориентированный граф, где вершины представляют состояния автомата, а ребра - переходы между состояниями, соответствующими символам регулярного выражения.</p></li><li><p>Преобразование графа: Производятся необходимые преобразования над графом регулярного выражения для оптимизации и упрощения автомата. Это может включать удаление лишних вершин, объединение эквивалентных состояний или другие оптимизации.</p></li><li><p>Построение КДА: На основе преобразованного графа регулярного выражения строится КДА, то есть конечный автомат с детерминированным управлением. Для этого используются алгоритмы, основанные на теории автоматов.</p></li><li><p>Минимизация КДА (опционально): В полученном КДА можно произвести минимизацию, которая позволяет уменьшить число состояний автомата, сохраняя при этом эквивалентность исходного автомата и языка, который он распознает.</p></li><li><p>Завершение: В результате работы алгоритма получается КДА, который распознает язык, соответствующий заданному регулярному выражению.</p></li></ol><p>Алгоритм абстрактного синтеза автоматов по графу регулярных выражений является важным инструментом в теории формальных языков и компиляторостроении. Он позволяет автоматически получать автоматы для распознавания различных языков на основе заданных регулярных выражений, что упрощает разработку программных средств для обработки текстовых данных и поиска шаблонов.</p></div>"],["Анализ сетей Петри","<div class=\\"markdown prose w-full break-words dark:prose-invert light\\"><p>Анализ сетей Петри - это метод и техника анализа дискретных систем, основанных на использовании графической нотации сетей Петри. Сети Петри были предложены Карлом Адамом Петри в 1962 году как формальная модель для описания и анализа параллельных процессов и дискретных систем.</p><p>Основные понятия и элементы сетей Петри:</p><ol><li><p>Позиции (Place): Позиции представляют состояния системы и обозначаются кругами. Они хранят и управляют некоторым количеством \\"маркеров\\" (токенов) и представляют различные состояния системы.</p></li><li><p>Переходы (Transition): Переходы обозначаются прямоугольниками и представляют события или действия, которые могут изменять состояние системы. Переходы могут быть активированы, если все входные позиции имеют достаточное количество маркеров (токенов).</p></li><li><p>Дуги (Arc): Дуги представляют связи между позициями и переходами, а также между переходами и позициями. Они определяют поток токенов между элементами сети.</p></li><li><p>Маркеры (Token): Маркеры представляются на позициях и представляют количественную информацию о состоянии системы.</p></li></ol><p>Основные методы анализа сетей Петри:</p><ol><li><p>Определение ограничений: Сети Петри позволяют выразить ограничения и зависимости между состояниями системы и исследовать их свойства.</p></li><li><p>Определение живости и ограниченности: Анализ сетей Петри позволяет определить, существуют ли такие последовательности переходов, которые могут быть выполнены бесконечное число раз (живость) или количество маркеров в системе ограничено (ограниченность).</p></li><li><p>Поиск мертвых блоков: Мертвые блоки - это состояния, из которых нет возможности достичь других состояний. Анализ сетей Петри позволяет выявить такие блоки и устранить их.</p></li><li><p>Анализ сети на предмет возникновения взаимоблокировок и взаимоисключений: Взаимоблокировки возникают, когда система находится в состоянии, из которого нет возможности выполнить переходы. Взаимоисключения - это ситуация, когда одновременно активируются два перехода, требующих одних и тех же ресурсов.</p></li></ol><p>Анализ сетей Петри является мощным инструментом для моделирования и анализа различных систем и процессов. Он находит применение в различных областях, таких как производственные системы, программирование, параллельные вычисления, дизайн аппаратуры и многое другое.</p></div>"],["Грамматика типа 3 и КА. Построение автомата по левосторонней грамматике","<div class=\\"markdown prose w-full break-words dark:prose-invert light\\"><p>Грамматика типа 3 (регулярная грамматика) и Конечный автомат (КА) - это два важных понятия в теории формальных языков и теории автоматов.</p><ol><li>Грамматика типа 3 (регулярная грамматика):\\nГрамматика типа 3 - это формальная система, которая определяет структуру регулярных языков. Она состоит из четырех компонентов: множества терминальных символов (алфавита), множества нетерминальных символов, стартового символа (один из нетерминалов) и набора правил вывода. Правила вывода задают, как нетерминальные символы заменяются на строки терминальных и нетерминальных символов.</li></ol><p>Грамматика типа 3 обладает следующими ограничениями:</p><ul><li>Правила вывода имеют вид A → aB или A → a, где A и B - нетерминальные символы, а a - терминальный символ.</li><li>Левая часть правила состоит только из одного нетерминала.</li></ul><ol start=\\"2\\"><li>Конечный автомат (КА):\\nКонечный автомат - это абстрактная вычислительная модель, которая состоит из конечного числа состояний и переходов между этими состояниями. КА используется для распознавания и обработки регулярных языков. Он может быть представлен как граф, где вершины - это состояния, а ребра - это переходы между состояниями, обозначающие символы алфавита.</li></ol><p>Построение КА по левосторонней грамматике:\\nДля построения Конечного автомата по левосторонней грамматике можно использовать следующий подход:</p><ol><li>Начальное состояние КА соответствует стартовому символу левосторонней грамматики.</li><li>Для каждого правила вывода вида A → αB, где A и B - нетерминалы, а α - строка терминальных и нетерминальных символов, добавить переход из состояния A в состояние B по символу α.</li><li>Для каждого правила вывода вида A → α, где A - нетерминал, а α - строка терминальных и нетерминальных символов, добавить переход из состояния A в новое состояние по символу α.</li><li>Если стартовый символ A является также и завершающим символом, то состояние A считается завершающим состоянием КА.</li></ol><p>Полученный КА будет распознавать язык, порождаемый левосторонней грамматикой. Таким образом, построение КА по левосторонней грамматике позволяет представить регулярный язык в виде конечного автомата и использовать автоматические методы для его обработки и анализа.</p></div>"],["Грамматика типа 3 и КА. Построение автомата по правосторонней грамматике","<div class=\\"markdown prose w-full break-words dark:prose-invert light\\"><p>Построение автомата по правосторонней грамматике может быть выполнено с использованием конечного автомата (КА), который будет распознавать язык, порождаемый правосторонней грамматикой (регулярный язык). Вот шаги построения КА по правосторонней грамматике:</p><ol><li>Начальное состояние КА соответствует стартовому символу правосторонней грамматики.</li><li>Для каждого правила вывода вида A → β, где A - нетерминал, а β - строка терминальных и нетерминальных символов, добавить переход из состояния A в новое состояние по символу β.</li><li>Для каждого правила вывода вида A → αB, где A и B - нетерминалы, а α - строка терминальных и нетерминальных символов, добавить переход из состояния B в состояние A по символу α.</li><li>Если стартовый символ A является также и завершающим символом, то состояние A считается завершающим состоянием КА.</li></ol><p>После выполнения этих шагов получим конечный автомат, который будет распознавать язык, порождаемый правосторонней грамматикой. Таким образом, построение автомата по правосторонней грамматике позволяет представить регулярный язык в виде конечного автомата и использовать его для распознавания и обработки строк, принадлежащих этому языку.</p></div>"],["Дерево разбора цепочек КС-языков","<div class=\\"markdown prose w-full break-words dark:prose-invert light\\"><p>Дерево разбора цепочки в контекстно-свободных (КС) языках - это структура данных, которая представляет собой дерево, используемое для анализа и разбора цепочек, принадлежащих КС-языку. КС-языки определяются контекстно-свободными грамматиками, и дерево разбора представляет собой структуру, которая показывает, какие правила грамматики были использованы для вывода данной цепочки.</p><p>Шаги построения дерева разбора для цепочки в КС-языках:</p><ol><li>Начните с корневого узла, который будет соответствовать стартовому символу грамматики.</li><li>Проанализируйте входную цепочку, начиная с первого символа.</li><li>Применяйте правила вывода грамматики для замены нетерминальных символов на соответствующие строки терминальных и нетерминальных символов.</li><li>Продолжайте разбор цепочки, заменяя нетерминальные символы, пока не получите исходную цепочку.</li><li>Стройте дерево разбора, добавляя новые узлы и связи для каждого применения правила вывода.</li><li>Повторяйте шаги 2-5 для каждой возможной альтернативы вывода, если они есть.</li></ol><p>В результате, дерево разбора представит структуру вывода данной цепочки в КС-языке. От каждого узла в дереве будут идти дуги к его дочерним узлам, отображающим применение правил грамматики. В итоге, дерево разбора будет показывать структуру предложения и то, как оно может быть получено из грамматики.</p></div>"],["Детерминированный и недетерминированный конечные автоматы. Построение ДКА по НДКА","<div class=\\"markdown prose w-full break-words dark:prose-invert light\\"><p>Детерминированный конечный автомат (ДКА) и недетерминированный конечный автомат (НДКА) - это два различных типа конечных автоматов, которые используются в теории автоматов и формальных языков.</p><ol><li>Детерминированный конечный автомат (ДКА):\\nДКА - это автомат, у которого для каждого состояния и каждого символа в алфавите есть ровно один переход в другое состояние. ДКА представляет собой пятерку (Q, Σ, δ, q₀, F), где:</li></ol><ul><li>Q - множество состояний.</li><li>Σ - алфавит, множество входных символов.</li><li>δ - функция переходов, определяющая, какие состояния будут достигнуты из текущего состояния при входе определенного символа.</li><li>q₀ - начальное состояние, из которого начинается обработка входной цепочки.</li><li>F - множество завершающих (принимающих) состояний.</li></ul><ol start=\\"2\\"><li>Недетерминированный конечный автомат (НДКА):\\nНДКА - это автомат, у которого для каждого состояния и символа в алфавите может быть несколько возможных переходов, и выбор перехода осуществляется недетерминированным образом. НДКА представляет собой пятерку (Q, Σ, δ, q₀, F) с теми же компонентами, что и ДКА.</li></ol><p>Построение ДКА по НДКА (процедура детерминизации):\\nДля построения ДКА по НДКА можно использовать алгоритм под названием \\"подмножества состояний\\". Шаги алгоритма следующие:</p><ol><li>Начальное состояние ДКА - это ε-замыкание (epsilon-closure) начального состояния НДКА.</li><li>Строим таблицу переходов для ДКА. Для каждого символа в алфавите и каждого состояния из ДКА:<ul><li>Находим ε-замыкание всех состояний НДКА, которые достижимы из текущего состояния ДКА по символу.</li><li>Это и будет переходом для данного символа и текущего состояния в ДКА.</li></ul></li><li>Повторяем шаг 2 до тех пор, пока у нас не возникнут новые состояния в ДКА.</li></ol><p>В результате выполнения алгоритма, мы получим ДКА, который распознает тот же язык, что и исходный НДКА. Таким образом, построение ДКА по НДКА позволяет переходить от недетерминированного представления автомата к детерминированному, что упрощает его реализацию и анализ.</p></div>"],["Задание регулярных выражений в форме графов. Правила","<div class=\\"markdown prose w-full break-words dark:prose-invert light\\"><p>Задание регулярных выражений в форме графов можно выполнить с использованием конечных автоматов. Конечные автоматы позволяют представить регулярные выражения в графической форме, где узлы представляют состояния, а ребра - переходы между состояниями по определенным символам.</p><p>Правила задания регулярных выражений в форме графов следующие:</p><ol><li><p>Начальное состояние обозначается одним входящим ребром, не имеющим исходящих ребер. Оно соответствует началу регулярного выражения.</p></li><li><p>Завершающее состояние или состояния обозначаются двойным кружком (или другой маркировкой) и соответствуют концу регулярного выражения.</p></li><li><p>Ребра, исходящие из состояний, помечаются символами из алфавита языка.</p></li><li><p>Каждое ребро помечается символом, который соответствует переходу из одного состояния в другое.</p></li><li><p>Дополнительные состояния могут использоваться для обозначения операций над регулярными выражениями, такими как объединение, конкатенация или звезда Клини.</p></li><li><p>Состояния могут быть объединены посредством ε-переходов (пустых переходов).</p></li><li><p>Каждая часть регулярного выражения (например, символы, операции, группировки) может быть представлена отдельным подграфом.</p></li><li><p>Для обозначения звезды Клини используется замкнутый контур.</p></li></ol><p>После того, как регулярное выражение представлено в форме графа, можно выполнить алгоритмы минимизации или преобразования конечных автоматов для оптимизации структуры регулярного выражения и реализации соответствующего языка. Таким образом, представление регулярных выражений в форме графов предоставляет наглядную и интуитивно понятную визуализацию регулярных языков.</p></div>"],["Классификация языков по Хомскому","<div class=\\"markdown prose w-full break-words dark:prose-invert light\\"><p>Классификация языков по Хомскому основана на иерархии четырех типов формальных грамматик, предложенной американским лингвистом Ноамом Хомским в 1956 году. Эта иерархия включает в себя четыре основных класса языков, которые отличаются по степени сложности и выразительной мощности.</p><ol><li><p>Тип 0: Рекурсивно перечислимые языки (Recursively Enumerable Languages):</p><ul><li>Определяются с помощью машин Тьюринга.</li><li>Могут быть описаны неразрешимыми алгоритмами.</li><li>Включают все языки, которые могут быть распознаны машиной Тьюринга с возможностью остановки, но без ограничений на количество шагов.</li></ul></li><li><p>Тип 1: Контекстно-зависимые языки (Context-Sensitive Languages):</p><ul><li>Определяются с помощью контекстно-зависимых грамматик.</li><li>Правила замены имеют вид α -&gt; β, где α - нетерминал, а β - цепочка символов, включающая α.</li><li>Языки этого типа являются более ограниченными, чем рекурсивно перечислимые, но более выразительными, чем контекстно-свободные.</li></ul></li><li><p>Тип 2: Контекстно-свободные языки (Context-Free Languages):</p><ul><li>Определяются с помощью контекстно-свободных грамматик.</li><li>Правила замены имеют вид A -&gt; γ, где A - нетерминал, а γ - цепочка символов, не зависящая от контекста.</li><li>Включают множество языков, которые используются для описания синтаксиса программ и языков разметки.</li></ul></li><li><p>Тип 3: Регулярные языки (Regular Languages):</p><ul><li>Определяются с помощью регулярных выражений или конечных автоматов.</li><li>Языки этого типа обладают наименьшей выразительной мощностью в иерархии.</li><li>Включают простые языки, такие как регулярные выражения для поиска шаблонов в тексте.</li></ul></li></ol><p>Эта иерархия часто используется в теории формальных языков и компьютерных науках для классификации и изучения различных типов языков и их грамматик.</p></div>"],["Магазинные автоматы и КС-языки","<div class=\\"markdown prose w-full break-words dark:prose-invert light\\"><p>Магазинный автомат (PDA - Pushdown Automaton) - это тип абстрактного вычислительного устройства, который обладает дополнительной магазинной (стековой) памятью. Он является более мощным, чем конечные автоматы, и используется для распознавания контекстно-свободных языков (КС-языков).</p><p>Основные компоненты магазинного автомата:</p><ol><li>Входной алфавит: Множество символов, на которых определен автомат.</li><li>Магазин (стек): Абстрактная память с LIFO (Last-In-First-Out) структурой. В него можно добавлять и извлекать элементы с вершины.</li><li>Контрольное устройство (конечный автомат): Определяет, какие символы считывать с входа и какие переходы выполнять на основе символов входа и текущего состояния.</li><li>Правила переходов (инструкции): Определяют, какие переходы выполнить, основываясь на символах входа, текущем состоянии и содержимом магазина.</li></ol><p>Распознавание КС-языков магазинным автоматом осуществляется следующим образом:</p><ol><li>На вход подается цепочка символов.</li><li>Магазин используется для запоминания информации о структуре цепочки (например, скобки или теги разметки).</li><li>Магазинный автомат может переходить из одного состояния в другое, считывая символы из входа и оперируя содержимым магазина по правилам переходов.</li><li>Если автомат завершает работу в завершающем состоянии и магазин пуст, то цепочка принадлежит языку, иначе она отвергается.</li></ol><p>Магазинные автоматы могут распознавать контекстно-свободные языки, которые не могут быть обработаны конечными автоматами. Они широко используются в компиляторах, обработке языков, синтаксическом анализе и других областях, где требуется работа с более сложными структурами языков.</p></div>"],["Машина Тьюринга и языки типа 0","<div class=\\"markdown prose w-full break-words dark:prose-invert light\\"><p>Машина Тьюринга (Тьюрингова машина) - это абстрактная модель вычислений, предложенная Аланом Тьюрингом в 1936 году. Она является универсальным вычислительным устройством, способным моделировать работу любого алгоритма, который может быть представлен в алгоритмической форме. Машина Тьюринга состоит из бесконечной ленты разделенной на ячейки, головки чтения/записи, алфавита символов, и набора правил перехода.</p><p>Основные компоненты машины Тьюринга:</p><ol><li>Бесконечная лента: Лента разделена на ячейки, каждая из которых может содержать символ из заданного алфавита, включая пустой символ (пустая ячейка).</li><li>Головка чтения/записи: Позиция головки определяет текущую ячейку на ленте, и она может считывать и записывать символы на ленту.</li><li>Алфавит: Множество символов, которые могут быть использованы на ленте, включая символ пустой ячейки.</li><li>Состояния: Конечное множество состояний, в которых может находиться машина. У каждого состояния есть ассоциированные правила перехода.</li><li>Правила перехода: Определяют, как машина должна изменить свое состояние и переместить головку чтения/записи на ленте в зависимости от текущего состояния и символа на ленте, который она считывает.</li></ol><p>Машина Тьюринга может решать различные вычислительные задачи, и ее вычислительная мощность является эквивалентной другим формальным моделям, таким как рекурсивно перечислимые языки (тип 0) или контекстно-свободные языки (тип 2).</p><p>Языки типа 0 - это самый общий класс формальных языков и включают в себя все языки, которые могут быть распознаны машиной Тьюринга. Они также называются рекурсивно перечислимыми языками. Языки типа 0 могут быть заданы с помощью грамматик, машин Тьюринга или других формальных устройств.</p><p>Машина Тьюринга является фундаментальной моделью в теории вычислений и лежит в основе понятий, связанных с вычислимостью и алгоритмами.</p></div>"],["Назначение и общая характеристика сетей Петри","<div class=\\"markdown prose w-full break-words dark:prose-invert light\\"><p>Сети Петри - это формальная модель, используемая для описания и анализа параллельных и конкурентных систем. Они были предложены Карлом Адамом Петри в 1962 году и нашли широкое применение в различных областях, таких как моделирование и анализ систем управления, параллельных вычислений, производственных процессов, компьютерных сетей, и др.</p><p>Назначение сетей Петри:</p><ol><li>Моделирование: Сети Петри позволяют описывать системы с распределенными и параллельными процессами, отображая взаимодействие компонентов системы.</li><li>Анализ: Сети Петри позволяют анализировать динамическое поведение системы, выявлять возможные конфликты и взаимные блокировки.</li><li>Проверка свойств: С помощью сетей Петри можно проверять различные свойства системы, такие как ограниченность ресурсов, достижимость состояний, сохранение свойств и др.</li></ol><p>Общая характеристика сетей Петри:</p><ol><li>Состояния: Сеть Петри состоит из состояний, которые представляют возможные конфигурации системы в различные моменты времени.</li><li>Переходы: Переходы отображают события или операции, которые могут изменять состояние системы.</li><li>Переходные условия: Переходы связаны с условиями, которые должны быть выполнены для их активации.</li><li>Маркировки: Маркировки указывают на текущее состояние системы и представляют распределение ресурсов.</li><li>Дуги: Дуги соединяют состояния с переходами и переходы с состояниями, определяя возможные переходы между состояниями.</li></ol><p>Сети Петри являются удобным инструментом для анализа сложных систем с параллельными и конкурентными процессами. Их простота и наглядность делает их популярным средством для моделирования и анализа различных системных процессов.</p></div>"],["НС-языки. Линейно-ограниченные автоматы","<div class=\\"markdown prose w-full break-words dark:prose-invert light\\"><p>НС-языки (недетерминированные контекстно-свободные языки) - это класс формальных языков, которые могут быть распознаны недетерминированными контекстно-свободными грамматиками. Этот класс языков находится между контекстно-свободными языками и рекурсивно перечислимыми языками по иерархии Хомского.</p><p>НС-грамматика - это формальная система, состоящая из четверки G = (N, Σ, P, S), где:</p><ul><li>N - конечное множество нетерминальных символов,</li><li>Σ - конечное множество терминальных символов (алфавит),</li><li>P - конечное множество правил продукции вида α -&gt; β, где α и β - строки символов из множества N ∪ Σ,</li><li>S - начальный нетерминал, который принадлежит множеству N.</li></ul><p>Линейно-ограниченные автоматы (ЛО-автоматы) - это модель вычислений, которая работает с лентой фиксированной длины. ЛО-автомат является расширением конечного автомата, где лента ограничена, и головка чтения/записи не может двигаться за пределы этой ленты. Ограничение ленты делает эту модель вычислений мощнее конечных автоматов, но менее мощной по сравнению с машинами Тьюринга или НДКА.</p><p>Основные характеристики ЛО-автоматов:</p><ol><li>Ограниченная лента: Лента ограничена и имеет фиксированную длину.</li><li>Головка чтения/записи: Головка может перемещаться только в пределах ленты.</li><li>Правила перехода: Автомат имеет набор правил перехода, которые определяют, как он изменяет своё состояние в зависимости от символа на ленте и текущего состояния.</li></ol><p>Линейно-ограниченные автоматы обладают ограниченной вычислительной мощностью по сравнению с машинами Тьюринга, но они все ещё могут распознавать некоторые интересные классы языков, такие как некоторые контекстно-зависимые языки и языки, которые не являются контекстно-свободными.</p></div>"],["Основные определения теория формальных грамматик","<div class=\\"markdown prose w-full break-words dark:prose-invert light\\"><p>Основные определения в теории формальных грамматик:</p><ol><li><p>Грамматика: Формальная система, состоящая из набора правил, которые определяют, как образовывать строки символов из заданного алфавита. Грамматика используется для задания языка, который представляет собой набор допустимых строк из этого алфавита.</p></li><li><p>Алфавит: Конечное непустое множество символов. Эти символы могут быть буквами, цифрами, знаками пунктуации или любыми другими элементами, которые образуют язык.</p></li><li><p>Строка (цепочка): Последовательность символов из алфавита. Строка может быть пустой (не содержащей символов) или состоять из одного или более символов.</p></li><li><p>Нетерминальный символ: Символ в грамматике, который может заменяться другой строкой (составной символ) согласно правилам грамматики.</p></li><li><p>Терминальный символ: Символ в грамматике, который не может быть заменен другой строкой и является одной из составляющих конечных строк языка.</p></li><li><p>Правило продукции: Правило, определяющее замену нетерминального символа (одной или более нетерминальных символов) на строку, состоящую из терминальных и/или нетерминальных символов. Например, A -&gt; XYZ, где A - нетерминальный символ, а XYZ - строка.</p></li><li><p>Контекстно-свободная грамматика (КС-грамматика): Это тип формальной грамматики, в которой каждое правило продукции состоит из одного нетерминального символа на левой стороне и строки из терминальных и/или нетерминальных символов на правой стороне. Наиболее часто используется для описания контекстно-свободных языков.</p></li><li><p>Контекстно-зависимая грамматика (КЗ-грамматика): Это тип формальной грамматики, в которой правила продукции могут зависеть от контекста, то есть содержания строки слева или справа от заменяемого нетерминала.</p></li><li><p>Регулярная грамматика: Это тип формальной грамматики, где правила продукции имеют ограничения на вид и порядок замены нетерминальных символов, что позволяет описывать регулярные языки.</p></li></ol><p>Эти определения являются основой для изучения формальных грамматик и различных классов языков, которые они могут описывать и порождать.</p></div>"],["Понятие автомата. Модель автомата Мили, Мура","<div class=\\"markdown prose w-full break-words dark:prose-invert light\\"><p>Автомат - это устройство или вычислительная модель, способная принимать входные данные (символы, последовательности символов) и выполнять определенные действия на основе этих данных согласно заданным правилам. Автоматы широко используются в теории автоматов и формальных языков для описания и распознавания различных языков.</p><p>Модель автомата определяется тремя основными компонентами:</p><ol><li><p>Входной алфавит (Input Alphabet): Это конечное непустое множество символов, которые могут быть прочитаны автоматом.</p></li><li><p>Множество состояний (Set of States): Это конечное множество состояний, в которых может находиться автомат в определенный момент времени.</p></li><li><p>Переходы (Transitions): Это функция, которая определяет, как автомат переходит из одного состояния в другое при чтении входных символов. Переходы определяются для каждой комбинации состояния и символа входного алфавита.</p></li></ol><p>На основе различных характеристик переходов и выходных значений, существуют две основные модели автоматов: автомат Мили и автомат Мура.</p><p>Автомат Мили (Mealy Automaton):</p><ul><li>В автомате Мили, выходные значения (ответы) зависят не только от текущего состояния, но и от входного символа.</li><li>Каждый переход имеет связанный с ним выходной символ, который определяется входным символом и текущим состоянием.</li><li>Формально, автомат Мили представляется как кортеж (Q, Σ, δ, λ, q0), где:\\nQ - множество состояний,\\nΣ - входной алфавит,\\nδ - функция переходов, δ: Q × Σ → Q,\\nλ - функция выходов, λ: Q × Σ → Λ, где Λ - множество выходных символов,\\nq0 - начальное состояние.</li></ul><p>Автомат Мура (Moore Automaton):</p><ul><li>В автомате Мура, выходные значения (ответы) зависят только от текущего состояния, независимо от входного символа.</li><li>Каждое состояние имеет связанный с ним выходной символ, который определяет выходное значение для данного состояния.</li><li>Формально, автомат Мура представляется как кортеж (Q, Σ, δ, λ, q0), где:\\nQ - множество состояний,\\nΣ - входной алфавит,\\nδ - функция переходов, δ: Q × Σ → Q,\\nλ - функция выходов, λ: Q → Λ, где Λ - множество выходных символов,\\nq0 - начальное состояние.</li></ul><p>Оба вида автоматов, Мили и Мура, имеют свои особенности и применения в различных областях, таких как распознавание языков, управление системами и другие задачи, связанные с обработкой информации.</p></div>"],["Примеры сетей Петри","<div class=\\"markdown prose w-full break-words dark:prose-invert light\\"><p>Примеры сетей Петри:</p><ol><li><p>Производственная система: Сеть Петри может использоваться для моделирования производственных систем, где места представляют состояния системы, а переходы отражают операции и переходы между состояниями производственного процесса.</p></li><li><p>Протоколы связи: Сети Петри применяются для анализа и проектирования протоколов связи в компьютерных сетях. Места представляют состояния системы, а переходы моделируют передачу данных или события в сети.</p></li><li><p>Параллельные вычисления: Сети Петри могут использоваться для моделирования параллельных вычислений и распределенных систем. Места могут представлять состояния процессов, а переходы — события или смену состояний.</p></li><li><p>Системы массового обслуживания: Сети Петри могут быть использованы для анализа производительности и оптимизации систем массового обслуживания, таких как телефонные сети или компьютерные серверы.</p></li><li><p>Программное обеспечение: Сети Петри можно применять для анализа и верификации программного обеспечения, моделирования последовательности действий и возможных состояний программы.</p></li></ol><p>Это лишь некоторые примеры, и сети Петри находят применение в различных областях, где необходимо анализировать состояния и переходы между ними.</p></div>"],["Регулярные выражения","<div class=\\"markdown prose w-full break-words dark:prose-invert light\\"><p>Регулярные выражения (Regular expressions) — это формальный язык для описания текстовых шаблонов. Они используются для поиска, сопоставления и обработки текстовой информации. В регулярных выражениях символы представляют определенные классы символов или операции, позволяющие выполнять сложные операции со строками.</p><p>Примеры регулярных выражений:</p><ol><li><p><strong>Простой текст:</strong> Простейшее регулярное выражение — это просто последовательность символов, которую оно ищет в тексте. Например, регулярное выражение \\"hello\\" найдет в тексте строку \\"hello\\".</p></li><li><p><strong>Символы-метасимволы:</strong> В регулярных выражениях некоторые символы имеют специальное значение и называются метасимволами. Например, символ \\".\\" соответствует любому одиночному символу, а символ \\"^\\" обозначает начало строки.</p></li><li><p><strong>Классы символов:</strong> Классы символов позволяют задавать группы символов, из которых должен выбираться один символ. Например, выражение \\"[aeiou]\\" найдет любую гласную букву в тексте.</p></li><li><p><strong>Квантификаторы:</strong> Квантификаторы определяют количество повторений предыдущего элемента. Например, выражение \\"a{2,4}\\" найдет последовательность из 2, 3 или 4 букв \\"a\\".</p></li><li><p><strong>Инвертированные классы символов:</strong> Инвертированные классы символов позволяют искать любой символ, не входящий в указанный класс. Например, выражение \\"[^0-9]\\" найдет любой символ, не являющийся цифрой.</p></li><li><p><strong>Альтернативы:</strong> Альтернативы позволяют задать несколько вариантов для поиска. Например, выражение \\"cat|dog\\" найдет либо \\"cat\\", либо \\"dog\\".</p></li><li><p><strong>Якоря:</strong> Якоря указывают позиции в тексте, например, начало строки \\"^\\" или конец строки \\"$\\". Выражение \\"^hello\\" найдет строку, которая начинается с \\"hello\\".</p></li></ol><p>Регулярные выражения являются мощным инструментом для работы с текстом и позволяют выполнять разнообразные операции, такие как поиск, замена, извлечение информации и многое другое. Они широко используются в программировании, редакторах текста, поисковых системах и других приложениях, где требуется работа с текстовыми данными.</p></div>"],["Регулярные грамматики и конечные автоматы","<div class=\\"markdown prose w-full break-words dark:prose-invert light\\"><p>Регулярные грамматики и конечные автоматы связаны между собой и используются для описания и обработки регулярных языков. Рассмотрим связь между ними:</p><p><strong>Регулярная грамматика:</strong>\\nРегулярная грамматика является типом формальной грамматики, определяющей регулярный язык. Регулярные грамматики состоят из продукций (правил вывода), которые имеют простую форму и позволяют порождать строки определенного формата.</p><p>Пример регулярной грамматики:</p><pre><div class=\\"bg-black rounded-md mb-4\\"><div class=\\"flex items-center relative text-gray-200 bg-gray-800 px-4 py-2 text-xs font-sans justify-between rounded-t-md\\"><span>rust</span><button class=\\"flex ml-auto gap-2\\"><svg stroke=\\"currentColor\\" fill=\\"none\\" stroke-width=\\"2\\" viewBox=\\"0 0 24 24\\" stroke-linecap=\\"round\\" stroke-linejoin=\\"round\\" class=\\"h-4 w-4\\" height=\\"1em\\" width=\\"1em\\" xmlns=\\"http://www.w3.org/2000/svg\\"><path d=\\"M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2\\"></path><rect x=\\"8\\" y=\\"2\\" width=\\"8\\" height=\\"4\\" rx=\\"1\\" ry=\\"1\\"></rect></svg>Copy code</button></div><div class=\\"p-4 overflow-y-auto\\"><code class=\\"!whitespace-pre hljs language-rust\\">S <span class=\\"hljs-punctuation\\">-&gt;</span> <span class=\\"hljs-number\\">0</span>A | <span class=\\"hljs-number\\">1</span>B | ε\\nA <span class=\\"hljs-punctuation\\">-&gt;</span> <span class=\\"hljs-number\\">0</span>A | <span class=\\"hljs-number\\">1</span>A | <span class=\\"hljs-number\\">0</span>\\nB <span class=\\"hljs-punctuation\\">-&gt;</span> <span class=\\"hljs-number\\">0</span>B | <span class=\\"hljs-number\\">1</span>B | <span class=\\"hljs-number\\">1</span>\\n</code></div></div></pre><p>Здесь <code>S</code>, <code>A</code> и <code>B</code> - нетерминальные символы, а <code>0</code>, <code>1</code> и <code>ε</code> - терминальные символы (терминалы представляют собой символы из алфавита языка, а <code>ε</code> обозначает пустую строку). Эта грамматика порождает регулярный язык, состоящий из всех строк, составленных из нулей и единиц, которые заканчиваются на <code>0</code> или <code>1</code>.</p><p><strong>Конечный автомат:</strong>\\nКонечный автомат (или конечный автомат без хранилища - DFA) - это абстрактная вычислительная машина, которая может находиться в одном из конечного числа состояний и переходить между состояниями в соответствии с входными символами. Конечный автомат может быть представлен как ориентированный граф, где вершины представляют состояния, а переходы между состояниями обозначаются символами из алфавита языка.</p><p>Пример конечного автомата для регулярного языка 0*1:</p><pre><div class=\\"bg-black rounded-md mb-4\\"><div class=\\"flex items-center relative text-gray-200 bg-gray-800 px-4 py-2 text-xs font-sans justify-between rounded-t-md\\"><span>scss</span><button class=\\"flex ml-auto gap-2\\"><svg stroke=\\"currentColor\\" fill=\\"none\\" stroke-width=\\"2\\" viewBox=\\"0 0 24 24\\" stroke-linecap=\\"round\\" stroke-linejoin=\\"round\\" class=\\"h-4 w-4\\" height=\\"1em\\" width=\\"1em\\" xmlns=\\"http://www.w3.org/2000/svg\\"><path d=\\"M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2\\"></path><rect x=\\"8\\" y=\\"2\\" width=\\"8\\" height=\\"4\\" rx=\\"1\\" ry=\\"1\\"></rect></svg>Copy code</button></div><div class=\\"p-4 overflow-y-auto\\"><code class=\\"!whitespace-pre hljs language-scss\\">   --- <span class=\\"hljs-number\\">0</span> --&gt; (q1)\\n  |        /\\n  |       / \\n  |      /\\n  |     / <span class=\\"hljs-number\\">1</span>\\n  V   V\\n (start)-----&gt; (accepting)\\n</code></div></div></pre><p>В этом примере, автомат имеет два состояния: <code>start</code> - начальное состояние и <code>accepting</code> - принимающее состояние. Он может переходить из начального состояния в принимающее состояние только по символу <code>1</code>, а по символу <code>0</code> остается в начальном состоянии.</p><p><strong>Связь между регулярными грамматиками и конечными автоматами:</strong>\\nРегулярные грамматики и конечные автоматы эквивалентны в том смысле, что для любого регулярного языка существует соответствующая регулярная грамматика и эквивалентный конечный автомат, и наоборот. Это свойство называется <strong>теоремой Клини</strong>.</p><p>Таким образом, регулярные грамматики и конечные автоматы являются двумя формальными способами описания одной и той же класса языков - регулярных языков. Они часто используются в теории формальных языков, компиляторах, лексическом анализе и других областях информатики для работы с регулярными языками и текстовыми шаблонами.</p></div>"],["Соединение автоматов. Параллельное соединение","<div class=\\"markdown prose w-full break-words dark:prose-invert light\\"><p><strong>Соединение автоматов</strong> - это процесс объединения двух или более автоматов для получения нового автомата, который обладает свойствами составных автоматов. Соединение автоматов позволяет комбинировать функциональность различных автоматов для решения более сложных задач.</p><p><strong>Параллельное соединение</strong> - это один из методов соединения автоматов, при котором два или более автомата работают независимо друг от друга, их входы и выходы объединяются, а переходы и состояния остаются независимыми. Результатом параллельного соединения является автомат, который выполняет операции сразу над несколькими автоматами, обрабатывая входы параллельно.</p><p><strong>Пример параллельного соединения:</strong></p><p>Предположим, у нас есть два автомата A и B, которые распознают языки L1 и L2 соответственно.</p><p><strong>Автомат A:</strong></p><pre><div class=\\"bg-black rounded-md mb-4\\"><div class=\\"flex items-center relative text-gray-200 bg-gray-800 px-4 py-2 text-xs font-sans justify-between rounded-t-md\\"><span>yaml</span><button class=\\"flex ml-auto gap-2\\"><svg stroke=\\"currentColor\\" fill=\\"none\\" stroke-width=\\"2\\" viewBox=\\"0 0 24 24\\" stroke-linecap=\\"round\\" stroke-linejoin=\\"round\\" class=\\"h-4 w-4\\" height=\\"1em\\" width=\\"1em\\" xmlns=\\"http://www.w3.org/2000/svg\\"><path d=\\"M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2\\"></path><rect x=\\"8\\" y=\\"2\\" width=\\"8\\" height=\\"4\\" rx=\\"1\\" ry=\\"1\\"></rect></svg>Copy code</button></div><div class=\\"p-4 overflow-y-auto\\"><code class=\\"!whitespace-pre hljs language-yaml\\"><span class=\\"hljs-attr\\">Alphabet:</span> {<span class=\\"hljs-string\\">a</span>, <span class=\\"hljs-string\\">b</span>}\\n<span class=\\"hljs-attr\\">States:</span> {<span class=\\"hljs-string\\">q0</span>, <span class=\\"hljs-string\\">q1</span>}\\n<span class=\\"hljs-attr\\">Start state:</span> <span class=\\"hljs-string\\">q0</span>\\n<span class=\\"hljs-attr\\">Accepting state:</span> <span class=\\"hljs-string\\">q1</span>\\n<span class=\\"hljs-attr\\">Transitions:</span>\\n<span class=\\"hljs-string\\">(q0,</span> <span class=\\"hljs-string\\">a)</span> <span class=\\"hljs-string\\">-&gt;</span> <span class=\\"hljs-string\\">q1</span>\\n<span class=\\"hljs-string\\">(q0,</span> <span class=\\"hljs-string\\">b)</span> <span class=\\"hljs-string\\">-&gt;</span> <span class=\\"hljs-string\\">q0</span>\\n<span class=\\"hljs-string\\">(q1,</span> <span class=\\"hljs-string\\">a)</span> <span class=\\"hljs-string\\">-&gt;</span> <span class=\\"hljs-string\\">q1</span>\\n<span class=\\"hljs-string\\">(q1,</span> <span class=\\"hljs-string\\">b)</span> <span class=\\"hljs-string\\">-&gt;</span> <span class=\\"hljs-string\\">q0</span>\\n</code></div></div></pre><p><strong>Автомат B:</strong></p><pre><div class=\\"bg-black rounded-md mb-4\\"><div class=\\"flex items-center relative text-gray-200 bg-gray-800 px-4 py-2 text-xs font-sans justify-between rounded-t-md\\"><span>yaml</span><button class=\\"flex ml-auto gap-2\\"><svg stroke=\\"currentColor\\" fill=\\"none\\" stroke-width=\\"2\\" viewBox=\\"0 0 24 24\\" stroke-linecap=\\"round\\" stroke-linejoin=\\"round\\" class=\\"h-4 w-4\\" height=\\"1em\\" width=\\"1em\\" xmlns=\\"http://www.w3.org/2000/svg\\"><path d=\\"M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2\\"></path><rect x=\\"8\\" y=\\"2\\" width=\\"8\\" height=\\"4\\" rx=\\"1\\" ry=\\"1\\"></rect></svg>Copy code</button></div><div class=\\"p-4 overflow-y-auto\\"><code class=\\"!whitespace-pre hljs language-yaml\\"><span class=\\"hljs-attr\\">Alphabet:</span> {<span class=\\"hljs-number\\">0</span>, <span class=\\"hljs-number\\">1</span>}\\n<span class=\\"hljs-attr\\">States:</span> {<span class=\\"hljs-string\\">s0</span>, <span class=\\"hljs-string\\">s1</span>}\\n<span class=\\"hljs-attr\\">Start state:</span> <span class=\\"hljs-string\\">s0</span>\\n<span class=\\"hljs-attr\\">Accepting state:</span> <span class=\\"hljs-string\\">s1</span>\\n<span class=\\"hljs-attr\\">Transitions:</span>\\n<span class=\\"hljs-string\\">(s0,</span> <span class=\\"hljs-number\\">0</span><span class=\\"hljs-string\\">)</span> <span class=\\"hljs-string\\">-&gt;</span> <span class=\\"hljs-string\\">s0</span>\\n<span class=\\"hljs-string\\">(s0,</span> <span class=\\"hljs-number\\">1</span><span class=\\"hljs-string\\">)</span> <span class=\\"hljs-string\\">-&gt;</span> <span class=\\"hljs-string\\">s1</span>\\n<span class=\\"hljs-string\\">(s1,</span> <span class=\\"hljs-number\\">0</span><span class=\\"hljs-string\\">)</span> <span class=\\"hljs-string\\">-&gt;</span> <span class=\\"hljs-string\\">s0</span>\\n<span class=\\"hljs-string\\">(s1,</span> <span class=\\"hljs-number\\">1</span><span class=\\"hljs-string\\">)</span> <span class=\\"hljs-string\\">-&gt;</span> <span class=\\"hljs-string\\">s1</span>\\n</code></div></div></pre><p>Теперь соединим автоматы A и B параллельно, чтобы получить новый автомат C.</p><p><strong>Параллельное соединение C:</strong></p><pre><div class=\\"bg-black rounded-md mb-4\\"><div class=\\"flex items-center relative text-gray-200 bg-gray-800 px-4 py-2 text-xs font-sans justify-between rounded-t-md\\"><span>rust</span><button class=\\"flex ml-auto gap-2\\"><svg stroke=\\"currentColor\\" fill=\\"none\\" stroke-width=\\"2\\" viewBox=\\"0 0 24 24\\" stroke-linecap=\\"round\\" stroke-linejoin=\\"round\\" class=\\"h-4 w-4\\" height=\\"1em\\" width=\\"1em\\" xmlns=\\"http://www.w3.org/2000/svg\\"><path d=\\"M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2\\"></path><rect x=\\"8\\" y=\\"2\\" width=\\"8\\" height=\\"4\\" rx=\\"1\\" ry=\\"1\\"></rect></svg>Copy code</button></div><div class=\\"p-4 overflow-y-auto\\"><code class=\\"!whitespace-pre hljs language-rust\\">Alphabet: {a, b, <span class=\\"hljs-number\\">0</span>, <span class=\\"hljs-number\\">1</span>}\\nStates: {(q0, s0), (q0, s1), (q1, s0), (q1, s1)}\\nStart state: (q0, s0)\\nAccepting states: {(q1, s1)}\\nTransitions:\\n((q0, s0), a) <span class=\\"hljs-punctuation\\">-&gt;</span> (q1, s0)\\n((q0, s0), b) <span class=\\"hljs-punctuation\\">-&gt;</span> (q0, s0)\\n((q0, s0), <span class=\\"hljs-number\\">0</span>) <span class=\\"hljs-punctuation\\">-&gt;</span> (q0, s0)\\n((q0, s0), <span class=\\"hljs-number\\">1</span>) <span class=\\"hljs-punctuation\\">-&gt;</span> (q1, s1)\\n((q0, s1), a) <span class=\\"hljs-punctuation\\">-&gt;</span> (q1, s1)\\n((q0, s1), b) <span class=\\"hljs-punctuation\\">-&gt;</span> (q0, s0)\\n((q0, s1), <span class=\\"hljs-number\\">0</span>) <span class=\\"hljs-punctuation\\">-&gt;</span> (q0, s0)\\n((q0, s1), <span class=\\"hljs-number\\">1</span>) <span class=\\"hljs-punctuation\\">-&gt;</span> (q1, s1)\\n((q1, s0), a) <span class=\\"hljs-punctuation\\">-&gt;</span> (q1, s0)\\n((q1, s0), b) <span class=\\"hljs-punctuation\\">-&gt;</span> (q0, s0)\\n((q1, s0), <span class=\\"hljs-number\\">0</span>) <span class=\\"hljs-punctuation\\">-&gt;</span> (q1, s0)\\n((q1, s0), <span class=\\"hljs-number\\">1</span>) <span class=\\"hljs-punctuation\\">-&gt;</span> (q1, s1)\\n((q1, s1), a) <span class=\\"hljs-punctuation\\">-&gt;</span> (q1, s1)\\n((q1, s1), b) <span class=\\"hljs-punctuation\\">-&gt;</span> (q0, s0)\\n((q1, s1), <span class=\\"hljs-number\\">0</span>) <span class=\\"hljs-punctuation\\">-&gt;</span> (q1, s0)\\n((q1, s1), <span class=\\"hljs-number\\">1</span>) <span class=\\"hljs-punctuation\\">-&gt;</span> (q1, s1)\\n</code></div></div></pre><p>Таким образом, автомат C получен путем параллельного соединения автоматов A и B. Он может обрабатывать входные символы из объединенных алфавитов и выполнять операции, которые происходят независимо друг от друга в автоматах A и B.</p></div>"],["Способы задания абстрактных автоматов","<div class=\\"markdown prose w-full break-words dark:prose-invert light\\"><p>Существует несколько способов задания абстрактных автоматов, каждый из которых предоставляет формальный способ описания структуры и поведения автомата. Вот некоторые из способов задания абстрактных автоматов:</p><ol><li><p><strong>Конечные автоматы (Finite Automata):</strong> Конечные автоматы могут быть заданы с помощью:</p><ul><li>Диаграмм переходов (Transition diagrams): Графическое представление состояний и переходов автомата с помощью вершин и стрелок.</li><li>Таблиц переходов (Transition tables): Таблицы, которые описывают состояния и переходы автомата в виде матрицы.</li><li>Регулярные выражения (Regular expressions): Описывают язык, распознаваемый автоматом, в виде шаблона из регулярных операций.</li></ul></li><li><p><strong>Конечные автоматы с магазинной памятью (Pushdown Automata):</strong> Конечные автоматы с магазинной памятью описываются с помощью:</p><ul><li>Диаграмм переходов с магазином (Pushdown Transition diagrams): Графическое представление с добавлением стека или магазина для хранения символов.</li><li>Таблиц переходов с магазином (Pushdown Transition tables): Таблицы переходов, в которых также учитывается состояние стека.</li></ul></li><li><p><strong>Машины Тьюринга (Turing Machines):</strong> Машины Тьюринга задаются с помощью:</p><ul><li>Таблиц переходов Тьюринга (Turing Transition tables): Таблицы, которые определяют правила перехода машины Тьюринга из одного состояния в другое на основе текущего символа и внутреннего состояния.</li><li>Функции переходов (Transition functions): Математические функции, определяющие переходы в зависимости от текущего состояния и символа на ленте.</li></ul></li><li><p><strong>Другие формальные языки:</strong> Абстрактные автоматы могут быть заданы с помощью различных формальных языков, таких как регулярные грамматики, контекстно-свободные грамматики и другие, которые определяют правила для обработки символов или строк.</p></li></ol><p>Каждый из этих способов задания предоставляет удобные инструменты для описания различных классов автоматов и их функциональности. Выбор конкретного способа зависит от конкретной задачи, которую нужно решить, и требований к модели автомата.</p></div>"],["Способы задания сетей Петри","<div class=\\"markdown prose w-full break-words dark:prose-invert light\\"><p>Сети Петри — это графические модели, используемые для представления параллельных и распределенных систем, производственных процессов, протоколов связи и других систем, которые включают в себя параллельные процессы и взаимодействия. Существуют различные способы задания сетей Петри, позволяющие создавать и анализировать такие модели. Ниже представлены основные способы задания сетей Петри:</p><ol><li><p><strong>Графический способ:</strong> Сети Петри могут быть изображены в виде графических диаграмм, которые состоят из двух основных элементов: переходов и позиций. Позиции представляют состояния системы, а переходы — события или операции, которые могут изменять состояние системы. Дуги связывают переходы с позициями и определяют потоки ресурсов или событий между ними.</p></li><li><p><strong>Матричный способ:</strong> В матричном способе задания сетей Петри используются матрицы для представления множества переходов, позиций и дуг. Например, можно использовать матрицу инцидентности для отображения связей между переходами и позициями, матрицу маркировки для представления текущего состояния системы и т.д.</p></li><li><p><strong>Эквивалентный язык программирования:</strong> Существуют специальные языки программирования, такие как CPN (Coloured Petri Nets), язык Petri Nets Markup Language (PNML) и др., которые позволяют описывать сети Петри в текстовом формате. Эти языки предоставляют стандартные синтаксисы для описания сетей Петри и их свойств.</p></li><li><p><strong>Интерактивные инструменты:</strong> Существуют программные инструменты и программы для создания сетей Петри с помощью интерактивных средств. В таких инструментах пользователи могут создавать сети Петри с помощью графических элементов и настраивать их свойства.</p></li><li><p><strong>Фреймворки моделирования:</strong> Сети Петри могут быть заданы с использованием фреймворков моделирования, таких как CPN Tools, PIPE (Platform Independent Petri Net Editor) и другие. Эти фреймворки предоставляют средства для создания, анализа и визуализации сетей Петри.</p></li></ol><p>Выбор способа задания сетей Петри зависит от предпочтений пользователя, сложности модели и доступных инструментов для анализа и работы с сетью Петри. Графический способ обычно более понятен для начинающих пользователей, в то время как использование языков программирования и фреймворков предоставляет большую гибкость и возможности для анализа и симуляции.</p></div>"],["Способы соединения конечных автоматов. Параллельное соединение","<div class=\\"markdown prose w-full break-words dark:prose-invert light\\"><p>Существует несколько способов соединения конечных автоматов, которые позволяют комбинировать несколько автоматов в один для выполнения более сложных задач. Один из таких способов - <strong>параллельное соединение</strong> конечных автоматов.</p><p><strong>Параллельное соединение (Parallel Composition):</strong>\\nПараллельное соединение - это один из методов соединения конечных автоматов, при котором два или более автомата работают независимо друг от друга, их входы и выходы объединяются, а переходы и состояния остаются независимыми.</p><p>Предположим, у нас есть два конечных автомата A и B:</p><p><strong>Автомат A:</strong></p><pre><div class=\\"bg-black rounded-md mb-4\\"><div class=\\"flex items-center relative text-gray-200 bg-gray-800 px-4 py-2 text-xs font-sans justify-between rounded-t-md\\"><span>yaml</span><button class=\\"flex ml-auto gap-2\\"><svg stroke=\\"currentColor\\" fill=\\"none\\" stroke-width=\\"2\\" viewBox=\\"0 0 24 24\\" stroke-linecap=\\"round\\" stroke-linejoin=\\"round\\" class=\\"h-4 w-4\\" height=\\"1em\\" width=\\"1em\\" xmlns=\\"http://www.w3.org/2000/svg\\"><path d=\\"M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2\\"></path><rect x=\\"8\\" y=\\"2\\" width=\\"8\\" height=\\"4\\" rx=\\"1\\" ry=\\"1\\"></rect></svg>Copy code</button></div><div class=\\"p-4 overflow-y-auto\\"><code class=\\"!whitespace-pre hljs language-yaml\\"><span class=\\"hljs-attr\\">Alphabet:</span> {<span class=\\"hljs-string\\">a</span>, <span class=\\"hljs-string\\">b</span>}\\n<span class=\\"hljs-attr\\">States:</span> {<span class=\\"hljs-string\\">q0</span>, <span class=\\"hljs-string\\">q1</span>}\\n<span class=\\"hljs-attr\\">Start state:</span> <span class=\\"hljs-string\\">q0</span>\\n<span class=\\"hljs-attr\\">Accepting state:</span> <span class=\\"hljs-string\\">q1</span>\\n<span class=\\"hljs-attr\\">Transitions:</span>\\n<span class=\\"hljs-string\\">(q0,</span> <span class=\\"hljs-string\\">a)</span> <span class=\\"hljs-string\\">-&gt;</span> <span class=\\"hljs-string\\">q1</span>\\n<span class=\\"hljs-string\\">(q0,</span> <span class=\\"hljs-string\\">b)</span> <span class=\\"hljs-string\\">-&gt;</span> <span class=\\"hljs-string\\">q0</span>\\n<span class=\\"hljs-string\\">(q1,</span> <span class=\\"hljs-string\\">a)</span> <span class=\\"hljs-string\\">-&gt;</span> <span class=\\"hljs-string\\">q1</span>\\n<span class=\\"hljs-string\\">(q1,</span> <span class=\\"hljs-string\\">b)</span> <span class=\\"hljs-string\\">-&gt;</span> <span class=\\"hljs-string\\">q0</span>\\n</code></div></div></pre><p><strong>Автомат B:</strong></p><pre><div class=\\"bg-black rounded-md mb-4\\"><div class=\\"flex items-center relative text-gray-200 bg-gray-800 px-4 py-2 text-xs font-sans justify-between rounded-t-md\\"><span>yaml</span><button class=\\"flex ml-auto gap-2\\"><svg stroke=\\"currentColor\\" fill=\\"none\\" stroke-width=\\"2\\" viewBox=\\"0 0 24 24\\" stroke-linecap=\\"round\\" stroke-linejoin=\\"round\\" class=\\"h-4 w-4\\" height=\\"1em\\" width=\\"1em\\" xmlns=\\"http://www.w3.org/2000/svg\\"><path d=\\"M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2\\"></path><rect x=\\"8\\" y=\\"2\\" width=\\"8\\" height=\\"4\\" rx=\\"1\\" ry=\\"1\\"></rect></svg>Copy code</button></div><div class=\\"p-4 overflow-y-auto\\"><code class=\\"!whitespace-pre hljs language-yaml\\"><span class=\\"hljs-attr\\">Alphabet:</span> {<span class=\\"hljs-number\\">0</span>, <span class=\\"hljs-number\\">1</span>}\\n<span class=\\"hljs-attr\\">States:</span> {<span class=\\"hljs-string\\">s0</span>, <span class=\\"hljs-string\\">s1</span>}\\n<span class=\\"hljs-attr\\">Start state:</span> <span class=\\"hljs-string\\">s0</span>\\n<span class=\\"hljs-attr\\">Accepting state:</span> <span class=\\"hljs-string\\">s1</span>\\n<span class=\\"hljs-attr\\">Transitions:</span>\\n<span class=\\"hljs-string\\">(s0,</span> <span class=\\"hljs-number\\">0</span><span class=\\"hljs-string\\">)</span> <span class=\\"hljs-string\\">-&gt;</span> <span class=\\"hljs-string\\">s0</span>\\n<span class=\\"hljs-string\\">(s0,</span> <span class=\\"hljs-number\\">1</span><span class=\\"hljs-string\\">)</span> <span class=\\"hljs-string\\">-&gt;</span> <span class=\\"hljs-string\\">s1</span>\\n<span class=\\"hljs-string\\">(s1,</span> <span class=\\"hljs-number\\">0</span><span class=\\"hljs-string\\">)</span> <span class=\\"hljs-string\\">-&gt;</span> <span class=\\"hljs-string\\">s0</span>\\n<span class=\\"hljs-string\\">(s1,</span> <span class=\\"hljs-number\\">1</span><span class=\\"hljs-string\\">)</span> <span class=\\"hljs-string\\">-&gt;</span> <span class=\\"hljs-string\\">s1</span>\\n</code></div></div></pre><p>Теперь объединим автоматы A и B параллельно, чтобы получить новый автомат C.</p><p><strong>Параллельное соединение C:</strong></p><pre><div class=\\"bg-black rounded-md mb-4\\"><div class=\\"flex items-center relative text-gray-200 bg-gray-800 px-4 py-2 text-xs font-sans justify-between rounded-t-md\\"><span>rust</span><button class=\\"flex ml-auto gap-2\\"><svg stroke=\\"currentColor\\" fill=\\"none\\" stroke-width=\\"2\\" viewBox=\\"0 0 24 24\\" stroke-linecap=\\"round\\" stroke-linejoin=\\"round\\" class=\\"h-4 w-4\\" height=\\"1em\\" width=\\"1em\\" xmlns=\\"http://www.w3.org/2000/svg\\"><path d=\\"M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2\\"></path><rect x=\\"8\\" y=\\"2\\" width=\\"8\\" height=\\"4\\" rx=\\"1\\" ry=\\"1\\"></rect></svg>Copy code</button></div><div class=\\"p-4 overflow-y-auto\\"><code class=\\"!whitespace-pre hljs language-rust\\">Alphabet: {a, b, <span class=\\"hljs-number\\">0</span>, <span class=\\"hljs-number\\">1</span>}\\nStates: {(q0, s0), (q0, s1), (q1, s0), (q1, s1)}\\nStart state: (q0, s0)\\nAccepting states: {(q1, s1)}\\nTransitions:\\n((q0, s0), a) <span class=\\"hljs-punctuation\\">-&gt;</span> (q1, s0)\\n((q0, s0), b) <span class=\\"hljs-punctuation\\">-&gt;</span> (q0, s0)\\n((q0, s0), <span class=\\"hljs-number\\">0</span>) <span class=\\"hljs-punctuation\\">-&gt;</span> (q0, s0)\\n((q0, s0), <span class=\\"hljs-number\\">1</span>) <span class=\\"hljs-punctuation\\">-&gt;</span> (q1, s1)\\n((q0, s1), a) <span class=\\"hljs-punctuation\\">-&gt;</span> (q1, s1)\\n((q0, s1), b) <span class=\\"hljs-punctuation\\">-&gt;</span> (q0, s0)\\n((q0, s1), <span class=\\"hljs-number\\">0</span>) <span class=\\"hljs-punctuation\\">-&gt;</span> (q0, s0)\\n((q0, s1), <span class=\\"hljs-number\\">1</span>) <span class=\\"hljs-punctuation\\">-&gt;</span> (q1, s1)\\n((q1, s0), a) <span class=\\"hljs-punctuation\\">-&gt;</span> (q1, s0)\\n((q1, s0), b) <span class=\\"hljs-punctuation\\">-&gt;</span> (q0, s0)\\n((q1, s0), <span class=\\"hljs-number\\">0</span>) <span class=\\"hljs-punctuation\\">-&gt;</span> (q1, s0)\\n((q1, s0), <span class=\\"hljs-number\\">1</span>) <span class=\\"hljs-punctuation\\">-&gt;</span> (q1, s1)\\n((q1, s1), a) <span class=\\"hljs-punctuation\\">-&gt;</span> (q1, s1)\\n((q1, s1), b) <span class=\\"hljs-punctuation\\">-&gt;</span> (q0, s0)\\n((q1, s1), <span class=\\"hljs-number\\">0</span>) <span class=\\"hljs-punctuation\\">-&gt;</span> (q1, s0)\\n((q1, s1), <span class=\\"hljs-number\\">1</span>) <span class=\\"hljs-punctuation\\">-&gt;</span> (q1, s1)\\n</code></div></div></pre><p>Таким образом, автомат C получен путем параллельного соединения автоматов A и B. Он может обрабатывать входные символы из объединенных алфавитов и выполнять операции, которые происходят независимо друг от друга в автоматах A и B.</p></div>"],["Способы соединения конечных автоматов. Соединение с обратной связью","<div class=\\"markdown prose w-full break-words dark:prose-invert light\\"><p><strong>Соединение с обратной связью (Feedback Concatenation):</strong></p><p>Соединение с обратной связью - это метод соединения конечных автоматов, который позволяет создавать автоматы с циклическим поведением или обратной связью. При таком соединении выход автомата подается на его вход, что позволяет автомату \\"запоминать\\" предыдущие состояния и, таким образом, обрабатывать последовательности символов с более сложным поведением.</p><p>Процесс соединения с обратной связью можно представить следующим образом:</p><ol><li>Берется исходный конечный автомат (назовем его автоматом A).</li><li>К выходу автомата A подключается его вход, создавая тем самым обратную связь.</li><li>Автоматы A и его копия (обратная связь) работают совместно, обрабатывая входные символы и передавая состояния друг другу.</li></ol><p>Такой подход позволяет создавать автоматы, способные распознавать или генерировать более сложные языки, включая контекстно-зависимые языки.</p><p>Пример соединения с обратной связью:</p><p>Допустим, у нас есть автомат A, который распознает язык L1, состоящий из нулей и единиц, где каждая последовательность начинается с 0 и заканчивается 1:</p><p><strong>Автомат A:</strong></p><pre><div class=\\"bg-black rounded-md mb-4\\"><div class=\\"flex items-center relative text-gray-200 bg-gray-800 px-4 py-2 text-xs font-sans justify-between rounded-t-md\\"><span>yaml</span><button class=\\"flex ml-auto gap-2\\"><svg stroke=\\"currentColor\\" fill=\\"none\\" stroke-width=\\"2\\" viewBox=\\"0 0 24 24\\" stroke-linecap=\\"round\\" stroke-linejoin=\\"round\\" class=\\"h-4 w-4\\" height=\\"1em\\" width=\\"1em\\" xmlns=\\"http://www.w3.org/2000/svg\\"><path d=\\"M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2\\"></path><rect x=\\"8\\" y=\\"2\\" width=\\"8\\" height=\\"4\\" rx=\\"1\\" ry=\\"1\\"></rect></svg>Copy code</button></div><div class=\\"p-4 overflow-y-auto\\"><code class=\\"!whitespace-pre hljs language-yaml\\"><span class=\\"hljs-attr\\">Alphabet:</span> {<span class=\\"hljs-number\\">0</span>, <span class=\\"hljs-number\\">1</span>}\\n<span class=\\"hljs-attr\\">States:</span> {<span class=\\"hljs-string\\">q0</span>, <span class=\\"hljs-string\\">q1</span>}\\n<span class=\\"hljs-attr\\">Start state:</span> <span class=\\"hljs-string\\">q0</span>\\n<span class=\\"hljs-attr\\">Accepting state:</span> <span class=\\"hljs-string\\">q1</span>\\n<span class=\\"hljs-attr\\">Transitions:</span>\\n<span class=\\"hljs-string\\">(q0,</span> <span class=\\"hljs-number\\">0</span><span class=\\"hljs-string\\">)</span> <span class=\\"hljs-string\\">-&gt;</span> <span class=\\"hljs-string\\">q1</span>\\n<span class=\\"hljs-string\\">(q1,</span> <span class=\\"hljs-number\\">1</span><span class=\\"hljs-string\\">)</span> <span class=\\"hljs-string\\">-&gt;</span> <span class=\\"hljs-string\\">q0</span>\\n</code></div></div></pre><p>Теперь объединим автомат A с его копией через обратную связь, чтобы получить новый автомат B:</p><p><strong>Соединение с обратной связью B:</strong></p><pre><div class=\\"bg-black rounded-md mb-4\\"><div class=\\"flex items-center relative text-gray-200 bg-gray-800 px-4 py-2 text-xs font-sans justify-between rounded-t-md\\"><span>vbnet</span><button class=\\"flex ml-auto gap-2\\"><svg stroke=\\"currentColor\\" fill=\\"none\\" stroke-width=\\"2\\" viewBox=\\"0 0 24 24\\" stroke-linecap=\\"round\\" stroke-linejoin=\\"round\\" class=\\"h-4 w-4\\" height=\\"1em\\" width=\\"1em\\" xmlns=\\"http://www.w3.org/2000/svg\\"><path d=\\"M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2\\"></path><rect x=\\"8\\" y=\\"2\\" width=\\"8\\" height=\\"4\\" rx=\\"1\\" ry=\\"1\\"></rect></svg>Copy code</button></div><div class=\\"p-4 overflow-y-auto\\"><code class=\\"!whitespace-pre hljs language-vbnet\\"><span class=\\"hljs-symbol\\">Alphabet:</span> {<span class=\\"hljs-number\\">0</span>, <span class=\\"hljs-number\\">1</span>}\\n<span class=\\"hljs-symbol\\">States:</span> {(q0, q0<span class=\\"hljs-comment\\">\'), (q0, q1\'), (q1, q0\'), (q1, q1\')}</span>\\nStart state: (q0, q0<span class=\\"hljs-comment\\">\')</span>\\nAccepting state: (q0, q1<span class=\\"hljs-comment\\">\')</span>\\n<span class=\\"hljs-symbol\\">Transitions:</span>\\n((q0, q0<span class=\\"hljs-comment\\">\'), 0) -&gt; (q1, q0\')   (автомат A)</span>\\n((q0, q0<span class=\\"hljs-comment\\">\'), 1) -&gt; (q0, q0\')</span>\\n((q0, q1<span class=\\"hljs-comment\\">\'), 0) -&gt; (q1, q0\')   (обратная связь)</span>\\n((q0, q1<span class=\\"hljs-comment\\">\'), 1) -&gt; (q0, q1\')</span>\\n((q1, q0<span class=\\"hljs-comment\\">\'), 0) -&gt; (q1, q0\')</span>\\n((q1, q0<span class=\\"hljs-comment\\">\'), 1) -&gt; (q0, q0\')</span>\\n((q1, q1<span class=\\"hljs-comment\\">\'), 0) -&gt; (q1, q0\')</span>\\n((q1, q1<span class=\\"hljs-comment\\">\'), 1) -&gt; (q0, q1\')</span>\\n</code></div></div></pre><p>В результате автомат B будет способен обрабатывать последовательности символов, принадлежащие языку L1, так как он содержит обратную связь, позволяющую \\"запомнить\\" состояние и продолжить обработку входных данных.</p></div>"],["Типы КС-языков. Нисходящие и восходящие распознаватели","<div class=\\"markdown prose w-full break-words dark:prose-invert light\\"><p><strong>Типы контекстно-свободных (КС) языков:</strong></p><p>Контекстно-свободные языки - это класс формальных языков, которые могут быть заданы с помощью контекстно-свободной грамматики. Они обладают более высокой выразительной мощностью, чем регулярные языки, и используются для описания более сложных структур и синтаксических правил. Важным свойством КС-языков является наличие контекстно-свободной грамматики, которая определяет их синтаксис.</p><p><strong>Нисходящие (Top-Down) распознаватели:</strong></p><p>Нисходящие распознаватели - это метод анализа синтаксиса, при котором анализатор начинает с верхнего уровня структуры (например, с символа стартового нетерминала) и рекурсивно спускается вниз по грамматике, пытаясь разобрать входную строку. Они строят вывод дерева разбора сверху вниз и используют различные правила для разбора и распознавания языка. Примечательными нисходящими анализаторами являются рекурсивный спуск и метод предсказывающего анализа (Predictive Parsing).</p><p><strong>Восходящие (Bottom-Up) распознаватели:</strong></p><p>Восходящие распознаватели - это метод анализа синтаксиса, при котором анализатор начинает с токенов входной строки и пытается построить дерево разбора, двигаясь \\"снизу вверх\\" по грамматике. Они строят вывод дерева разбора от листьев к корню и используют правила свертки для обработки входных данных и определения их соответствия грамматике. Примечательными восходящими анализаторами являются метод LR (слева направо, правое выводимое) и метод LALR (Look-Ahead LR).</p><p>Оба типа распознавателей (нисходящие и восходящие) используются для синтаксического анализа, чтобы определить, соответствует ли входная строка заданной грамматике, и в случае успешного разбора, построить структуру вывода, такую как дерево разбора. Выбор между ними зависит от структуры грамматики и особенностей языка, который требуется разобрать.</p></div>"],["Формальные языки и формальные грамматики","<div class=\\"markdown prose w-full break-words dark:prose-invert light\\"><p><strong>Формальные языки и формальные грамматики:</strong></p><p><strong>Формальные языки</strong> - это абстрактные множества символов, которые определяются с помощью формальных правил. Они широко используются в информатике, лингвистике и других дисциплинах для описания и анализа языковых структур и систем.</p><p><strong>Формальные грамматики</strong> - это формальные системы правил, которые определяют формальные языки. Формальная грамматика состоит из конечного набора правил, которые определяют, какие строки могут быть считаны входным языком, а какие нет.</p><p>Формальные грамматики обычно состоят из четырех компонентов:</p><ol><li><p><strong>Алфавит (Alphabet):</strong> Это конечное множество символов, которые могут использоваться для создания строк языка.</p></li><li><p><strong>Набор нетерминалов (Non-terminals):</strong> Это конечное множество символов, которые представляют собой абстрактные единицы или \\"переменные\\" в правилах грамматики. Нетерминалы заменяются на строки символов с помощью правил вывода.</p></li><li><p><strong>Начальный символ (Start symbol):</strong> Это один нетерминал из множества нетерминалов, который представляет начальное состояние грамматики. Процесс вывода строки начинается с этого символа.</p></li><li><p><strong>Правила вывода (Production rules):</strong> Это набор правил, которые определяют замену нетерминалов на строки символов. Правила задают, как одни символы заменяются другими в процессе вывода строки.</p></li></ol><p>Формальные грамматики классифицируются на различные типы, включая:</p><ul><li><p><strong>Регулярные грамматики:</strong> Определяют регулярные языки и используются для описания последовательностей символов с ограниченным контекстом, которые могут быть распознаны конечными автоматами.</p></li><li><p><strong>Контекстно-свободные грамматики:</strong> Определяют контекстно-свободные языки и используются для описания структурных характеристик языков, таких как вложенные скобки и синтаксические правила.</p></li><li><p><strong>Контекстно-зависимые грамматики:</strong> Определяют контекстно-зависимые языки и используются для описания языков с более сложными структурами, зависящими от контекста.</p></li><li><p><strong>Рекурсивно перечислимые грамматики:</strong> Определяют рекурсивно перечислимые языки, которые могут быть распознаны машиной Тьюринга.</p></li></ul><p>Формальные грамматики представляют собой мощный инструмент для описания языков и их синтаксиса, и они широко используются в компиляторах, обработке естественного языка, лингвистике и других областях информатики и науки о языке.</p></div>"]],"Исследование операций":[["Графический способ решения задач линейного программирования.","<div class=\\"markdown prose w-full break-words dark:prose-invert light\\"><p><strong>Графический способ решения задач линейного программирования:</strong></p><p>Графический способ решения задач линейного программирования используется для нахождения оптимального решения в задачах оптимизации с линейной целевой функцией и линейными ограничениями. Он применим только для задач с двумя переменными, так как он представляет решение на плоскости.</p><p>Шаги графического решения задачи линейного программирования:</p><ol><li><p><strong>Составление ограничений:</strong> Сначала необходимо записать ограничения задачи линейного программирования в виде системы линейных уравнений или неравенств.</p></li><li><p><strong>Построение координатной системы:</strong> На плоскости строится координатная система, где оси представляют значения переменных (x и y).</p></li><li><p><strong>Построение линий ограничений:</strong> Для каждого ограничения находим его уравнение или неравенство и строим соответствующую линию на графике.</p></li><li><p><strong>Определение допустимой области:</strong> Допустимая область представляет собой область на плоскости, которая удовлетворяет всем ограничениям задачи. Это область, которая ограничена пересечением линий ограничений.</p></li><li><p><strong>Построение линии уровня целевой функции:</strong> Целевая функция также представляется линией на графике. Эта линия называется линией уровня. Если задача является задачей на максимум, линия уровня обозначает направление роста значения целевой функции, и наилучшее решение будет находиться на самой высокой точке допустимой области. Если задача является задачей на минимум, линия уровня обозначает направление убывания значения целевой функции, и наилучшее решение будет находиться на самой низкой точке допустимой области.</p></li><li><p><strong>Нахождение оптимального решения:</strong> Оптимальное решение задачи будет точкой на допустимой области, где линия уровня целевой функции достигает наибольшего значения (в задачах на максимум) или наименьшего значения (в задачах на минимум).</p></li></ol><p>Графический метод предоставляет интуитивное представление решения задачи линейного программирования и может быть полезен для простых задач с двумя переменными. Однако для более сложных задач с большим количеством переменных чаще используются более эффективные методы, такие как симплекс-метод.</p></div>"],["Динамическое программирование.","<div class=\\"markdown prose w-full break-words dark:prose-invert light\\"><p><strong>Динамическое программирование:</strong></p><p>Динамическое программирование - это метод решения оптимизационных задач, который использует принцип оптимальности и повторное использование промежуточных результатов для сокращения времени выполнения. Этот подход применяется в ситуациях, когда задача может быть разбита на подзадачи, и оптимальное решение для исходной задачи может быть получено путем комбинирования оптимальных решений для подзадач.</p><p>Основные черты динамического программирования:</p><ol><li><p><strong>Мемоизация:</strong> Для избежания повторных вычислений и повышения эффективности, динамическое программирование использует мемоизацию (или запоминание). Результаты решения подзадач сохраняются в памяти, и если эти результаты понадобятся снова, они могут быть получены непосредственно из памяти без повторных вычислений.</p></li><li><p><strong>Рекурсия или итерация:</strong> Динамическое программирование может быть реализовано с использованием рекурсии или итерации (циклическим подходом). В рекурсивной форме, задача разбивается на подзадачи, и функция решения вызывает саму себя для решения каждой подзадачи. В итеративной форме, решение строится последовательно, начиная с меньших подзадач и постепенно переходя к исходной задаче.</p></li><li><p><strong>Оптимальная подструктура:</strong> Для успешного применения динамического программирования, задача должна обладать оптимальной подструктурой. Это означает, что оптимальное решение для исходной задачи может быть получено из оптимальных решений ее подзадач.</p></li><li><p><strong>Перекрытие подзадач:</strong> Динамическое программирование решает множество подзадач, и эти подзадачи могут иметь общие части. Задачи перекрываются, что позволяет избежать повторных вычислений и ускоряет процесс решения.</p></li></ol><p>Динамическое программирование находит широкое применение в различных областях, таких как оптимизация, алгоритмы, экономика, биоинформатика, и т.д. Оно позволяет эффективно решать сложные задачи, которые могут быть разложены на меньшие, независимые подзадачи.</p></div>"],["Классификация систем массового обслуживания.","<div class=\\"markdown prose w-full break-words dark:prose-invert light\\"><p><strong>Классификация систем массового обслуживания:</strong></p><p>Системы массового обслуживания (СМО) - это системы, в которых поступают заявки (запросы, клиенты) на обслуживание, и они обслуживаются определенными обслуживающими устройствами (серверами). Классификация СМО базируется на различных характеристиках системы и ее элементов:</p><ol><li><p><strong>Число каналов обслуживания (серверов):</strong></p><ul><li>Одноканальные СМО: В системе есть только один канал обслуживания (один сервер).</li><li>Многоканальные СМО: В системе есть несколько параллельных каналов обслуживания (несколько серверов).</li></ul></li><li><p><strong>Число очередей:</strong></p><ul><li>Системы с одной очередью: Заявки стоят в одной общей очереди и обслуживаются по мере доступности серверов.</li><li>Системы с несколькими очередями: Заявки могут быть направлены в различные очереди в зависимости от некоторых критериев (например, приоритета).</li></ul></li><li><p><strong>Порядок обслуживания:</strong></p><ul><li>Первым пришел - первым обслужен (FIFO): Заявки обслуживаются в том порядке, в котором они пришли в систему.</li><li>Случайный порядок: Заявки обслуживаются случайным образом.</li><li>Приоритетное обслуживание: Заявки обслуживаются в соответствии с их приоритетами.</li></ul></li><li><p><strong>Распределение времени обслуживания:</strong></p><ul><li>Постоянное время обслуживания: Время обслуживания для каждой заявки постоянно и одинаково для всех заявок.</li><li>Случайное время обслуживания: Время обслуживания каждой заявки случайно и может различаться.</li></ul></li><li><p><strong>Ожидание и отказ:</strong></p><ul><li>Системы с ожиданием: Заявки ожидают своей очереди на обслуживание, если серверы заняты.</li><li>Системы с отказами: Если все серверы заняты, новые заявки могут быть отклонены.</li></ul></li><li><p><strong>Природа поступления заявок:</strong></p><ul><li>Поток Пуассона: Заявки поступают в систему по процессу Пуассона, который характеризуется случайными интервалами между поступлениями.</li><li>Детерминированный поток: Заявки поступают в систему с фиксированным интервалом между поступлениями.</li></ul></li></ol><p>Классификация СМО позволяет определить основные характеристики системы и выбрать наиболее подходящие методы и модели для анализа и оптимизации производительности системы обслуживания.</p></div>"],["Критерии завершенности тестирования.","<div class=\\"markdown prose w-full break-words dark:prose-invert light\\"><p><strong>Критерии завершенности тестирования:</strong></p><p>Критерии завершенности тестирования - это условия или стандарты, которые определяют, когда тестирование программного продукта или системы считается полностью выполненным. Завершение тестирования указывает на то, что выполнены все необходимые шаги и проверки для обеспечения качества и готовности продукта к выпуску или внедрению. Критерии завершенности помогают обеспечить достаточное покрытие тестирования и максимально возможное выявление ошибок и проблем.</p><p>Некоторые общие критерии завершенности тестирования включают:</p><ol><li><p><strong>Покрытие тестирования:</strong> Критерий, который оценивает, какой процент кода, функциональности или требований был протестирован и проверен.</p></li><li><p><strong>Количество и серьезность ошибок:</strong> Критерий, основанный на количестве обнаруженных ошибок и их степени серьезности. Завершенность может быть достигнута, когда определенный порог ошибок удовлетворен или когда все критические ошибки устранены.</p></li><li><p><strong>Исполнение всех тестовых сценариев:</strong> Критерий, устанавливающий, что все запланированные тестовые сценарии и случаи были выполнены и успешно прошли.</p></li><li><p><strong>Успешность тестовых циклов:</strong> Критерий, основанный на успехе различных тестовых циклов или этапов тестирования, таких как модульное тестирование, интеграционное тестирование, системное тестирование и т.д.</p></li><li><p><strong>Соответствие требованиям:</strong> Критерий, который проверяет, что продукт или система соответствует предоставленным требованиям и спецификациям.</p></li><li><p><strong>Завершение документации:</strong> Критерий, основанный на завершении всех необходимых документов и отчетов о тестировании.</p></li><li><p><strong>Подтверждение заказчиком или командой:</strong> В некоторых случаях, тестирование может считаться завершенным после получения одобрения или подтверждения от заказчика или команды разработки.</p></li></ol><p>Критерии завершенности тестирования могут варьироваться в зависимости от типа проекта, характеристик продукта и контекста. Они обычно определяются в начале тестирования в соответствии с целями и требованиями проекта, и следует стремиться выполнить все критерии перед выпуском или внедрением продукта.</p></div>"],["Линейное программирование. Основные понятия линейного программирования.","<div class=\\"markdown prose w-full break-words dark:prose-invert light\\"><p><strong>Линейное программирование:</strong></p><p>Линейное программирование (ЛП) - это метод оптимизации, который используется для решения математических моделей, в которых целевая функция и ограничения представлены линейными функциями. Он позволяет найти оптимальное решение задачи при условии линейной зависимости между переменными.</p><p><strong>Основные понятия линейного программирования:</strong></p><ol><li><p><strong>Целевая функция (ЦФ):</strong> Это функция, которая должна быть минимизирована или максимизирована в рамках задачи линейного программирования. Она обычно представляет собой линейное выражение от переменных решения и может иметь форму \\"Минимизировать (или Максимизировать) Z = c₁x₁ + c₂x₂ + ... + cₙxₙ\\", где c₁, c₂, ..., cₙ - коэффициенты при переменных x₁, x₂, ..., xₙ.</p></li><li><p><strong>Ограничения:</strong> Ограничения представляют собой набор линейных уравнений или неравенств, которые ограничивают допустимую область переменных. Они определяют допустимые значения переменных и формируют границы, в которых должно находиться оптимальное решение.</p></li><li><p><strong>Переменные решения:</strong> Переменные решения - это неизвестные величины, которые необходимо найти для достижения оптимального результата. Они представляют собой значения, которые мы хотим определить или найти.</p></li><li><p><strong>Допустимая область:</strong> Допустимая область - это область в пространстве переменных, которая удовлетворяет всем ограничениям задачи. Она образуется пересечением всех ограничений.</p></li><li><p><strong>Условие неотрицательности:</strong> В большинстве задач линейного программирования предполагается, что переменные решения должны быть неотрицательными (x₁ ≥ 0, x₂ ≥ 0, ..., xₙ ≥ 0), то есть их значения не могут быть отрицательными.</p></li><li><p><strong>Решение задачи:</strong> Решение задачи линейного программирования - это набор значений переменных решения, которые удовлетворяют всем ограничениям и оптимизируют значение целевой функции (минимизируют или максимизируют его).</p></li></ol><p>Линейное программирование имеет широкий спектр применения в экономике, производственной деятельности, логистике, финансах и других областях, где необходимо оптимизировать ресурсы и принимать решения на основе линейных ограничений и целевых функций.</p></div>"],["Математическая модель транспортной задачи.","<div class=\\"markdown prose w-full break-words dark:prose-invert light\\"><p><strong>Математическая модель транспортной задачи:</strong></p><p>Транспортная задача является одной из классических задач линейного программирования и используется для оптимизации транспортных и поставочных проблем. Эта задача связана с определением оптимального плана перевозки товаров из источников (поставщиков) к потребителям с минимальными затратами или максимальной прибылью.</p><p>Предположим, у нас есть m источников и n потребителей, и каждый источник предоставляет определенное количество товара (производственные мощности), которое нужно доставить к потребителям. Целью транспортной задачи является определение оптимального плана перевозок, чтобы удовлетворить потребности потребителей и минимизировать общие транспортные затраты или максимизировать прибыль.</p><p>Предположим, что:</p><ul><li>aᵢ - количество товара, доступного на i-м источнике (поставщике).</li><li>bⱼ - потребность в товаре у j-го потребителя.</li><li>cᵢⱼ - стоимость перевозки единицы товара из i-го источника к j-му потребителю.</li></ul><p>Математическая модель транспортной задачи записывается следующим образом:</p><p><strong>Минимизировать:</strong>\\nZ = ΣᵢΣⱼ (cᵢⱼ * xᵢⱼ)</p><p><strong>При условии:</strong></p><ol><li>Σⱼ xᵢⱼ ≤ aᵢ, для каждого источника i.</li><li>Σᵢ xᵢⱼ = bⱼ, для каждого потребителя j.</li><li>xᵢⱼ ≥ 0, для всех i и j.</li></ol><p>Где:</p><ul><li>xᵢⱼ - количество товара, перевозимого из источника i к потребителю j.</li></ul><p>Целевая функция Z определяет общие транспортные затраты или прибыль, а ограничения (условия) обеспечивают, чтобы потребности потребителей были удовлетворены, и все поставщики не превысили свои производственные мощности.</p><p>Транспортные задачи могут быть решены с использованием различных методов оптимизации, таких как метод северо-западного угла, метод минимальной стоимости, метод потенциалов (метод симплекса) и другие.</p></div>"],["Метод наименьшего элемента. Метод потенциалов. (Транспортная задача)","<div class=\\"markdown prose w-full break-words dark:prose-invert light\\"><p><strong>Метод наименьшего элемента и метод потенциалов в решении транспортной задачи:</strong></p><p><strong>Метод наименьшего элемента:</strong></p><p>Метод наименьшего элемента является одним из классических методов решения транспортной задачи. Он основан на выборе клетки с наименьшей стоимостью перевозки (наименьший элемент) в таблице перевозок и выполнении перевозки в эту клетку максимально возможного объема товара. После каждой перевозки проверяется удовлетворение условий ограничений и уменьшается нужное количество товара в соответствующих строках и столбцах. Этот процесс повторяется до тех пор, пока все потребности потребителей и ограничения источников не будут удовлетворены.</p><p>Шаги метода наименьшего элемента:</p><ol><li>Найти клетку с наименьшей стоимостью перевозки в таблице.</li><li>Выполнить перевозку максимально возможного объема товара в эту клетку.</li><li>Уменьшить нужное количество товара в соответствующих строках и столбцах.</li><li>Повторить шаги 1-3 до тех пор, пока все потребности потребителей и ограничения источников не будут удовлетворены.</li></ol><p><strong>Метод потенциалов:</strong></p><p>Метод потенциалов, также известный как метод симплекса для транспортных задач, является более эффективным и точным методом решения транспортной задачи. Он использует понятие потенциалов (цен) для определения оптимального решения. В этом методе цены присваиваются всем клеткам таблицы перевозок и затем рассчитываются потенциалы для строк и столбцов. Затем производится проверка на удовлетворение условий ограничений и наличие затрато-оптимального решения.</p><p>Шаги метода потенциалов:</p><ol><li>Начать с некоторого допустимого базисного плана, например, методом северо-западного угла или методом наименьшего элемента.</li><li>Рассчитать потенциалы (цены) для всех клеток таблицы перевозок, используя решение из шага 1.</li><li>Рассчитать потенциалы для строк и столбцов с помощью уравнений потенциалов (цен).</li><li>Проверить условия оптимальности и определить, достигнуто ли затрато-оптимальное решение. Если условия оптимальности не выполняются, выполнить пересчет базисного плана и повторить шаги 2-4 до достижения оптимального решения.</li></ol><p>Метод потенциалов обладает более высокой точностью и эффективностью по сравнению с методом наименьшего элемента, особенно для больших транспортных задач. Он также может быть применен для решения недопустимых задач или задач с неравными потребностями и производственными мощностями.</p></div>"],["Методология и методы принятия решений.","<div class=\\"markdown prose w-full break-words dark:prose-invert light\\"><p><strong>Методология и методы принятия решений:</strong></p><p><strong>Методология принятия решений:</strong></p><p>Методология принятия решений - это системный подход к процессу принятия решений, который включает в себя различные этапы, методы и техники, направленные на анализ проблемы, оценку альтернатив и выбор оптимального решения. Методология принятия решений помогает структурировать процесс принятия решений и повышает вероятность принятия обоснованных и эффективных решений.</p><p>Основные этапы методологии принятия решений включают:</p><ol><li><p><strong>Определение проблемы:</strong> Первый этап заключается в определении суть и характера проблемы или решаемой задачи, а также выявлении целей и ограничений.</p></li><li><p><strong>Сбор и анализ информации:</strong> На этом этапе собирается необходимая информация, проводится ее анализ и оценка, выявляются альтернативы и возможные решения.</p></li><li><p><strong>Разработка альтернатив:</strong> В этом этапе формируются различные альтернативы или варианты решений, которые могут быть рассмотрены.</p></li><li><p><strong>Оценка альтернатив:</strong> Альтернативы оцениваются по определенным критериям и показателям для определения их преимуществ и недостатков.</p></li><li><p><strong>Выбор решения:</strong> На основе результатов оценки альтернатив выбирается наилучшее решение, которое соответствует целям и ограничениям проблемы.</p></li><li><p><strong>Реализация решения:</strong> После выбора решения приступают к его реализации и внедрению.</p></li><li><p><strong>Контроль и оценка результатов:</strong> Контролируется выполнение выбранного решения и оценивается его эффективность.</p></li></ol><p><strong>Методы принятия решений:</strong></p><p>Методы принятия решений - это конкретные инструменты и техники, которые используются для оценки альтернатив и поддержки процесса принятия решений. Существует множество методов принятия решений, и выбор конкретного метода зависит от типа проблемы и ее характеристик.</p><p>Некоторые из распространенных методов принятия решений включают:</p><ul><li><strong>Метод взвешенных критериев:</strong> Позволяет оценить альтернативы на основе взвешенных критериев, учитывая их относительную важность.</li><li><strong>Метод анализа иерархий (МАИ):</strong> Использует иерархическую структуру для оценки альтернатив и определения наилучшего варианта.</li><li><strong>Метод сетей Перри (PERT):</strong> Применяется для анализа времени выполнения проектов и определения вероятных сроков завершения.</li><li><strong>Метод экспертных оценок:</strong> Включает в себя опрос экспертов и специалистов для получения информации и мнений о различных альтернативах.</li><li><strong>Байесовский анализ:</strong> Основан на теории вероятности и используется для обработки неопределенности и статистических данных при принятии решений.</li></ul><p>Выбор конкретного метода зависит от сложности проблемы, доступных данных и желаемой точности принятия решения. Часто в реальной жизни комбинируют несколько методов для получения более полной и надежной информации для принятия решений.</p></div>"],["Описание алгоритма Симплекс-метода","<div class=\\"markdown prose w-full break-words dark:prose-invert light\\"><p><strong>Описание алгоритма Симплекс-метода:</strong></p><p>Симплекс-метод - это эффективный алгоритм линейного программирования, который позволяет найти оптимальное решение задачи линейного программирования. Он разработан для решения задач с линейной целевой функцией и линейными ограничениями. Алгоритм работает в пространстве переменных задачи и перемещается по вершинам (угловым точкам) допустимой области до достижения оптимального решения.</p><p>Шаги алгоритма Симплекс-метода:</p><ol><li><p><strong>Перевод в стандартную форму:</strong> Если задача не находится в стандартной форме (максимизация с неотрицательными переменными), она преобразуется к стандартной форме.</p></li><li><p><strong>Создание симплекс-таблицы:</strong> Строится симплекс-таблица, которая включает все переменные и их коэффициенты, а также базисные переменные, значения которых равны ограничениям.</p></li><li><p><strong>Выбор начального базиса:</strong> Выбираются базисные переменные, которые образуют исходный базис (ненулевые элементы в столбце правой части таблицы).</p></li><li><p><strong>Определение разрешающего элемента:</strong> Выбирается разрешающий элемент из симплекс-таблицы. Разрешающий элемент - это наименьший элемент в столбце целевой функции (значения Z) среди всех отрицательных элементов.</p></li><li><p><strong>Пересчет симплекс-таблицы:</strong> Производится пересчет элементов в симплекс-таблице с использованием выбранного разрешающего элемента. Этот шаг включает деление разрешающей строки на разрешающий элемент и обновление остальных элементов таблицы, чтобы получить новый опорный план.</p></li><li><p><strong>Проверка оптимальности:</strong> Проверяется оптимальность текущего опорного плана. Если все значения в строке целевой функции (кроме значения Z) положительны или нулевые, то текущий опорный план является оптимальным решением. В противном случае, переходим на шаг 4 для поиска нового разрешающего элемента и пересчета таблицы.</p></li><li><p><strong>Получение оптимального решения:</strong> Когда оптимальный опорный план достигнут, находится оптимальное значение целевой функции (максимум или минимум, в зависимости от постановки задачи) и соответствующие значения переменных.</p></li></ol><p>Алгоритм Симплекс-метода может быть представлен в итерационной форме, и он продолжает двигаться по вершинам допустимой области, пока не достигнет оптимального решения.</p></div>"],["Основные понятия исследования операций","<div class=\\"markdown prose w-full break-words dark:prose-invert light\\"><p><strong>Основные понятия исследования операций:</strong></p><p>Исследование операций (Operations Research, OR) - это научно-методическая дисциплина, которая использует математические, статистические и аналитические методы для анализа сложных систем и принятия оптимальных решений. Основной целью исследования операций является оптимизация процессов и ресурсов, чтобы улучшить эффективность и эффективность принятия решений в различных областях.</p><p>Ниже приведены основные понятия, связанные с исследованием операций:</p><ol><li><p><strong>Модель:</strong> Модель представляет собой упрощенное математическое описание реальной системы или процесса. Модели позволяют анализировать и предсказывать поведение системы, а также оценивать различные стратегии и решения.</p></li><li><p><strong>Оптимизация:</strong> Оптимизация в исследовании операций означает поиск наилучшего решения среди доступных альтернатив. Целью оптимизации может быть максимизация прибыли, минимизация затрат, оптимальное распределение ресурсов и другие критерии.</p></li><li><p><strong>Линейное программирование:</strong> Линейное программирование (Linear Programming, LP) - это метод оптимизации, который используется для решения задач с линейной целевой функцией и линейными ограничениями.</p></li><li><p><strong>Целочисленное программирование:</strong> Целочисленное программирование (Integer Programming, IP) - это метод оптимизации, в котором переменные решения ограничены целочисленными значениями. Этот метод используется для решения задач, в которых решения должны быть дискретными.</p></li><li><p><strong>Сетевой анализ:</strong> Сетевой анализ используется для моделирования и анализа сложных сетевых систем, таких как графики проектов, системы маршрутизации и др.</p></li><li><p><strong>Теория очередей:</strong> Теория очередей изучает процессы обслуживания и управления потоками в системах массового обслуживания.</p></li><li><p><strong>Методы принятия решений:</strong> Исследование операций предоставляет различные методы и техники для принятия решений, такие как симплекс-метод, метод взвешенных критериев, метод анализа иерархий и т.д.</p></li><li><p><strong>Статистические методы:</strong> Исследование операций использует статистические методы для обработки данных, оценки вероятностей и принятия статистических выводов.</p></li><li><p><strong>Моделирование симуляции:</strong> Симуляция используется для создания моделей систем, которые имитируют реальное поведение и позволяют проводить эксперименты без риска и затрат реальной системы.</p></li></ol><p>Исследование операций широко применяется в различных областях, таких как логистика, производство, финансы, транспорт, здравоохранение и другие, чтобы помочь в принятии решений на основе анализа данных и оптимизации ресурсов.</p></div>"],["Теория массового обслуживания. Цель и задачи теории массового обслуживания.","<div class=\\"markdown prose w-full break-words dark:prose-invert light\\"><p><strong>Теория массового обслуживания:</strong></p><p>Теория массового обслуживания (Queueing Theory) - это раздел исследования операций, который занимается анализом и моделированием систем массового обслуживания, в которых клиенты (заявки, требования) поступают в систему, ожидают обслуживания и, наконец, обслуживаются. Эта теория является основным инструментом для анализа производительности систем с очередями, таких как кассы в магазинах, серверы в компьютерных сетях, операционные залы в больницах и т.д.</p><p><strong>Цель теории массового обслуживания:</strong></p><p>Основной целью теории массового обслуживания является анализ и оптимизация производительности систем массового обслуживания. Она стремится предоставить количественные оценки для различных характеристик таких систем, таких как:</p><ul><li>Среднее время ожидания клиентов в очереди.</li><li>Среднее время обслуживания клиентов.</li><li>Вероятность ожидания в очереди.</li><li>Вероятность отказа в обслуживании.</li><li>Загрузка и использование ресурсов системы.</li></ul><p><strong>Задачи теории массового обслуживания:</strong></p><p>Теория массового обслуживания решает ряд задач, связанных с анализом и оптимизацией производительности систем с очередями. Некоторые из основных задач включают:</p><ol><li><p><strong>Анализ системы массового обслуживания:</strong> Основная задача - это анализ характеристик системы, таких как среднее время ожидания, среднее время обслуживания, вероятность ожидания, вероятность отказа и других показателей производительности.</p></li><li><p><strong>Определение оптимальных параметров:</strong> Теория массового обслуживания помогает определить оптимальные параметры системы, которые обеспечивают оптимальное использование ресурсов и минимизацию времени ожидания клиентов.</p></li><li><p><strong>Прогнозирование производительности:</strong> Опираясь на анализ системы, теория массового обслуживания позволяет предсказать будущую производительность и возможные проблемы, которые могут возникнуть при увеличении нагрузки на систему.</p></li><li><p><strong>Проектирование и оптимизация системы:</strong> Теория массового обслуживания помогает разрабатывать и оптимизировать системы с очередями, чтобы они могли эффективно обрабатывать клиентов и удовлетворять их потребности.</p></li></ol><p>Теория массового обслуживания находит применение в различных областях, включая транспортные сети, телекоммуникации, информационные системы, производственные процессы, общественное здравоохранение и другие, где эффективное управление потоками и ресурсами является ключевым фактором для обеспечения качества обслуживания и оптимизации производительности.</p></div>"],["Транспортная задача. Постановка задачи.","<div class=\\"markdown prose w-full break-words dark:prose-invert light\\"><p><strong>Транспортная задача: Постановка задачи</strong></p><p>Транспортная задача является одной из классических задач линейного программирования и является частным случаем задачи о назначениях. Она моделирует проблему оптимального распределения ресурсов из источников в пункты потребления с минимальными затратами или максимизацией выгоды.</p><p><strong>Постановка задачи:</strong></p><p>Пусть у нас имеется m источников (фабрик, складов и т.д.) и n пунктов потребления (магазинов, покупателей и т.д.). Каждый источник имеет определенное количество единиц ресурса (товара, продукции), которое он может предоставить, и каждый пункт потребления имеет определенную потребность в ресурсах.</p><p>Задача состоит в том, чтобы определить, как распределить ресурсы из источников в пункты потребления так, чтобы удовлетворить потребности всех пунктов потребления и при этом минимизировать или максимизировать общие затраты (стоимость транспортировки или общую выгоду).</p><p>Основные параметры транспортной задачи:</p><ul><li><strong>m:</strong> Количество источников ресурсов.</li><li><strong>n:</strong> Количество пунктов потребления.</li><li><strong>a&lt;sub&gt;i&lt;/sub&gt;:</strong> Объем ресурсов (товаров) доступных в i-ом источнике (i = 1, 2, ..., m).</li><li><strong>b&lt;sub&gt;j&lt;/sub&gt;:</strong> Потребность в ресурсах (товарах) в j-ом пункте потребления (j = 1, 2, ..., n).</li><li><strong>c&lt;sub&gt;ij&lt;/sub&gt;:</strong> Затраты (стоимость) транспортировки единицы ресурса из i-ого источника в j-ый пункт потребления.</li></ul><p><strong>Целевая функция:</strong>\\nТранспортная задача имеет цель минимизации или максимизации общих затрат (стоимости) транспортировки ресурсов из источников в пункты потребления. Целевая функция определяется следующим образом:</p><p><strong>Минимизация затрат:</strong>\\nMinimize Σ&lt;sub&gt;i=1 to m&lt;/sub&gt; Σ&lt;sub&gt;j=1 to n&lt;/sub&gt; (c&lt;sub&gt;ij&lt;/sub&gt; * x&lt;sub&gt;ij&lt;/sub&gt;), где x&lt;sub&gt;ij&lt;/sub&gt; - количество ресурсов, транспортированных из i-ого источника в j-ый пункт потребления.</p><p><strong>Максимизация выгоды (при необходимости):</strong>\\nMaximize Σ&lt;sub&gt;i=1 to m&lt;/sub&gt; Σ&lt;sub&gt;j=1 to n&lt;/sub&gt; (c&lt;sub&gt;ij&lt;/sub&gt; * x&lt;sub&gt;ij&lt;/sub&gt;), где x&lt;sub&gt;ij&lt;/sub&gt; - количество ресурсов, транспортированных из i-ого источника в j-ый пункт потребления.</p><p><strong>Ограничения:</strong>\\nОграничения транспортной задачи представляют собой обязательство удовлетворения потребностей каждого пункта потребления и ограничения на доступность ресурсов в каждом источнике.</p><p>Σ&lt;sub&gt;i=1 to m&lt;/sub&gt; x&lt;sub&gt;ij&lt;/sub&gt; = b&lt;sub&gt;j&lt;/sub&gt;, где j = 1, 2, ..., n (условие удовлетворения потребности в каждом пункте потребления).</p><p>Σ&lt;sub&gt;j=1 to n&lt;/sub&gt; x&lt;sub&gt;ij&lt;/sub&gt; = a&lt;sub&gt;i&lt;/sub&gt;, где i = 1, 2, ..., m (условие доступности ресурсов в каждом источнике).</p><p>x&lt;sub&gt;ij&lt;/sub&gt; ≥ 0, где i = 1, 2, ..., m, и j = 1, 2, ..., n (неотрицательность количества транспортируемых ресурсов).</p><p>Решение транспортной задачи заключается в нахождении значений переменных x&lt;sub&gt;ij&lt;/sub&gt; таким образом, чтобы удовлетворить ограничениям и минимизировать или максимизировать целевую функцию. Это может быть выполнено с использованием различных методов, таких как метод Северо-Западного угла, метод Минимального элемента,</p></div>"],["Характеристики эффективности функционирования СМО.","<div class=\\"markdown prose w-full break-words dark:prose-invert light\\"><p><strong>Характеристики эффективности функционирования СМО (Системы массового обслуживания):</strong></p><p>Система массового обслуживания (СМО) представляет собой модель, которая используется для изучения и анализа процессов обслуживания клиентов (заявок, требований) в условиях случайных поступлений и обслуживания. Характеристики эффективности функционирования СМО позволяют оценить производительность и качество обслуживания в таких системах. Вот основные характеристики эффективности СМО:</p><ol><li><p><strong>Интенсивность поступления заявок (λ):</strong> Это параметр, определяющий среднее количество заявок (клиентов) поступающих в систему за единицу времени. Интенсивность поступления может быть постоянной или случайной величиной.</p></li><li><p><strong>Интенсивность обслуживания (μ):</strong> Это параметр, определяющий среднее количество заявок (клиентов), обслуживаемых за единицу времени. Интенсивность обслуживания также может быть постоянной или случайной величиной.</p></li><li><p><strong>Коэффициент использования обслуживающих устройств (ρ):</strong> Этот параметр показывает, насколько эффективно используются ресурсы (например, обслуживающие устройства, каналы). Он определяется отношением интенсивности поступления (λ) к интенсивности обслуживания (μ): ρ = λ / μ. Если ρ &lt; 1, то система используется не полностью, а если ρ = 1, то система работает на предельной нагрузке.</p></li><li><p><strong>Среднее время ожидания в очереди (W):</strong> Эта характеристика показывает среднее время, которое клиенты проводят в очереди перед обслуживанием. Долгое время ожидания может снижать удовлетворенность клиентов.</p></li><li><p><strong>Среднее время пребывания в системе (T):</strong> Это среднее время, которое клиенты проводят в системе, включая время ожидания в очереди и время обслуживания.</p></li><li><p><strong>Вероятность отказа в обслуживании (P&lt;sub&gt;отк&lt;/sub&gt;):</strong> Это вероятность того, что клиент не будет обслужен в системе, а будет отвергнут из-за отсутствия свободных ресурсов или переполнения очереди.</p></li><li><p><strong>Интенсивность обслуживания (количество обслуженных клиентов в единицу времени) в системе (L):</strong> Это характеристика показывает среднее количество клиентов, находящихся в системе (в очереди и в обслуживании) за единицу времени.</p></li><li><p><strong>Число клиентов в очереди (L&lt;sub&gt;q&lt;/sub&gt;):</strong> Это среднее количество клиентов, ожидающих обслуживания в очереди.</p></li><li><p><strong>Число клиентов в системе (L&lt;sub&gt;сист&lt;/sub&gt;):</strong> Это среднее количество клиентов, находящихся в системе (в очереди и в обслуживании).</p></li><li><p><strong>Коэффициент занятости обслуживающих устройств (u):</strong> Это показатель, который определяет, насколько обслуживающие устройства (каналы) заняты в процессе обслуживания клиентов.</p></li></ol><p>Эти характеристики позволяют оценить эффективность функционирования СМО, и их анализ помогает оптимизировать процессы обслуживания и улучшить качество обслуживания клиентов.</p></div>"],["Характеристики эффективности функционирования СМО.","<div class=\\"markdown prose w-full break-words dark:prose-invert light\\"><p><strong>Характеристики эффективности функционирования СМО (Системы массового обслуживания):</strong></p><p>Характеристики эффективности функционирования СМО представляют собой параметры, которые используются для оценки производительности и качества обслуживания в системах массового обслуживания. Они помогают определить уровень сервиса, удовлетворенность клиентов, эффективность использования ресурсов и производительность системы. Вот основные характеристики эффективности СМО:</p><ol><li><p><strong>Интенсивность поступления заявок (λ):</strong> Это параметр, определяющий среднее количество заявок (клиентов) поступающих в систему за единицу времени. Интенсивность поступления может быть постоянной или случайной величиной.</p></li><li><p><strong>Интенсивность обслуживания (μ):</strong> Это параметр, определяющий среднее количество заявок (клиентов), обслуживаемых за единицу времени. Интенсивность обслуживания также может быть постоянной или случайной величиной.</p></li><li><p><strong>Коэффициент использования обслуживающих устройств (ρ):</strong> Этот параметр показывает, насколько эффективно используются ресурсы (например, обслуживающие устройства, каналы). Он определяется отношением интенсивности поступления (λ) к интенсивности обслуживания (μ): ρ = λ / μ. Если ρ &lt; 1, то система используется не полностью, а если ρ = 1, то система работает на предельной нагрузке.</p></li><li><p><strong>Среднее время ожидания в очереди (W):</strong> Эта характеристика показывает среднее время, которое клиенты проводят в очереди перед обслуживанием. Долгое время ожидания может снижать удовлетворенность клиентов.</p></li><li><p><strong>Среднее время пребывания в системе (T):</strong> Это среднее время, которое клиенты проводят в системе, включая время ожидания в очереди и время обслуживания.</p></li><li><p><strong>Вероятность отказа в обслуживании (P&lt;sub&gt;отк&lt;/sub&gt;):</strong> Это вероятность того, что клиент не будет обслужен в системе, а будет отвергнут из-за отсутствия свободных ресурсов или переполнения очереди.</p></li><li><p><strong>Интенсивность обслуживания (количество обслуженных клиентов в единицу времени) в системе (L):</strong> Это характеристика показывает среднее количество клиентов, находящихся в системе (в очереди и в обслуживании) за единицу времени.</p></li><li><p><strong>Число клиентов в очереди (L&lt;sub&gt;q&lt;/sub&gt;):</strong> Это среднее количество клиентов, ожидающих обслуживания в очереди.</p></li><li><p><strong>Число клиентов в системе (L&lt;sub&gt;сист&lt;/sub&gt;):</strong> Это среднее количество клиентов, находящихся в системе (в очереди и в обслуживании).</p></li><li><p><strong>Коэффициент занятости обслуживающих устройств (u):</strong> Это показатель, который определяет, насколько обслуживающие устройства (каналы) заняты в процессе обслуживания клиентов.</p></li></ol><p>Эти характеристики позволяют оценить эффективность функционирования СМО, анализируя производительность, использование ресурсов и качество обслуживания клиентов. Исследование этих характеристик позволяет оптимизировать процессы обслуживания, снизить время ожидания клиентов и повысить удовлетворенность клиентов.</p></div>"],["Экономико-математическое моделирование. Классификация экономических задач.","<div class=\\"markdown prose w-full break-words dark:prose-invert light\\"><p><strong>Экономико-математическое моделирование. Классификация экономических задач:</strong></p><p><strong>Экономико-математическое моделирование</strong> - это методология применения математических и статистических методов для решения экономических задач и анализа экономических процессов. При помощи моделей можно формализовать сложные экономические взаимодействия и предсказать поведение рыночных структур, планировать ресурсы и принимать обоснованные экономические решения.</p><p><strong>Классификация экономических задач:</strong></p><ol><li><p><strong>Оптимизационные задачи:</strong> Задачи оптимизации направлены на поиск оптимальных решений, которые максимизируют или минимизируют определенную функцию. Примерами могут быть задачи максимизации прибыли, минимизации затрат, определения оптимального портфеля инвестиций и т.д.</p></li><li><p><strong>Прогнозирование и статистические задачи:</strong> Задачи прогнозирования предполагают предсказание будущих значений экономических переменных на основе статистических данных и временных рядов. Это может быть прогнозирование спроса, инфляции, экономического роста и т.д.</p></li><li><p><strong>Моделирование динамических процессов:</strong> В экономических задачах часто рассматриваются динамические процессы, такие как развитие рынков, долгосрочные инвестиции, модели бюджетного планирования и др. Для анализа таких процессов используются дифференциальные уравнения и динамические системы.</p></li><li><p><strong>Теория игр:</strong> Теория игр используется для анализа стратегических решений и взаимодействий различных участников экономических процессов. Эта область исследует оптимальные стратегии, которые принимают участники в условиях неопределенности и конкуренции.</p></li><li><p><strong>Экономические модели спроса и предложения:</strong> Экономические модели спроса и предложения описывают взаимосвязь между ценой товара или услуги и их количеством, которое покупатели и продавцы готовы приобрести или продать.</p></li><li><p><strong>Финансовые модели:</strong> Финансовые модели применяются для анализа инвестиционных решений, оценки стоимости активов, управления портфелем и оценки рисков.</p></li><li><p><strong>Экономические задачи принятия решений:</strong> Задачи принятия решений касаются выбора оптимальных стратегий и альтернатив в условиях ограниченных ресурсов и неопределенности.</p></li><li><p><strong>Моделирование макроэкономических процессов:</strong> Эти задачи относятся к анализу долгосрочных тенденций и экономического развития на уровне всей страны или региона. Здесь используются модели макроэкономики для прогнозирования и анализа макроэкономических переменных, таких как ВВП, инфляция, безработица и др.</p></li><li><p><strong>Моделирование рисков и страхования:</strong> Задачи оценки рисков и страхования направлены на анализ финансовых потерь и определение оптимальных стратегий управления рисками.</p></li></ol><p>Экономико-математическое моделирование играет ключевую роль в принятии обоснованных экономических решений и обеспечении эффективного функционирования бизнеса, инвестиций и государственной политики.</p></div>"],["Эффективность операции по нескольким критериям.","<div class=\\"markdown prose w-full break-words dark:prose-invert light\\"><p><strong>Эффективность операции по нескольким критериям:</strong></p><p>При оценке эффективности операции или проекта часто возникает необходимость учитывать несколько критериев одновременно, так как решение может влиять на различные аспекты или цели. Это приводит к появлению задач многокритериальной оптимизации. При такой оптимизации стремятся найти компромиссное решение, учитывающее различные критерии, которые могут быть взаимно противоречивыми или конкурировать друг с другом.</p><p><strong>Примеры критериев, по которым может оцениваться эффективность операции:</strong></p><ol><li><p><strong>Прибыль:</strong> Это основной критерий для многих бизнес-операций. Оценивается сумма денег, которую операция принесла компании, после вычета всех затрат.</p></li><li><p><strong>Сроки:</strong> Оценивается время, необходимое для выполнения операции или проекта. Зависит от требований заказчика или важности выполнения задачи в определенный срок.</p></li><li><p><strong>Качество:</strong> Оценивается соответствие выполненной работы или произведенных товаров установленным стандартам и требованиям качества.</p></li><li><p><strong>Затраты:</strong> Оценивается количество ресурсов (денежных средств, времени, труда, материалов) затраченных на выполнение операции.</p></li><li><p><strong>Удовлетворенность клиентов:</strong> Оценивается удовлетворенность клиентов полученными продуктами или услугами.</p></li><li><p><strong>Уровень риска:</strong> Оценивается степень риска, связанного с операцией, и его влияние на компанию.</p></li><li><p><strong>Социальная ответственность:</strong> Оценивается соответствие операции принципам социальной ответственности, влияние на окружающую среду и общественное благополучие.</p></li><li><p><strong>Инновации:</strong> Оценивается внедрение новых технологий, процессов или идей, которые способствуют развитию компании или индустрии.</p></li><li><p><strong>Экономическая эффективность:</strong> Оценивается соотношение затрат к выгодам или выходу, полученному от операции.</p></li><li><p><strong>Соответствие стратегическим целям:</strong> Оценивается соответствие выполнения операции стратегическим целям компании или проекта.</p></li></ol><p>Многокритериальная оптимизация включает в себя различные методы, такие как методы взвешенной суммы, методы ограничений, методы компромиссов и др. Оптимальное решение выбирается на основе компромисса между различными критериями с учетом их важности и взаимосвязи. Это позволяет достичь более сбалансированных результатов и принять более обоснованные решения, учитывая множество факторов, которые влияют на эффективность операции.</p></div>"],["Эффективность операции. Критерий эффективности операций.","<div class=\\"markdown prose w-full break-words dark:prose-invert light\\"><p><strong>Эффективность операции. Критерий эффективности операций:</strong></p><p><strong>Эффективность операции</strong> относится к степени, в которой операция достигает своих целей и задач с наилучшими результатами, оптимальным использованием ресурсов и минимальными затратами. Критерий эффективности операций является мерой оценки того, насколько успешно операция выполняет свои функции и приносит пользу организации или компании.</p><p><strong>Критерии эффективности операций могут включать следующие аспекты:</strong></p><ol><li><p><strong>Прибыльность:</strong> Одним из основных критериев эффективности является прибыльность операции. Операция считается эффективной, если она приносит организации прибыль и способствует росту доходов.</p></li><li><p><strong>Производительность:</strong> Критерий производительности связан с количеством продукции или услуг, которые операция способна производить или предоставлять за определенный период времени. Чем выше производительность, тем более эффективна операция.</p></li><li><p><strong>Качество продукции или услуг:</strong> Эффективная операция должна предоставлять продукцию или услуги высокого качества, которые удовлетворяют требованиям и ожиданиям клиентов.</p></li><li><p><strong>Эффективность использования ресурсов:</strong> Операция считается эффективной, если она способна эффективно использовать доступные ресурсы, такие как трудовые ресурсы, материалы, оборудование и др.</p></li><li><p><strong>Соблюдение сроков:</strong> Эффективная операция должна выполняться в срок и не допускать задержек или простоев.</p></li><li><p><strong>Инновации и технологический прогресс:</strong> Эффективные операции стараются внедрять инновации и использовать современные технологии для улучшения производственных процессов и результатов.</p></li><li><p><strong>Удовлетворенность клиентов:</strong> Критерий удовлетворенности клиентов оценивает, насколько операция удовлетворяет потребности и ожидания клиентов.</p></li><li><p><strong>Устойчивость и экологическая ответственность:</strong> Эффективные операции также обращают внимание на устойчивость, социальную ответственность и уважение к окружающей среде.</p></li><li><p><strong>Уровень риска:</strong> Операция должна учитывать риски и стараться минимизировать их влияние на результаты.</p></li><li><p><strong>Соответствие стратегическим целям:</strong> Операция считается эффективной, если она соответствует стратегическим целям организации и способствует достижению ее долгосрочных задач.</p></li></ol><p><strong>Критерий эффективности операций может варьироваться в зависимости от типа операции, отрасли и конкретных целей организации.</strong> Компания должна анализировать и учитывать различные критерии, чтобы принимать обоснованные решения и достигать оптимальных результатов.</p></div>"]],"Базы данных":[["Назначение и основные компоненты системы баз данных.","<div class=\\"markdown prose w-full break-words dark:prose-invert light\\"><p><strong>Назначение и основные компоненты системы баз данных:</strong></p><p><strong>Назначение системы баз данных (СБД):</strong></p><p>Система баз данных предназначена для организации и управления большими объемами данных, обеспечивая эффективное хранение, обработку, доступ и защиту информации. Основной целью СБД является предоставление надежного и удобного механизма для работы с данными, обеспечивая одновременный доступ нескольких пользователей к общим данным и устраняя проблемы избыточности и несогласованности информации.</p><p><strong>Основные компоненты системы баз данных:</strong></p><ol><li><p><strong>База данных (БД):</strong> Является основным компонентом системы. Это организованная коллекция данных, хранящихся в структурированной форме для обеспечения эффективного доступа и управления. База данных содержит информацию, которую необходимо хранить и обрабатывать.</p></li><li><p><strong>Система управления базами данных (СУБД):</strong> Это программное обеспечение, которое обеспечивает управление базой данных. СУБД предоставляет средства для создания, обновления, удаления и запросов данных в базе данных. Она отвечает за выполнение операций с данными и обеспечение целостности и безопасности информации.</p></li><li><p><strong>Язык запросов (SQL):</strong> SQL (Structured Query Language) - это стандартизированный язык запросов, который используется для работы с данными в базе данных. С помощью SQL можно выполнять запросы на выборку, вставку, обновление и удаление данных, а также создавать и управлять структурами таблиц и индексами.</p></li><li><p><strong>Метаданные:</strong> Метаданные представляют собой данные о структуре и характеристиках данных в базе данных. Они описывают, какие таблицы существуют, их поля, типы данных, ограничения, связи между таблицами и другие сведения, необходимые для правильной интерпретации и использования данных.</p></li><li><p><strong>Интерфейс пользователя:</strong> Это компонент, который обеспечивает взаимодействие между пользователями и системой баз данных. Интерфейс может быть текстовым, графическим или веб-приложением, предоставляющим пользователю возможность выполнять запросы, вносить изменения в данные и просматривать результаты операций.</p></li><li><p><strong>Физическая структура данных:</strong> Это способ, которым данные физически хранятся на устройствах хранения, таких как жесткие диски. Физическая структура данных включает таблицы, индексы, файлы данных и другие элементы, необходимые для оптимальной организации и доступа к данным.</p></li><li><p><strong>Безопасность и контроль доступа:</strong> Этот компонент обеспечивает защиту данных от несанкционированного доступа. Система баз данных может управлять правами доступа пользователей к данным, контролировать авторизацию и аутентификацию пользователей и применять другие меры безопасности для защиты информации.</p></li><li><p><strong>Средства резервного копирования и восстановления:</strong> Это механизмы, которые обеспечивают создание резервных копий данных и возможность восстановления данных в случае сбоев или ошибок.</p></li></ol><p><strong>Все эти компоненты совместно образуют систему баз данных, которая обеспечивает эффективную работу с данными и обеспечивает целостность, доступность и безопасность информации.</strong></p></div>"],["Уровни представления баз данных; понятия схемы и подсхемы.","<div class=\\"markdown prose w-full break-words dark:prose-invert light\\"><p><strong>Уровни представления баз данных; понятия схемы и подсхемы:</strong></p><p><strong>Уровни представления баз данных:</strong></p><p>В базах данных существует три уровня представления данных, которые описывают различные аспекты данных и представления информации:</p><ol><li><p><strong>Внешний уровень (пользовательский уровень):</strong> Это уровень, который виден конечным пользователям или прикладным программам. На этом уровне определены внешние схемы, которые предоставляют удобный интерфейс для работы с данными и соответствуют потребностям конкретных пользователей или приложений. Каждый пользователь может видеть только ту часть данных, которая ему необходима, и иметь свой набор операций на данных.</p></li><li><p><strong>Концептуальный уровень (логический уровень):</strong> На этом уровне определена концептуальная схема, которая описывает все данные в базе данных и их связи между собой независимо от конкретных приложений. Концептуальная схема является абстракцией, которая позволяет понять общую структуру данных и их логические связи. Этот уровень обеспечивает независимость данных от приложений и упрощает изменение структуры данных без влияния на пользователей.</p></li><li><p><strong>Внутренний уровень (физический уровень):</strong> На этом уровне определена физическая схема, которая описывает, как данные фактически хранятся на физических носителях, таких как жесткие диски. Физическая схема включает в себя информацию о структуре файлов, индексах, методах доступа к данным и других деталях, которые связаны с физическим размещением данных.</p></li></ol><p><strong>Понятия схемы и подсхемы:</strong></p><ul><li><p><strong>Схема базы данных:</strong> Схема базы данных представляет собой общее логическое описание всех данных в базе данных. Она определяет сущности, атрибуты, связи между сущностями и ограничения на данные. Схема базы данных создается на концептуальном уровне и определяет, как данные будут организованы и храниться.</p></li><li><p><strong>Подсхемы:</strong> Подсхемы представляют собой части схемы базы данных, которые описываются на внешнем уровне. Они предназначены для представления данных определенным группам пользователей или приложениям. Подсхемы обеспечивают пользовательские интерфейсы к данным, которые оптимизированы для конкретных нужд и предпочтений пользователей. Подсхемы позволяют скрыть детали организации базы данных от конечных пользователей и предоставить им удобные и понятные представления данных.</p></li></ul><p>Таким образом, уровни представления баз данных и понятия схемы и подсхемы играют важную роль в организации данных в базе данных, обеспечивая удобный доступ к информации для различных пользователей и приложений и обеспечивая независимость данных от конкретных приложений и физической структуры.</p></div>"],["Модели данных. Иерархическая, сетевая и реляционная модели данных; схема отношения.","<div class=\\"markdown prose w-full break-words dark:prose-invert light\\"><p><strong>Модели данных: Иерархическая, сетевая и реляционная модели данных; схема отношения:</strong></p><p><strong>Иерархическая модель данных:</strong></p><p>В иерархической модели данных данные представляются в виде иерархической структуры, состоящей из записей и связей между ними, образующих древовидную структуру. Каждая запись может иметь одного или нескольких потомков, и каждый потомок может быть связан только с одним родителем. Примерами иерархических баз данных являются системы IMS (Information Management System) и Windows Registry.</p><p><strong>Сетевая модель данных:</strong></p><p>В сетевой модели данных данные представляются в виде графа, где каждая запись может быть связана с несколькими другими записями, формируя сложные сетевые связи. Это позволяет более гибко представлять отношения между данными. Основной пример сетевой модели - CODASYL (Conference on Data Systems Languages).</p><p><strong>Реляционная модель данных:</strong></p><p>Реляционная модель данных основана на математической теории множеств и представляет данные в виде таблиц, называемых \\"отношениями\\". Каждая таблица состоит из строк (кортежей) и столбцов (атрибутов). Запросы на языке SQL (Structured Query Language) используются для манипулирования данными в реляционной модели. Реляционные базы данных являются наиболее распространенным типом баз данных в современных информационных системах.</p><p><strong>Схема отношения:</strong></p><p>Схема отношения (Relation Schema) определяет структуру и характеристики отношения в реляционной базе данных. Она определяет название отношения, список атрибутов, их типы данных и ограничения, которые применяются к данным в этом отношении.</p><p><strong>Пример схемы отношения:</strong></p><p>Предположим, у нас есть отношение \\"Сотрудники\\" с атрибутами \\"Имя\\", \\"Возраст\\" и \\"Зарплата\\". Тогда схема отношения будет выглядеть следующим образом:</p><pre><div class=\\"bg-black rounded-md mb-4\\"><div class=\\"flex items-center relative text-gray-200 bg-gray-800 px-4 py-2 text-xs font-sans justify-between rounded-t-md\\"><span>scss</span><button class=\\"flex ml-auto gap-2\\"><svg stroke=\\"currentColor\\" fill=\\"none\\" stroke-width=\\"2\\" viewBox=\\"0 0 24 24\\" stroke-linecap=\\"round\\" stroke-linejoin=\\"round\\" class=\\"h-4 w-4\\" height=\\"1em\\" width=\\"1em\\" xmlns=\\"http://www.w3.org/2000/svg\\"><path d=\\"M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2\\"></path><rect x=\\"8\\" y=\\"2\\" width=\\"8\\" height=\\"4\\" rx=\\"1\\" ry=\\"1\\"></rect></svg>Copy code</button></div><div class=\\"p-4 overflow-y-auto\\"><code class=\\"!whitespace-pre hljs language-scss\\">Сотрудники(Имя, Возраст, Зарплата)\\n</code></div></div></pre><p>Где \\"Имя\\", \\"Возраст\\" и \\"Зарплата\\" - это названия атрибутов, определяющих структуру отношения, а \\"Сотрудники\\" - это название самого отношения.</p><p>Схема отношения является статическим определением структуры данных, в то время как сами данные, хранящиеся в таблице, называются кортежами (строками). При добавлении данных в отношение или их изменении схема остается неизменной, и данные должны соответствовать этой схеме.</p></div>"],["Язык манипулирования данными для реляционной модели; Реляционная алгебра и язык SQL.","<div class=\\"markdown prose w-full break-words dark:prose-invert light\\"><p><strong>Язык манипулирования данными для реляционной модели; Реляционная алгебра и язык SQL:</strong></p><p><strong>Реляционная алгебра:</strong></p><p>Реляционная алгебра - это математический формализм для манипулирования данными в реляционной модели. Она представляет собой набор операций, которые применяются к отношениям (таблицам) и порождают новые отношения. Реляционная алгебра используется для выполнения запросов к базе данных и получения нужных данных.</p><p>Основные операции реляционной алгебры:</p><ol><li><p><strong>Выбор (Selection):</strong> Извлекает строки из отношения, которые удовлетворяют заданному условию.</p></li><li><p><strong>Проекция (Projection):</strong> Извлекает определенные атрибуты (столбцы) из отношения, игнорируя остальные.</p></li><li><p><strong>Объединение (Union):</strong> Объединяет два отношения с одинаковой структурой (одинаковое количество и типы атрибутов).</p></li><li><p><strong>Пересечение (Intersection):</strong> Извлекает общие строки из двух отношений с одинаковой структурой.</p></li><li><p><strong>Разность (Difference):</strong> Извлекает строки из первого отношения, которых нет во втором отношении.</p></li><li><p><strong>Декартово произведение (Cartesian Product):</strong> Образует все возможные комбинации строк из двух отношений.</p></li></ol><p><strong>Язык SQL (Structured Query Language):</strong></p><p>SQL - это стандартный язык запросов, используемый для манипулирования данными в реляционной базе данных. SQL позволяет выполнять операции выборки, вставки, обновления и удаления данных.</p><p>Основные операторы SQL:</p><ol><li><p><strong>SELECT:</strong> Используется для выборки данных из таблицы на основе заданных условий.</p></li><li><p><strong>INSERT:</strong> Используется для добавления новых строк в таблицу.</p></li><li><p><strong>UPDATE:</strong> Используется для обновления существующих строк в таблице на основе заданных условий.</p></li><li><p><strong>DELETE:</strong> Используется для удаления строк из таблицы на основе заданных условий.</p></li><li><p><strong>CREATE:</strong> Используется для создания новых таблиц, представлений (VIEW) и других объектов базы данных.</p></li><li><p><strong>ALTER:</strong> Используется для изменения структуры существующих таблиц или других объектов базы данных.</p></li><li><p><strong>DROP:</strong> Используется для удаления таблиц, представлений и других объектов базы данных.</p></li></ol><p>SQL обеспечивает удобный и декларативный способ взаимодействия с базой данных, позволяя выполнять сложные запросы с помощью простых и понятных команд.</p></div>"],["Проектирование реляционной базы данных на основе функциональных зависимостей. Функциональные зависимости, декомпозиция отношений, транзитивные зависимости.","<div class=\\"markdown prose w-full break-words dark:prose-invert light\\"><p><strong>Проектирование реляционной базы данных на основе функциональных зависимостей; функциональные зависимости, декомпозиция отношений, транзитивные зависимости:</strong></p><p><strong>Функциональные зависимости:</strong></p><p>Функциональная зависимость - это связь между атрибутами в отношении (таблице) базы данных. Она говорит о том, что значение одного атрибута определенным образом зависит от значения другого атрибута или группы атрибутов. Функциональные зависимости помогают определить свойства и связи данных в базе данных.</p><p>Если атрибут X функционально зависит от атрибута Y, то обозначается как Y -&gt; X, что означает, что каждому значению Y соответствует единственное значение X.</p><p><strong>Пример функциональной зависимости:</strong>\\nПредположим, у нас есть отношение \\"Сотрудники\\" с атрибутами \\"Имя\\", \\"Отдел\\", и \\"Зарплата\\". Если каждому сотруднику соответствует определенный отдел, тогда \\"Отдел\\" -&gt; \\"Имя\\", потому что зная отдел, мы можем однозначно определить имя сотрудника.</p><p><strong>Декомпозиция отношений:</strong></p><p>Декомпозиция отношений - это процесс разбиения одного отношения на несколько более мелких отношений с целью улучшения структуры базы данных и устранения аномалий.</p><p><strong>Пример декомпозиции отношения:</strong>\\nПредположим, у нас есть отношение \\"Заказы\\" с атрибутами \\"Номер заказа\\", \\"Дата заказа\\" и \\"Имя клиента\\". Если атрибут \\"Имя клиента\\" не зависит от атрибута \\"Номер заказа\\" и \\"Дата заказа\\", то отношение можно декомпозировать на два отношения: \\"Заказы\\" с атрибутами \\"Номер заказа\\" и \\"Дата заказа\\", и \\"Клиенты\\" с атрибутом \\"Имя клиента\\". Это упрощает структуру базы данных и избавляет от избыточности данных.</p><p><strong>Транзитивные зависимости:</strong></p><p>Транзитивная зависимость - это зависимость, которая возникает между атрибутами через другие атрибуты. Если атрибут A зависит от атрибута B, и атрибут B зависит от атрибута C, тогда A транзитивно зависит от C.</p><p><strong>Пример транзитивной зависимости:</strong>\\nПредположим, у нас есть отношение \\"Учебные курсы\\" с атрибутами \\"Номер курса\\", \\"Название курса\\" и \\"Преподаватель\\". Если \\"Номер курса\\" -&gt; \\"Название курса\\", и \\"Название курса\\" -&gt; \\"Преподаватель\\", тогда транзитивная зависимость будет \\"Номер курса\\" -&gt; \\"Преподаватель\\".</p><p>При проектировании реляционной базы данных, функциональные зависимости помогают определить правильную структуру таблиц и избежать избыточности и аномалий данных. Декомпозиция отношений и устранение транзитивных зависимостей позволяют улучшить эффективность и структуру базы данных.</p></div>"],["Проектирование с использованием метода «сущность – связь».","<div class=\\"markdown prose w-full break-words dark:prose-invert light\\"><p><strong>Проектирование с использованием метода \\"сущность – связь\\":</strong></p><p>Метод \\"сущность – связь\\" (Entity-Relationship, ER) - это семантический подход к проектированию баз данных, который используется для моделирования и описания данных в информационных системах. Основной целью этого метода является представление ключевых сущностей и их взаимосвязей в базе данных.</p><p><strong>Основные понятия метода \\"сущность – связь\\":</strong></p><ol><li><p><strong>Сущность (Entity):</strong> Сущность представляет реальный объект или концепцию, которая имеет уникальные и идентифицируемые характеристики. Каждая сущность обладает атрибутами, которые описывают ее свойства. Сущности представляются в виде прямоугольников с именем сущности.</p></li><li><p><strong>Атрибут (Attribute):</strong> Атрибуты представляют характеристики или свойства сущности. Они описывают информацию, которая хранится о сущности. Атрибуты представляются внутри сущности.</p></li><li><p><strong>Связь (Relationship):</strong> Связь представляет отношение между двумя или более сущностями. Она показывает, как сущности взаимодействуют или связаны друг с другом. Связи представляются линиями, которые соединяют связанные сущности.</p></li></ol><p><strong>Процесс проектирования методом \\"сущность – связь\\":</strong></p><ol><li><p><strong>Идентификация сущностей:</strong> Определение ключевых сущностей, которые будут представлены в базе данных, и их атрибутов.</p></li><li><p><strong>Определение связей:</strong> Определение типов связей между сущностями и их характеристик. Связи могут быть однонаправленными или двунаправленными и могут быть однозначными или многозначными.</p></li><li><p><strong>Атрибуты:</strong> Определение атрибутов для каждой сущности, описывающих ее характеристики.</p></li><li><p><strong>Кардинальность связей:</strong> Определение минимального и максимального количества связанных объектов для каждой стороны связи.</p></li><li><p><strong>Преобразование в схему базы данных:</strong> После определения всех сущностей, атрибутов и связей, метод \\"сущность – связь\\" может быть преобразован в схему базы данных, которая определяет таблицы сущностей и связи между ними.</p></li></ol><p>Метод \\"сущность – связь\\" позволяет ясно и структурированно представить данные и их взаимосвязи, что облегчает процесс проектирования баз данных и обеспечивает более легкое понимание структуры информационной системы.</p></div>"],["Создание и модификация базы данных.","<div class=\\"markdown prose w-full break-words dark:prose-invert light\\"><p><strong>Создание и модификация базы данных:</strong></p><p><strong>Создание базы данных:</strong></p><p>Создание базы данных - это процесс, при котором создается физическая структура, предназначенная для хранения данных. Оно включает в себя определение схемы базы данных, таблиц, атрибутов и других объектов, необходимых для хранения и организации данных.</p><ol><li><p><strong>Выбор СУБД:</strong> Сначала необходимо выбрать систему управления базами данных (СУБД), которую вы будете использовать для создания базы данных. Популярными СУБД являются MySQL, PostgreSQL, Oracle, Microsoft SQL Server и др.</p></li><li><p><strong>Определение схемы:</strong> Затем определяется схема базы данных, которая включает в себя набор таблиц и связей между ними. Каждая таблица должна иметь уникальное имя и определенные атрибуты (столбцы).</p></li><li><p><strong>Создание таблиц:</strong> После определения схемы происходит создание таблиц с использованием SQL команды CREATE TABLE. В команде указываются имена таблиц и их атрибуты с указанием типов данных.</p></li><li><p><strong>Определение первичных ключей и ограничений:</strong> Для каждой таблицы нужно определить первичный ключ, который уникально идентифицирует каждую запись в таблице. Также могут быть определены другие ограничения, такие как уникальные значения или ограничения целостности.</p></li><li><p><strong>Наполнение данными:</strong> После создания таблиц базу данных можно наполнить данными с помощью оператора INSERT, который добавляет новые записи в таблицы.</p></li></ol><p><strong>Модификация базы данных:</strong></p><p>Модификация базы данных - это процесс изменения структуры или данных в существующей базе данных.</p><ol><li><p><strong>Добавление новых таблиц или атрибутов:</strong> Можно добавлять новые таблицы или атрибуты к уже существующим таблицам. Это может потребоваться, если вам нужно расширить функциональность базы данных.</p></li><li><p><strong>Изменение атрибутов или ограничений:</strong> Можно изменять типы данных атрибутов, ограничения или другие параметры таблицы.</p></li><li><p><strong>Удаление таблиц или атрибутов:</strong> При необходимости можно удалить уже существующие таблицы или атрибуты из базы данных.</p></li><li><p><strong>Изменение данных:</strong> Можно изменять существующие данные в таблицах с помощью оператора UPDATE.</p></li><li><p><strong>Удаление данных:</strong> Можно удалять данные из таблиц с помощью оператора DELETE.</p></li><li><p><strong>Изменение ограничений целостности:</strong> Можно изменять правила и ограничения, которые обеспечивают целостность данных в базе данных.</p></li></ol><p>Важно производить модификацию базы данных осторожно, чтобы не нарушить целостность данных и не повредить структуру базы данных. Часто перед внесением изменений рекомендуется создать резервную копию базы данных, чтобы в случае ошибки можно было восстановить исходное состояние.</p></div>"],["Поиск, сортировка, индексирование базы данных.","<div class=\\"markdown prose w-full break-words dark:prose-invert light\\"><p><strong>Поиск, сортировка и индексирование базы данных:</strong></p><p><strong>Поиск в базе данных:</strong></p><p>Поиск в базе данных - это процесс нахождения конкретной информации или записей, удовлетворяющих заданным условиям. Для выполнения поиска в базе данных используется язык запросов, такой как SQL. Основные операторы SQL для поиска данных включают операторы SELECT, WHERE и LIKE.</p><ol><li><p><strong>Оператор SELECT:</strong> Используется для выборки данных из таблицы. Можно выбрать все столбцы или только определенные столбцы.</p></li><li><p><strong>Оператор WHERE:</strong> Используется для задания условия поиска. Можно указать условие для одного или нескольких столбцов, чтобы отобрать нужные записи.</p></li><li><p><strong>Оператор LIKE:</strong> Используется для поиска значений, соответствующих определенному шаблону. Например, можно использовать оператор LIKE для поиска строк, содержащих определенное слово или фразу.</p></li></ol><p><strong>Сортировка базы данных:</strong></p><p>Сортировка в базе данных - это процесс упорядочивания данных в таблице по определенным критериям. Для сортировки данных используется оператор ORDER BY в SQL. По умолчанию, данные сортируются в порядке возрастания, но можно указать ключевое слово DESC, чтобы выполнить сортировку в порядке убывания.</p><p><strong>Пример сортировки:</strong></p><pre><div class=\\"bg-black rounded-md mb-4\\"><div class=\\"flex items-center relative text-gray-200 bg-gray-800 px-4 py-2 text-xs font-sans justify-between rounded-t-md\\"><span>sql</span><button class=\\"flex ml-auto gap-2\\"><svg stroke=\\"currentColor\\" fill=\\"none\\" stroke-width=\\"2\\" viewBox=\\"0 0 24 24\\" stroke-linecap=\\"round\\" stroke-linejoin=\\"round\\" class=\\"h-4 w-4\\" height=\\"1em\\" width=\\"1em\\" xmlns=\\"http://www.w3.org/2000/svg\\"><path d=\\"M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2\\"></path><rect x=\\"8\\" y=\\"2\\" width=\\"8\\" height=\\"4\\" rx=\\"1\\" ry=\\"1\\"></rect></svg>Copy code</button></div><div class=\\"p-4 overflow-y-auto\\"><code class=\\"!whitespace-pre hljs language-sql\\"><span class=\\"hljs-keyword\\">SELECT</span> <span class=\\"hljs-operator\\">*</span> <span class=\\"hljs-keyword\\">FROM</span> employees <span class=\\"hljs-keyword\\">ORDER</span> <span class=\\"hljs-keyword\\">BY</span> last_name <span class=\\"hljs-keyword\\">ASC</span>;\\n</code></div></div></pre><p>В данном примере данные из таблицы \\"employees\\" будут отсортированы по фамилии сотрудников в алфавитном порядке.</p><p><strong>Индексирование базы данных:</strong></p><p>Индексирование - это процесс создания структуры данных, которая ускоряет поиск и сортировку данных в базе данных. Индексы создаются на определенных столбцах таблицы и содержат отсортированные значения из этих столбцов, что позволяет системе быстрее находить данные.</p><p>Преимущества использования индексов:</p><ul><li><p><strong>Ускорение поиска:</strong> Поиск данных с использованием индекса выполняется быстрее, так как системе необходимо просматривать только значения в индексе, а не все строки таблицы.</p></li><li><p><strong>Ускорение сортировки:</strong> Индексы также помогают ускорить сортировку данных, так как они представляют собой предварительно отсортированные структуры.</p></li></ul><p>Несмотря на преимущества, использование индексов требует дополнительных ресурсов для их поддержки, и они должны быть созданы с умом. Индексы должны использоваться на тех столбцах, которые часто используются для поиска или сортировки данных, и не рекомендуется создавать слишком много индексов, так как это может привести к избыточности и замедлению работы базы данных.</p></div>"],["Создание форм и отчетов.","<div class=\\"markdown prose w-full break-words dark:prose-invert light\\"><p><strong>Создание форм и отчетов:</strong></p><p><strong>Формы:</strong></p><p>Формы в базах данных представляют пользовательский интерфейс, который позволяет вводить, просматривать и редактировать данные в таблицах. Формы делают работу с базой данных более удобной и понятной для конечных пользователей, так как они скрывают сложности работы с SQL запросами.</p><p><strong>Основные функции форм:</strong></p><ol><li><p><strong>Ввод данных:</strong> Формы позволяют пользователям вводить новые данные в таблицы базы данных.</p></li><li><p><strong>Редактирование данных:</strong> С помощью форм пользователи могут редактировать существующие данные в таблицах.</p></li><li><p><strong>Просмотр данных:</strong> Формы предоставляют возможность просматривать данные из таблиц.</p></li><li><p><strong>Фильтрация и сортировка данных:</strong> Формы позволяют применять фильтры и сортировку данных для удобства работы с большим объемом информации.</p></li><li><p><strong>Валидация данных:</strong> Формы могут включать проверки и валидацию данных, чтобы предотвратить ввод некорректных или недопустимых значений.</p></li><li><p><strong>Отображение связанных данных:</strong> Формы могут отображать связанные данные из разных таблиц, чтобы обеспечить целостную информацию.</p></li></ol><p><strong>Отчеты:</strong></p><p>Отчеты представляют собой специально оформленную информацию, сгруппированную и отсортированную по определенным критериям. Отчеты позволяют представить данные в удобочитаемой и информативной форме, что помогает пользователям принимать решения на основе анализа данных.</p><p><strong>Основные функции отчетов:</strong></p><ol><li><p><strong>Агрегация данных:</strong> Отчеты могут суммировать, усреднять или иначе агрегировать данные, чтобы предоставить общую картину.</p></li><li><p><strong>Группировка данных:</strong> Данные в отчетах могут быть сгруппированы по определенным полям, что помогает увидеть связи и тенденции.</p></li><li><p><strong>Сортировка данных:</strong> Отчеты могут сортировать данные по определенным критериям для лучшего анализа.</p></li><li><p><strong>Фильтрация данных:</strong> Отчеты могут применять фильтры для отображения только тех данных, которые соответствуют определенным условиям.</p></li><li><p><strong>Визуализация данных:</strong> Отчеты могут включать графики, диаграммы и другие элементы визуализации для лучшего понимания данных.</p></li><li><p><strong>Экспорт данных:</strong> Отчеты могут быть экспортированы в различные форматы, такие как PDF, Excel, или HTML.</p></li></ol><p>Создание форм и отчетов делает работу с базами данных более удобной и эффективной, позволяя пользователям быстро получать и анализировать информацию. Формы и отчеты могут быть настроены в соответствии с потребностями конкретных пользователей и помогают сделать процесс работы с данными более удобным и продуктивным.</p></div>"],["Физическая организация базы данных. Хешированные, индексированные файлы;","<div class=\\"markdown prose w-full break-words dark:prose-invert light\\"><p><strong>Физическая организация базы данных: Хешированные и индексированные файлы:</strong></p><p><strong>Хешированные файлы (Hash Files):</strong></p><p>Хеш-файлы представляют собой один из методов физической организации данных в базе данных. В хеш-файлах используется хеш-функция для преобразования ключей данных в адреса блоков памяти, в которых хранятся соответствующие записи.</p><p><strong>Принцип работы хеш-файлов:</strong></p><ol><li><p><strong>Хеш-функция:</strong> При добавлении записи в хеш-файл, ключ данных пропускается через хеш-функцию, которая возвращает адрес блока памяти для хранения этой записи.</p></li><li><p><strong>Коллизии:</strong> Возможны ситуации, когда двум разным ключам соответствует один и тот же адрес блока памяти (коллизии). В этом случае могут использоваться различные методы разрешения коллизий, например, метод цепочек или открытой адресации.</p></li></ol><p><strong>Преимущества хеш-файлов:</strong></p><ul><li>Быстрый доступ к данным при известном ключе, так как хеш-функция напрямую указывает на местонахождение записи.</li><li>Отличный выбор, когда ключи данных часто известны и имеют равные вероятности.</li><li>Хорошая производительность при большом объеме данных, если хеш-функция хорошо спроектирована и коллизии минимизированы.</li></ul><p><strong>Недостатки хеш-файлов:</strong></p><ul><li>Сложности с поиском данных при неизвестных или неполных ключах, так как хеш-функция не может предоставить информацию о расположении.</li><li>Проблемы с производительностью при частом изменении данных или большом количестве коллизий.</li></ul><p><strong>Индексированные файлы (Indexed Files):</strong></p><p>Индексированные файлы - это еще один метод физической организации данных, который использует индексы для упорядочивания и быстрого доступа к данным. Индексы - это структуры данных, которые содержат ключи и адреса записей в файле данных.</p><p><strong>Принцип работы индексированных файлов:</strong></p><ol><li><p><strong>Индексы:</strong> Индексы содержат уникальные ключи и указатели на соответствующие записи в файле данных.</p></li><li><p><strong>Сортировка:</strong> Записи в файле данных могут быть упорядочены по ключу для более быстрого поиска и сортировки.</p></li></ol><p><strong>Преимущества индексированных файлов:</strong></p><ul><li>Быстрый доступ к данным при известном ключе, используя индекс.</li><li>Удобный для поиска данных по неизвестным или частично известным ключам.</li><li>Подходит для баз данных, в которых данные часто изменяются, так как изменение записей не требует перестроения всего файла.</li></ul><p><strong>Недостатки индексированных файлов:</strong></p><ul><li>Потребление дополнительного места для хранения индексов.</li><li>Дополнительная сложность при вставке и удалении записей, так как индексы должны поддерживаться актуальными.</li></ul><p>Выбор между хеш-файлами и индексированными файлами зависит от конкретных требований базы данных, частоты доступа к данным, количества изменений данных и объема данных.</p></div>"],["Защита баз данных. Целостность и сохранность баз данных.","<div class=\\"markdown prose w-full break-words dark:prose-invert light\\"><p><strong>Защита баз данных: Целостность и сохранность баз данных:</strong></p><p><strong>Целостность баз данных:</strong></p><p>Целостность баз данных - это обеспечение правильности и непротиворечивости данных в базе данных. Целостность гарантирует, что данные в базе данных остаются в согласованном и корректном состоянии. Целостность баз данных обычно поддерживается с помощью ограничений целостности.</p><p><strong>Ограничения целостности:</strong></p><p>Ограничения целостности - это правила, которые определяют допустимые значения и отношения между данными в базе данных. Они могут быть заданы на уровне схемы базы данных и включают:</p><ol><li><p><strong>Ограничения первичного ключа:</strong> Гарантируют уникальность идентификаторов для каждой записи в таблице.</p></li><li><p><strong>Ограничения уникальности:</strong> Обеспечивают уникальность значений в определенных столбцах или комбинациях столбцов.</p></li><li><p><strong>Ограничения NOT NULL:</strong> Устанавливают обязательность заполнения определенных столбцов, чтобы предотвратить появление нулевых значений.</p></li><li><p><strong>Ограничения внешнего ключа:</strong> Связывают данные между таблицами и обеспечивают целостность связей между данными.</p></li><li><p><strong>Ограничения проверки:</strong> Позволяют определить пользовательские правила и условия для данных.</p></li></ol><p><strong>Сохранность баз данных:</strong></p><p>Сохранность баз данных - это обеспечение безопасности и надежности данных в базе данных. Защита данных от потери, повреждения, несанкционированного доступа и разрушения является основным аспектом сохранности баз данных.</p><p><strong>Меры для обеспечения сохранности баз данных:</strong></p><ol><li><p><strong>Регулярное резервное копирование:</strong> Создание резервных копий баз данных, чтобы в случае потери или повреждения данных можно было восстановить базу данных до последнего сохраненного состояния.</p></li><li><p><strong>Аутентификация и авторизация:</strong> Использование систем аутентификации и авторизации для контроля доступа к базе данных и предотвращения несанкционированного доступа.</p></li><li><p><strong>Шифрование данных:</strong> Защита данных с использованием методов шифрования, чтобы предотвратить их понимание и использование злоумышленниками.</p></li><li><p><strong>Физическая защита серверов и хранилищ данных:</strong> Обеспечение физической безопасности серверов и хранилищ данных, чтобы предотвратить физический доступ к оборудованию.</p></li><li><p><strong>Обновление и патчи:</strong> Регулярное обновление и установка патчей для операционных систем и СУБД для предотвращения уязвимостей.</p></li><li><p><strong>Аудит и мониторинг:</strong> Ведение журналов аудита и мониторинга доступа к базе данных для обнаружения и предотвращения несанкционированных действий.</p></li></ol><p>Обеспечение целостности и сохранности данных - это критически важные аспекты в управлении базами данных. Эффективная защита данных помогает предотвратить потерю и повреждение данных, а также обеспечивает их надежное использование и доступность для авторизованных пользователей.</p></div>"]],"Конструирование программного обеспечения":[["Автономная и комплексная отладки модуля.","<div class=\\"markdown prose w-full break-words dark:prose-invert light\\"><p><strong>Автономная и комплексная отладка модуля:</strong></p><p><strong>Автономная отладка модуля:</strong></p><p>Автономная отладка модуля (также называемая локальной отладкой) - это процесс отладки программного модуля, который выполняется независимо от остальной части программы или системы. В этом случае отладка проводится только на уровне отдельного модуля, изолированного от других компонентов.</p><p><strong>Основные характеристики автономной отладки:</strong></p><ol><li><p><strong>Изоляция модуля:</strong> Модуль отделяется от других частей программы, и отладка ведется только в пределах этого модуля, не затрагивая другие компоненты системы.</p></li><li><p><strong>Независимость от внешних факторов:</strong> Автономная отладка не зависит от того, как модуль будет взаимодействовать с другими модулями или системой в целом.</p></li><li><p><strong>Упрощение процесса:</strong> Отладка на уровне отдельного модуля позволяет упростить процесс обнаружения и исправления ошибок, так как фокус сосредоточен только на конкретной части кода.</p></li></ol><p><strong>Комплексная отладка модуля:</strong></p><p>Комплексная отладка модуля (или глобальная отладка) - это процесс отладки, включающий не только отдельный модуль, но и его взаимодействие с другими модулями и компонентами программы или системы. В этом случае отладка проводится на уровне всей системы, а не только на уровне отдельных модулей.</p><p><strong>Основные характеристики комплексной отладки:</strong></p><ol><li><p><strong>Отслеживание взаимодействия:</strong> Комплексная отладка позволяет отслеживать взаимодействие между различными компонентами системы.</p></li><li><p><strong>Выявление ошибок взаимодействия:</strong> Позволяет обнаруживать ошибки и несоответствия, возникающие при работе нескольких модулей вместе.</p></li><li><p><strong>Контекст выполнения:</strong> При комплексной отладке учитывается контекст выполнения модулей в рамках всей системы, что может быть важным при обнаружении проблем.</p></li></ol><p><strong>Когда применяется каждый вид отладки:</strong></p><ul><li><p><strong>Автономная отладка:</strong> Применяется, когда необходимо сосредоточиться только на отдельном модуле, когда возможно, что ошибка находится только в его коде, и для тестирования функциональности модуля в изоляции.</p></li><li><p><strong>Комплексная отладка:</strong> Применяется, когда требуется выявить ошибки взаимодействия между компонентами, убедиться в корректной работе всей системы в целом, или при сложных ошибках, которые проявляются только при совместной работе нескольких модулей. Комплексная отладка может потребовать использования инструментов и техник, специфичных для отладки на уровне системы.</p></li></ul></div>"],["Архитектура программного средства. Понятие архитектуры, Основные классы ПС","<div class=\\"markdown prose w-full break-words dark:prose-invert light\\"><p><strong>Архитектура программного средства:</strong></p><p><strong>Понятие архитектуры программного средства:</strong></p><p>Архитектура программного средства (ПС) - это высокоуровневое описание структуры и организации программного продукта, определяющее взаимосвязи между его компонентами, а также правила и принципы их взаимодействия. Архитектура представляет собой основу, на которой строится весь программный продукт.</p><p><strong>Основные элементы архитектуры программного средства:</strong></p><ol><li><p><strong>Компоненты (модули):</strong> Это основные блоки программного продукта, которые выполняют определенные функции. Каждый компонент выполняет четко определенную задачу и может быть независимо разработан, тестирован и поддерживаем.</p></li><li><p><strong>Интерфейсы:</strong> Это точки взаимодействия между компонентами, через которые они обмениваются данными и вызывают друг друга. Интерфейсы определяют форматы данных, протоколы обмена и возможные операции, которые могут быть выполнены.</p></li><li><p><strong>Структура:</strong> Архитектура определяет организацию компонентов в иерархическую или другую структуру. Например, это может быть однослойная или многослойная архитектура, клиент-серверная, или другие организационные схемы.</p></li><li><p><strong>Поток управления и данных:</strong> Архитектура определяет порядок выполнения операций и передачи данных между компонентами. Это важно для обеспечения правильного функционирования программы.</p></li></ol><p><strong>Основные классы программных средств:</strong></p><ol><li><p><strong>Структурная архитектура:</strong> Программное средство организовано в виде иерархии компонентов, каждый из которых выполняет определенную функцию. Примеры включают клиент-серверные и многослойные архитектуры.</p></li><li><p><strong>Модульная архитектура:</strong> Программа разбивается на отдельные модули или компоненты, каждый из которых может быть разработан, тестирован и поддерживаться независимо.</p></li><li><p><strong>Компонентно-ориентированная архитектура:</strong> Программа строится вокруг повторно используемых компонентов, которые могут быть заменены или изменены без влияния на другие компоненты.</p></li><li><p><strong>Событийно-ориентированная архитектура:</strong> Программа реагирует на события, такие как пользовательские действия или сигналы от других компонентов, и выполняет соответствующие действия.</p></li><li><p><strong>Служба-ориентированная архитектура:</strong> Программа предоставляет определенные службы, которые могут быть использованы другими программами через определенные интерфейсы.</p></li><li><p><strong>Распределенная архитектура:</strong> Программа состоит из компонентов, которые могут быть размещены на разных узлах сети и взаимодействуют по сетевому протоколу.</p></li></ol><p>Выбор архитектуры зависит от требований программного продукта, характеристик разрабатываемой системы и потребностей пользователей. Правильно спроектированная архитектура способствует легкости сопровождения, масштабируемости и расширяемости программного средства.</p></div>"],["Аттестация программного средства. Методы оценки качества программного средства","<div class=\\"markdown prose w-full break-words dark:prose-invert light\\"><p><strong>Аттестация программного средства:</strong></p><p><strong>Аттестация программного средства</strong> - это процесс оценки и подтверждения соответствия программного продукта определенным стандартам, требованиям и спецификациям. Целью аттестации является обеспечение уверенности в том, что программное средство работает корректно, надежно и соответствует заданным критериям качества.</p><p><strong>Методы оценки качества программного средства:</strong></p><ol><li><p><strong>Тестирование:</strong></p><ul><li><strong>Модульное тестирование:</strong> Проверка отдельных модулей программы на правильность выполнения.</li><li><strong>Интеграционное тестирование:</strong> Проверка взаимодействия между различными модулями и компонентами программы.</li><li><strong>Системное тестирование:</strong> Проверка работы всей программы в целом, в различных условиях и сценариях использования.</li><li><strong>Приемочное тестирование:</strong> Проверка соответствия программы требованиям заказчика и готовности продукта к внедрению.</li></ul></li><li><p><strong>Статический анализ:</strong></p><ul><li><strong>Анализ кода:</strong> Проверка и анализ исходного кода программы с помощью статических анализаторов на предмет наличия ошибок, нарушения стандартов кодирования и потенциальных проблем.</li><li><strong>Анализ документации:</strong> Проверка документации на полноту, точность и соответствие требованиям.</li></ul></li><li><p><strong>Проверка требований и спецификаций:</strong></p><ul><li><strong>Верификация:</strong> Проверка того, что программное средство было разработано в соответствии с заданными требованиями и спецификациями.</li><li><strong>Валидация:</strong> Проверка того, что программное средство решает задачи и нужды пользователей.</li></ul></li><li><p><strong>Использование метрик:</strong></p><ul><li><strong>Метрики кода:</strong> Измерение характеристик и качества исходного кода программы, таких как сложность, размер, степень покрытия кода тестами и т. д.</li><li><strong>Метрики процесса разработки:</strong> Измерение характеристик процесса разработки, таких как время разработки, количество ошибок и т. д.</li></ul></li><li><p><strong>Экспертное оценивание:</strong> Оценка качества программного средства и его соответствия требованиям проводится экспертами, имеющими опыт в данной области.</p></li><li><p><strong>Сравнение с аналогичными программами:</strong> Проведение сравнительного анализа с аналогичными программами или с программами, которые уже успешно прошли аттестацию.</p></li><li><p><strong>Контроль качества в процессе разработки:</strong> Использование процессов и методологий, направленных на обеспечение высокого качества программного продукта на каждом этапе разработки.</p></li></ol><p>Комбинация этих методов и инструментов помогает достичь высокого уровня качества программного средства, обеспечивая его надежность, функциональность, безопасность и соответствие требованиям пользователей и заказчиков.</p></div>"],["Верификация и валидация.","<div class=\\"markdown prose w-full break-words dark:prose-invert light\\"><p><strong>Верификация и валидация:</strong></p><p><strong>Верификация:</strong></p><p><strong>Верификация</strong> - это процесс проверки того, что программное средство или система были правильно разработаны в соответствии с заданными спецификациями и требованиями. Она направлена на то, чтобы убедиться, что программное средство делает то, что от него ожидается на этапе разработки.</p><p><strong>Основные характеристики верификации:</strong></p><ol><li><p><strong>Осуществляется на ранних этапах:</strong> Верификация проводится на ранних стадиях жизненного цикла разработки программного средства, когда еще нет окончательного продукта.</p></li><li><p><strong>Статический процесс:</strong> Она обычно осуществляется без выполнения программы и включает проверку документации, спецификаций и исходного кода.</p></li><li><p><strong>Проверка правильности:</strong> Верификация проверяет, соответствует ли каждый этап разработки спецификациям и требованиям.</p></li><li><p><strong>Направлена на процесс разработки:</strong> Верификация оценивает процесс разработки, а не конечный продукт.</p></li><li><p><strong>Задача разработчиков:</strong> Обычно верификация выполняется разработчиками программного средства, хотя может быть вовлечены и другие члены команды.</p></li></ol><p><strong>Валидация:</strong></p><p><strong>Валидация</strong> - это процесс проверки того, что программное средство или система решает актуальные потребности пользователей и соответствует их ожиданиям. Она направлена на то, чтобы убедиться, что программное средство делает то, что требуется в реальных условиях эксплуатации.</p><p><strong>Основные характеристики валидации:</strong></p><ol><li><p><strong>Осуществляется на поздних этапах:</strong> Валидация проводится на поздних стадиях разработки, когда уже есть рабочий прототип или окончательный продукт.</p></li><li><p><strong>Динамический процесс:</strong> Она обычно осуществляется с выполнением программы в реальной среде.</p></li><li><p><strong>Проверка актуальности:</strong> Валидация проверяет, решает ли программное средство актуальные проблемы пользователей и соответствует ли его функциональность и требования реальным ситуациям.</p></li><li><p><strong>Направлена на продукт:</strong> Валидация оценивает окончательный продукт и его работу в реальных условиях.</p></li><li><p><strong>Задача пользователей и заказчиков:</strong> Валидацию часто выполняют пользователи, заказчики или независимые тестировщики, которые представляют интересы пользователей.</p></li></ol><p><strong>Сходства и различия между верификацией и валидацией:</strong></p><ul><li>Оба процесса направлены на обеспечение качества программного продукта.</li><li>Верификация фокусируется на процессе разработки и соответствии спецификациям, в то время как валидация проверяет соответствие реальным потребностям пользователей и ожиданиям.</li><li>Верификация выполняется на ранних стадиях разработки, в то время как валидация проводится на поздних стадиях, когда уже есть рабочий продукт.</li><li>Оба процесса выполняются с помощью различных методов тестирования, анализа и проверки, но имеют разные цели и охватывают разные аспекты программного продукта.</li></ul></div>"],["Внедрение, эксплуатация и сопровождение","<div class=\\"markdown prose w-full break-words dark:prose-invert light\\"><p><strong>Внедрение, эксплуатация и сопровождение:</strong></p><p><strong>Внедрение:</strong></p><p><strong>Внедрение</strong> - это процесс внедрения программного продукта или системы в реальную среду и начало ее использования пользователями. Этот этап следует за завершением разработки и тестирования программного продукта. Внедрение включает в себя различные деятельности, такие как установка программного обеспечения на целевые компьютеры, проведение обучения пользователей, подготовка документации, а также перенос данных, если это необходимо.</p><p><strong>Эксплуатация:</strong></p><p><strong>Эксплуатация</strong> - это фаза жизненного цикла программного продукта, когда она начинает свое активное использование пользователями для выполнения определенных задач и достижения целей. Этот этап может продолжаться в течение длительного времени, пока продукт остается востребованным и выполняет функции, для которых он предназначен. Во время эксплуатации пользователи используют программное средство для своих повседневных дел и решения задач.</p><p><strong>Сопровождение:</strong></p><p><strong>Сопровождение</strong> - это процесс поддержания и обновления программного продукта после его внедрения и во время эксплуатации. В течение времени могут возникать ошибки, требования пользователей могут меняться, возникают новые технические задачи, связанные с окружающей инфраструктурой, поэтому программное обеспечение требует регулярных обновлений и поддержки.</p><p><strong>Основные аспекты внедрения, эксплуатации и сопровождения:</strong></p><ol><li><p><strong>Подготовка к внедрению:</strong> Внедрение требует тщательной подготовки, включая обучение персонала, подготовку документации, создание резервных копий данных и тестирование на целевой среде.</p></li><li><p><strong>Обучение пользователей:</strong> Пользователи должны быть обучены работе с программным продуктом, чтобы использовать его эффективно и безопасно.</p></li><li><p><strong>Постоянное обновление:</strong> Программное обеспечение может регулярно обновляться и совершенствоваться для улучшения функциональности, исправления ошибок и решения новых требований пользователей.</p></li><li><p><strong>Поддержка пользователей:</strong> В процессе эксплуатации необходима поддержка пользователей, которые могут сталкиваться с проблемами, ошибками или нуждаться в помощи.</p></li><li><p><strong>Мониторинг производительности:</strong> Во время эксплуатации производительность программного средства может быть проанализирована и оптимизирована для обеспечения эффективной работы.</p></li><li><p><strong>Регулярное тестирование и обслуживание:</strong> Важно регулярно тестировать программное обеспечение и его компоненты, а также поддерживать его инфраструктуру и окружение в рабочем состоянии.</p></li><li><p><strong>Анализ обратной связи:</strong> Обратная связь от пользователей и заказчиков может помочь определить слабые места и предложить улучшения.</p></li></ol><p>Эффективное внедрение, эксплуатация и сопровождение программного продукта являются критическими этапами его жизненного цикла, чтобы обеспечить успешное функционирование и удовлетворение потребностей пользователей на протяжении всего срока службы продукта.</p></div>"],["Вспомогательные средства проектирования.","<div class=\\"markdown prose w-full break-words dark:prose-invert light\\"><p><strong>Вспомогательные средства проектирования:</strong></p><p>В конструировании программного обеспечения применяются различные вспомогательные средства и инструменты, которые помогают разработчикам более эффективно и точно выполнять процесс проектирования. Эти инструменты помогают автоматизировать некоторые задачи, обеспечивают визуальное представление структуры системы и помогают управлять и контролировать процесс проектирования.</p><p><strong>Некоторые из вспомогательных средств проектирования включают:</strong></p><ol><li><p><strong>Интегрированные среды разработки (IDE):</strong> Это программные средства, которые объединяют в себе редакторы кода, компиляторы, отладчики и другие инструменты для разработки программного обеспечения. IDE обеспечивают удобный интерфейс для написания, тестирования и отладки кода.</p></li><li><p><strong>UML-инструменты:</strong> UML (Unified Modeling Language) является стандартным языком моделирования, используемым для визуализации и описания различных аспектов системы. UML-инструменты позволяют разработчикам создавать UML-диаграммы, такие как диаграммы классов, диаграммы последовательности, диаграммы состояний и т. д.</p></li><li><p><strong>Кейсы применения (Use Case Tools):</strong> Кейсы применения используются для моделирования и описания функциональности системы из перспективы пользователей. Эти инструменты позволяют определить основные сценарии использования системы и взаимодействие между актерами и функциональностью.</p></li><li><p><strong>CASE-средства:</strong> CASE (Computer-Aided Software Engineering) представляют собой инструменты для автоматизации различных задач в процессе проектирования и разработки программного обеспечения. Это могут быть инструменты для управления требованиями, моделирования, тестирования, анализа и документирования.</p></li><li><p><strong>Отладчики:</strong> Отладчики - это программные средства, которые позволяют разработчикам искать и исправлять ошибки в программном коде. Отладчики обычно позволяют пошагово выполнять код, просматривать значения переменных, анализировать стек вызовов и т. д.</p></li><li><p><strong>Средства тестирования:</strong> Эти средства помогают разработчикам проводить тестирование программного обеспечения, включая модульное тестирование, интеграционное тестирование, системное тестирование и т. д. Они также могут предоставлять отчеты о результатах тестирования.</p></li><li><p><strong>Средства контроля версий:</strong> Средства контроля версий позволяют разработчикам управлять изменениями в коде и отслеживать различные версии программного обеспечения. Они обеспечивают возможность совместной работы нескольких разработчиков над проектом.</p></li></ol><p>Использование вспомогательных средств проектирования повышает эффективность и качество процесса конструирования программного обеспечения, облегчает визуализацию структуры и функциональности системы, а также упрощает совместную работу в команде разработчиков.</p></div>"],["Модульное программирование. Обобщенная структура модуля.","<div class=\\"markdown prose w-full break-words dark:prose-invert light\\"><p><strong>Модульное программирование и обобщенная структура модуля:</strong></p><p><strong>Модульное программирование</strong> - это методология разработки программного обеспечения, которая предполагает разделение программы на небольшие, логически связанные и независимые части, называемые модулями. Каждый модуль выполняет определенную функцию и может быть разработан и тестирован отдельно, что упрощает поддержку и расширение программы.</p><p><strong>Обобщенная структура модуля</strong> в модульном программировании обычно включает следующие элементы:</p><ol><li><p><strong>Интерфейс:</strong> Интерфейс модуля определяет, как внешние компоненты могут взаимодействовать с модулем. Это включает в себя определение функций, которые модуль предоставляет для использования другими частями программы, а также определение входных и выходных данных модуля.</p></li><li><p><strong>Реализация:</strong> Реализация модуля содержит код, который реализует функциональность модуля. Здесь определены алгоритмы и логика, которая обеспечивает выполнение задач модуля. Важно, чтобы реализация была изолирована от других модулей и не зависела от их внутренней реализации.</p></li><li><p><strong>Интерфейсные переменные:</strong> Модуль может использовать некоторые переменные, которые не являются его входными или выходными данными, но используются для обмена информацией с другими модулями или для сохранения промежуточных результатов.</p></li><li><p><strong>Зависимости:</strong> Зависимости модуля указывают на другие модули, от которых зависит данный модуль. Зависимости могут быть выражены в виде вызовов функций из других модулей или в виде использования их переменных.</p></li><li><p><strong>Документация:</strong> Важной частью обобщенной структуры модуля является документация, которая описывает назначение модуля, его интерфейс, ожидаемое поведение, а также ограничения и требования к его использованию.</p></li><li><p><strong>Тестирование:</strong> Каждый модуль должен быть хорошо протестирован, чтобы убедиться, что он выполняет свои функции правильно и не влияет на работу других модулей. Модульные тесты проверяют правильность работы отдельных модулей перед интеграцией в более крупные системы.</p></li></ol><p><strong>Преимущества модульного программирования:</strong></p><ul><li><p><strong>Модульность:</strong> Разделение программы на модули упрощает понимание, разработку и поддержку кода, так как каждый модуль решает отдельную задачу.</p></li><li><p><strong>Переиспользование:</strong> Модули могут быть переиспользованы в других проектах, что сокращает время разработки новых программ.</p></li><li><p><strong>Изоляция ошибок:</strong> Ошибка в одном модуле обычно не повлияет на работу остальной программы, что упрощает отладку и исправление ошибок.</p></li><li><p><strong>Параллельная разработка:</strong> Разработчики могут работать над разными модулями одновременно, что ускоряет процесс разработки.</p></li></ul><p>Модульное программирование способствует созданию более структурированных, понятных и надежных программных систем, что делает его популярным подходом в разработке программного обеспечения.</p></div>"],["Нисходящее тестирование. Преимущества нисходящего тестирования.","<div class=\\"markdown prose w-full break-words dark:prose-invert light\\"><p><strong>Нисходящее тестирование (Top-down testing):</strong></p><p><strong>Нисходящее тестирование</strong> - это метод тестирования программного обеспечения, при котором тестирование проводится начиная с верхнего уровня иерархии системы (как правило, с пользовательского интерфейса или внешнего интерфейса) и постепенно спускается на более низкие уровни иерархии, пока не будут протестированы все компоненты системы.</p><p><strong>Преимущества нисходящего тестирования:</strong></p><ol><li><p><strong>Раннее выявление критических ошибок:</strong> При нисходящем тестировании сначала тестируется верхний уровень системы, который обычно включает наиболее критические и важные функции. Это позволяет выявить критические ошибки и проблемы на ранних стадиях разработки, что уменьшает риск возникновения серьезных проблем в более поздних этапах разработки.</p></li><li><p><strong>Быстрая обратная связь:</strong> Нисходящее тестирование позволяет быстро получить обратную связь о работе системы на высоком уровне, что позволяет быстро выявлять проблемы и вносить изменения в дизайн или архитектуру системы при необходимости.</p></li><li><p><strong>Эффективное использование времени и ресурсов:</strong> Тестирование верхнего уровня системы может быть выполнено даже до того, как все низкоуровневые компоненты полностью разработаны. Это позволяет сэкономить время и ресурсы, так как можно начать тестирование на ранних этапах разработки.</p></li><li><p><strong>Легкость интеграции:</strong> При нисходящем тестировании тестирование верхних уровней системы проводится с имитацией нижних уровней (часто с помощью заглушек или фиктивных компонентов). Это упрощает процесс интеграции, так как можно начать тестирование высокоуровневых функций до завершения разработки всех компонентов.</p></li><li><p><strong>Поддержка параллельной разработки:</strong> Нисходящее тестирование позволяет разрабатывать различные части системы независимо друг от друга. Таким образом, различные команды разработчиков могут параллельно заниматься разработкой различных модулей или компонентов системы.</p></li><li><p><strong>Управляемость сложности:</strong> Тестирование верхнего уровня системы позволяет сосредотачиваться на функциональности и требованиях системы, не углубляясь в детали реализации. Это упрощает процесс управления сложностью системы.</p></li></ol><p>Нисходящее тестирование предоставляет эффективный подход для тестирования и разработки программного обеспечения, особенно при работе над крупными и сложными проектами, и позволяет обнаруживать и устранять проблемы на ранних этапах разработки.</p></div>"],["Обеспечение функциональности и надежности программного средства.","<div class=\\"markdown prose w-full break-words dark:prose-invert light\\"><p><strong>Обеспечение функциональности и надежности программного средства:</strong></p><p><strong>Обеспечение функциональности</strong> - это процесс разработки программного обеспечения с учетом заданных функциональных требований, которые определяют, какие функции и возможности должно предоставлять программное средство. Функциональные требования определяют поведение программы и описывают, что программа должна делать.</p><p><strong>Обеспечение надежности</strong> - это процесс разработки программного обеспечения с учетом требований к надежности и стабильности работы программы. Надежность программного средства определяет его способность выполнять свои функции без сбоев, ошибок и непредвиденных ситуаций.</p><p><strong>Некоторые методы и подходы для обеспечения функциональности и надежности программного средства:</strong></p><ol><li><p><strong>Тестирование:</strong> Тестирование - это процесс проверки программного средства на соответствие функциональным и надежностным требованиям. Оно включает в себя выполнение тестовых сценариев, сравнение результатов с ожидаемыми значениями и выявление ошибок и дефектов.</p></li><li><p><strong>Формальные методы верификации и валидации:</strong> Использование формальных методов позволяет математически доказать, что программное средство соответствует определенным спецификациям и не содержит ошибок или противоречий.</p></li><li><p><strong>Код-ревью:</strong> Код-ревью - это процесс проверки и анализа программного кода другими разработчиками для выявления ошибок, уязвимостей и несоответствий стандартам и соглашениям.</p></li><li><p><strong>Использование проверенных библиотек и компонентов:</strong> Использование стабильных и проверенных библиотек и компонентов может повысить надежность программного средства и уменьшить вероятность ошибок.</p></li><li><p><strong>Управление рисками:</strong> Анализ рисков и принятие соответствующих мер позволяют предотвращать проблемы и сбои на ранних стадиях разработки и внедрения программного обеспечения.</p></li><li><p><strong>Регулярные обновления и сопровождение:</strong> Регулярные обновления и сопровождение программного средства помогают исправлять ошибки, устранять уязвимости и добавлять новую функциональность для повышения надежности и функциональности программы.</p></li><li><p><strong>Техническая поддержка и обратная связь пользователей:</strong> Активная обратная связь от пользователей и предоставление технической поддержки помогают выявлять проблемы, связанные с функциональностью и надежностью программного средства, и принимать меры для их устранения.</p></li></ol><p>Обеспечение функциональности и надежности программного средства является критическим аспектом в процессе его разработки и использования. Эти подходы помогают создавать стабильные, эффективные и надежные программы, которые удовлетворяют потребности пользователей и бизнес-задачи.</p></div>"],["Объектный подход к разработке программных средств.","<div class=\\"markdown prose w-full break-words dark:prose-invert light\\"><p><strong>Объектный подход к разработке программных средств:</strong></p><p>Объектно-ориентированный подход (ООП) к разработке программных средств представляет собой методологию программирования, в которой программа рассматривается как совокупность взаимосвязанных объектов. Объекты объединяют данные (переменные) и операции (методы), которые манипулируют этими данными. Объекты взаимодействуют друг с другом, образуя сложную структуру, представляющую систему.</p><p><strong>Основные принципы объектно-ориентированного подхода:</strong></p><ol><li><p><strong>Инкапсуляция:</strong> Инкапсуляция означает объединение данных и методов, которые работают с этими данными, внутри объекта. Доступ к данным объекта осуществляется через его методы, что позволяет скрыть детали реализации и защитить данные от неправильного использования.</p></li><li><p><strong>Наследование:</strong> Наследование позволяет создавать новые классы на основе существующих классов (родительских) и наследовать их свойства и методы. Это позволяет повторно использовать код и создавать иерархии классов, что упрощает организацию программы и делает ее более гибкой и расширяемой.</p></li><li><p><strong>Полиморфизм:</strong> Полиморфизм позволяет использовать один и тот же метод или оператор для различных типов данных. Это достигается благодаря возможности классов иметь одинаковые методы с одинаковыми именами, но с различными реализациями.</p></li></ol><p><strong>Преимущества объектно-ориентированного подхода:</strong></p><ol><li><p><strong>Модульность и повторное использование кода:</strong> Объекты позволяют разбивать программу на независимые модули, что упрощает ее понимание и сопровождение. Кроме того, возможность наследования позволяет повторно использовать код, что уменьшает объем работы и повышает производительность.</p></li><li><p><strong>Гибкость и расширяемость:</strong> Объектно-ориентированный подход позволяет создавать иерархии классов, что облегчает добавление новых функций и расширение программы без изменения существующего кода.</p></li><li><p><strong>Повышенная надежность и устойчивость к ошибкам:</strong> Инкапсуляция и контролируемый доступ к данным позволяют изолировать ошибки в пределах объекта, что уменьшает вероятность влияния ошибок на другие части программы.</p></li><li><p><strong>Поддержка абстракции:</strong> ООП позволяет создавать абстракции, которые позволяют скрыть сложность реализации и сосредоточиться на важных аспектах программы.</p></li></ol><p>Объектно-ориентированный подход стал широко используемым методом разработки программного обеспечения, так как позволяет создавать сложные и гибкие программы, которые легко поддерживать и модифицировать. ООП также способствует повышению производительности и эффективности разработки.</p></div>"],["Основные факторы, влияющие на трудоемкость разработки комплексов программ. Длительность разработки программных средств.","<div class=\\"markdown prose w-full break-words dark:prose-invert light\\"><p><strong>Основные факторы, влияющие на трудоемкость разработки комплексов программ и длительность разработки программных средств:</strong></p><ol><li><p><strong>Объем и сложность программного продукта:</strong> Чем больше объем функциональности, требуемый от программного продукта, и чем сложнее его реализация, тем более трудоемкой будет разработка.</p></li><li><p><strong>Требования и изменения требований:</strong> Качественное определение требований к программному продукту и четкость их формулировки влияют на эффективность разработки. Неясные, изменяющиеся или поздно предоставленные требования могут существенно увеличить трудоемкость и продолжительность проекта.</p></li><li><p><strong>Квалификация команды разработчиков:</strong> Опыт и уровень знаний команды разработчиков существенно влияют на скорость и качество разработки. Команда, обладающая высокой квалификацией и опытом в разрабатываемой области, может справиться с проектом более быстро и эффективно.</p></li><li><p><strong>Методология разработки:</strong> Выбор методологии разработки, такой как водопадная, инкрементная, спиральная или Agile, также влияет на продолжительность проекта и его успех.</p></li><li><p><strong>Используемые технологии и инструменты:</strong> Использование современных технологий и инструментов для разработки может существенно ускорить процесс разработки и повысить качество программного продукта.</p></li><li><p><strong>Сроки и ограничения:</strong> Наличие жестких сроков или бюджетных ограничений может повлиять на трудоемкость разработки. Короткие сроки могут привести к необходимости использовать ускоренные методы разработки, что может повлиять на качество продукта.</p></li><li><p><strong>Коммуникация и взаимодействие с заказчиком:</strong> Эффективная коммуникация с заказчиком и понимание его требований позволяют избежать недопониманий и уточнений, что способствует более быстрой разработке.</p></li><li><p><strong>Тестирование и отладка:</strong> Тщательное тестирование и отладка программного продукта влияют на общую продолжительность разработки. Непредвиденные ошибки и задержки в этапе тестирования могут потребовать дополнительного времени для исправления.</p></li><li><p><strong>Сопровождение и поддержка:</strong> Необходимость в последующем сопровождении и поддержке программного продукта также может повлиять на длительность разработки.</p></li></ol><p>Все эти факторы взаимосвязаны и могут оказывать как положительное, так и отрицательное влияние на трудоемкость разработки и длительность проекта. Правильное управление и планирование проекта, а также использование современных подходов и инструментов помогут справиться с вызовами и обеспечить успешную разработку программного обеспечения.</p></div>"],["Основные этапы жизненного цикла программ.","<div class=\\"markdown prose w-full break-words dark:prose-invert light\\"><p><strong>Основные этапы жизненного цикла программного продукта:</strong></p><p>Жизненный цикл программного продукта представляет собой последовательность этапов, чередующихся с момента начала разработки и до его вывода из эксплуатации. Каждый этап выполняет определенные функции и имеет свои характерные особенности. В зависимости от методологии разработки и типа программного продукта, этапы могут называться и структурироваться по-разному, но общая схема может включать следующие основные этапы:</p><ol><li><p><strong>Планирование и анализ:</strong> На этом этапе определяются требования к программному продукту, формируется концепция проекта, определяются его цели и задачи. Производится оценка рисков и выработка стратегии разработки.</p></li><li><p><strong>Проектирование:</strong> В этом этапе разрабатывается детальное техническое задание, определяется архитектура программного продукта, выделяются его компоненты и модули, происходит проектирование интерфейсов.</p></li><li><p><strong>Разработка:</strong> На данном этапе происходит фактическое создание программного продукта на основе предварительно разработанного технического задания и проекта. Программисты пишут код, создают модули, интегрируют компоненты.</p></li><li><p><strong>Тестирование:</strong> Проводятся различные виды тестирования для выявления ошибок и дефектов в программном продукте. Этот этап помогает удостовериться в корректности и соответствии программы требованиям.</p></li><li><p><strong>Внедрение:</strong> На этом этапе программный продукт передается заказчику или ставится в эксплуатацию. Пользователи начинают использовать программу в реальных условиях.</p></li><li><p><strong>Эксплуатация:</strong> На этом этапе программное обеспечение активно используется пользователями. Возможно выполнение сопровождения и поддержки, а также выпуск обновлений.</p></li><li><p><strong>Снятие с эксплуатации:</strong> По истечении срока службы или по другим причинам программный продукт может быть выведен из эксплуатации и прекращена его поддержка.</p></li></ol><p>После завершения жизненного цикла программного продукта, возможно его удаление или архивирование, в случае, если он более не используется. Отдельные методологии разработки программного обеспечения могут иметь свои варианты этапов и дополнительные подходы, но общая схема этапов жизненного цикла остается применимой для большинства проектов.</p></div>"],["Особенности объектного подхода на этапе конструирования ПС.","<div class=\\"markdown prose w-full break-words dark:prose-invert light\\"><p><strong>Особенности объектного подхода на этапе конструирования программного средства:</strong></p><p>Объектно-ориентированный подход (ООП) является одним из важных подходов в разработке программного обеспечения. На этапе конструирования программного средства объектный подход предлагает следующие особенности:</p><ol><li><p><strong>Абстракция:</strong> Объекты в объектно-ориентированном подходе представляют абстракции реальных или виртуальных объектов, которые взаимодействуют друг с другом. На этапе конструирования ПС определяются классы объектов, их свойства и методы.</p></li><li><p><strong>Инкапсуляция:</strong> Классы объектов инкапсулируют данные и методы, относящиеся к этим данным. Это позволяет обеспечить контролируемый доступ к данным и скрыть детали реализации от внешних компонентов.</p></li><li><p><strong>Наследование:</strong> Наследование позволяет создавать новые классы на основе существующих, повторно использовать код и расширять функциональность. На этапе конструирования определяются иерархии классов и их взаимосвязи.</p></li><li><p><strong>Полиморфизм:</strong> Полиморфизм позволяет использовать один и тот же интерфейс для различных классов объектов. Это облегчает создание универсальных методов и функций, которые могут работать с разными типами объектов.</p></li><li><p><strong>Модульность:</strong> ООП способствует модульности программного кода. Каждый класс представляет собой модуль со своими функциями и данными. Это упрощает понимание и поддержку кода.</p></li><li><p><strong>Сокрытие информации:</strong> ООП позволяет скрыть реализацию методов и данных объектов. Это позволяет создавать надежные и защищенные программные средства.</p></li><li><p><strong>Повторное использование кода:</strong> Благодаря наследованию и полиморфизму объектно-ориентированный подход способствует повторному использованию кода, что уменьшает объем работы на этапе конструирования и улучшает общую эффективность разработки.</p></li><li><p><strong>Проектирование на уровне объектов:</strong> На этапе конструирования программного средства уделяется особое внимание проектированию классов объектов, определению их интерфейсов и взаимодействия между ними.</p></li></ol><p>В целом, объектно-ориентированный подход способствует созданию гибких, расширяемых и легко поддерживаемых программных средств. Он позволяет лучше организовать структуру программы и повысить ее модульность и удобство использования.</p></div>"],["Сложность программного обеспечения. Характерные черты","<div class=\\"markdown prose w-full break-words dark:prose-invert light\\"><p><strong>Сложность программного обеспечения и его характерные черты:</strong></p><p>Сложность программного обеспечения (ПО) является одним из ключевых аспектов в его разработке и оценке. Она отражает степень сложности и разнообразия элементов, взаимодействий и задач, которые выполняет программное средство. Характерные черты сложности программного обеспечения включают:</p><ol><li><p><strong>Многообразие компонентов:</strong> Сложные программные продукты часто состоят из большого числа компонентов (модулей, классов, библиотек), которые взаимодействуют между собой для решения задачи. При этом каждый компонент может выполнять свою уникальную функцию.</p></li><li><p><strong>Сложные зависимости:</strong> Компоненты программного обеспечения могут быть связаны между собой сложными зависимостями, что усложняет понимание взаимосвязей и может повлечь за собой проблемы при изменениях в коде.</p></li><li><p><strong>Сложность взаимодействия:</strong> Крупные программные системы обычно обеспечивают взаимодействие между множеством компонентов, что может привести к сложности синхронизации, обработки ошибок и контроля взаимодействия.</p></li><li><p><strong>Сложные алгоритмы:</strong> Сложные программные продукты часто требуют использования сложных алгоритмов для решения задач, таких как оптимизация, распределение ресурсов или обработка больших объемов данных.</p></li><li><p><strong>Трудности тестирования и отладки:</strong> Сложное программное обеспечение может быть труднее подвергнуть полному тестированию и отладке из-за большого объема кода, сложных взаимодействий и возможных побочных эффектов.</p></li><li><p><strong>Сложность поддержки:</strong> Сложное программное обеспечение может быть сложнее поддерживать в будущем из-за необходимости понимать и изменять множество компонентов.</p></li><li><p><strong>Высокая степень абстракции:</strong> Сложные программные продукты могут использовать высокую степень абстракции, что делает их более сложными для понимания и анализа.</p></li><li><p><strong>Зависимость от внешних факторов:</strong> В больших и сложных программных системах зависимость от внешних факторов (аппаратные и программные средства, сетевые условия и т. д.) может создавать дополнительные сложности.</p></li></ol><p>Управление сложностью программного обеспечения является важной задачей для разработчиков. Использование хороших практик программирования, модульности, абстракции, тестирования и документирования может помочь справиться с сложностью и сделать программное средство более понятным, устойчивым и легко поддерживаемым.</p></div>"]],"Тестирование программного обеспечения":[["Ручной контроль ПО. Основные методы ручного контроля","<div class=\\"markdown prose w-full break-words dark:prose-invert light\\"><p><strong>Ручной контроль программного обеспечения и основные методы ручного контроля:</strong></p><p>Ручной контроль программного обеспечения (ПО) представляет собой процесс проверки и оценки программы, выполняемый вручную людьми. Он играет важную роль в процессе тестирования ПО и обеспечивает выявление ошибок, недочетов и соответствие требованиям. Основные методы ручного контроля включают:</p><ol><li><p><strong>Тестирование ввода данных:</strong> Проверка корректности ввода данных в программу. Проверяется, как программа обрабатывает различные типы данных, пограничные значения и некорректные данные.</p></li><li><p><strong>Тестирование функциональности:</strong> Проверка функциональных возможностей программы в соответствии с требованиями и спецификацией. Проверяются основные функции программы и их правильное выполнение.</p></li><li><p><strong>Тестирование пользовательского интерфейса:</strong> Оценка удобства использования пользовательского интерфейса. Проверка навигации, взаимодействия с элементами управления, корректности отображения и т.д.</p></li><li><p><strong>Тестирование совместимости:</strong> Проверка работы программы на разных платформах, операционных системах, браузерах и аппаратных конфигурациях.</p></li><li><p><strong>Тестирование производительности:</strong> Оценка производительности программы при различных нагрузках. Проверка скорости выполнения операций и эффективности использования ресурсов.</p></li><li><p><strong>Тестирование безопасности:</strong> Проверка наличия уязвимостей и защищенности программы от несанкционированного доступа.</p></li><li><p><strong>Тестирование восстановления после сбоев:</strong> Проверка способности программы восстанавливаться после сбоев или ошибок.</p></li><li><p><strong>Тестирование на реальных данных:</strong> Проверка работы программы на реальных или симулированных данных для выявления проблем, которые могут возникнуть в реальных условиях использования.</p></li><li><p><strong>Тестирование локализации и интернационализации:</strong> Проверка работы программы с различными языками и региональными настройками.</p></li><li><p><strong>Тестирование документации:</strong> Проверка соответствия документации реальным функциям программы и актуальности информации.</p></li></ol><p>Ручной контроль позволяет выявить множество проблем и недочетов в программном обеспечении, особенно в ранних стадиях разработки. Однако он требует времени и усилий со стороны тестировщиков, и может быть менее эффективным в отношении обнаружения сложных ошибок, которые легче выявить с помощью автоматического тестирования. Поэтому ручной контроль часто дополняется автоматическими тестами для более полного обеспечения качества программного обеспечения.</p></div>"],["Структурное тестирование (тестирование «белого ящика»). Основные способы формирования тестовых наборов","<div class=\\"markdown prose w-full break-words dark:prose-invert light\\"><p><strong>Структурное тестирование (тестирование \\"белого ящика\\") и основные способы формирования тестовых наборов:</strong></p><p>Структурное тестирование, также известное как тестирование \\"белого ящика\\" или кодовое тестирование, основывается на анализе внутренней структуры программного кода и позволяет проверить различные пути выполнения программы. Основная цель структурного тестирования - обеспечить максимальное покрытие кода и выявить ошибки, связанные с логикой и потоком управления программы. Основные способы формирования тестовых наборов в структурном тестировании включают:</p><ol><li><p><strong>Тестирование по покрытию ветвей (Branch Coverage):</strong> При этом методе тестируются все возможные ветвления в программе, включая разветвления условных операторов (if-else, switch). Цель - проверить выполнение обеих веток каждого условного оператора.</p></li><li><p><strong>Тестирование по покрытию условий (Condition Coverage):</strong> В этом случае проверяются все возможные значения каждого логического условия внутри условных операторов.</p></li><li><p><strong>Тестирование по покрытию путей (Path Coverage):</strong> При таком тестировании все возможные пути выполнения программы анализируются и тестируются. Это может включать комбинации различных ветвей и условий.</p></li><li><p><strong>Тестирование по покрытию условий и путей (Decision/Condition and Path Coverage):</strong> Этот метод комбинирует покрытие условий и путей, чтобы обеспечить более полное тестирование программы.</p></li><li><p><strong>Тестирование по покрытию циклов (Loop Coverage):</strong> Этот метод направлен на проверку всех возможных путей в циклах, включая вход и выход из циклов и различные итерации.</p></li><li><p><strong>Тестирование по покрытию данных (Data Coverage):</strong> При таком тестировании проверяются все возможные значения переменных в программе, включая крайние случаи и недопустимые значения.</p></li><li><p><strong>Тестирование ошибок (Error Testing):</strong> Этот метод направлен на специфические ошибки в коде, такие как обработка исключений, проверка наличия и обработка ошибок и т.д.</p></li><li><p><strong>Тестирование граничных значений (Boundary Value Testing):</strong> При этом тестируются значения переменных, приближающиеся к граничным условиям, так как ошибки часто возникают именно на границах допустимых значений.</p></li></ol><p>Выбор определенного метода формирования тестовых наборов зависит от характеристик программы, требований к качеству, сроков и доступных ресурсов для тестирования. Обычно комбинация различных методов обеспечивает более полное и эффективное тестирование программного обеспечения.</p></div>"],["Функциональное тестирование (тестирование «черного ящика»). Основные способы формирования тестовых наборов","<div class=\\"markdown prose w-full break-words dark:prose-invert light\\"><p><strong>Функциональное тестирование (тестирование \\"черного ящика\\") и основные способы формирования тестовых наборов:</strong></p><p>Функциональное тестирование, также известное как тестирование \\"черного ящика\\", основывается на анализе функциональности программы без знания внутренней структуры кода. В этом типе тестирования проверяется соответствие программного продукта требованиям и ожидаемому поведению на основе внешних спецификаций. Основные способы формирования тестовых наборов в функциональном тестировании включают:</p><ol><li><p><strong>Тестирование граничных значений (Boundary Value Testing):</strong> Этот метод направлен на проверку поведения программы при граничных значениях входных данных или параметров, так как ошибки часто возникают именно на границах допустимых значений.</p></li><li><p><strong>Тестирование эквивалентных классов (Equivalence Class Testing):</strong> При этом методе входные данные разбиваются на классы эквивалентности, и для каждого класса выбираются представители для тестирования. Предполагается, что все данные в одном классе эквивалентности обладают схожим поведением.</p></li><li><p><strong>Тестирование взаимодействия (Scenario-based Testing):</strong> При этом методе тестируются различные сценарии взаимодействия пользователя с программой, включая последовательность действий и реакции программы на эти действия.</p></li><li><p><strong>Тестирование случайными данными (Random Testing):</strong> Этот метод предполагает генерацию случайных данных для тестирования программы. Он может помочь выявить неожиданные проблемы, которые могут возникнуть при нестандартных входных данных.</p></li><li><p><strong>Тестирование негативных сценариев (Negative Testing):</strong> При таком тестировании проверяется поведение программы при некорректных или недопустимых входных данных или действиях пользователя.</p></li><li><p><strong>Тестирование специальных случаев (Special Case Testing):</strong> При этом методе проверяется поведение программы в специфических условиях, таких как крайние случаи, пустые значения и т.д.</p></li><li><p><strong>Тестирование с использованием тестовых сценариев (Test Scenarios):</strong> Тестовые сценарии разрабатываются на основе требований и функциональных возможностей программы, и их выполнение позволяет проверить соответствие программы требованиям.</p></li></ol><p>Выбор определенного метода формирования тестовых наборов зависит от характеристик программы, сложности функциональности и требований к качеству программного обеспечения. Часто комбинация различных методов обеспечивает более полное тестирование и повышает уверенность в работоспособности программы в различных ситуациях.</p></div>"],["Организация процесса тестирования ПО. Методика тестирования. Тестирование модулей. Нисходящее и восходящее тестирование интеграции. Оценочное тестирование","<div class=\\"markdown prose w-full break-words dark:prose-invert light\\"><p><strong>Организация процесса тестирования ПО и методики тестирования:</strong></p><p>Организация процесса тестирования программного обеспечения (ПО) является важной частью разработки качественного и надежного программного продукта. Она включает несколько этапов и методик, которые обеспечивают проверку работоспособности и соответствия ПО заданным требованиям.</p><p><strong>1. Методика тестирования:</strong>\\nМетодика тестирования - это план действий, определенный для проведения тестирования программного обеспечения. Она определяет, какие виды тестов будут проведены, в какой последовательности и с какими целями. Некоторые распространенные методики тестирования включают:</p><ul><li><p><strong>Методика \\"V-модели\\":</strong> В этом методе каждый этап разработки (анализ, проектирование, кодирование) соответствует определенному этапу тестирования (тестирование модулей, интеграционное тестирование, системное тестирование и т.д.). Это позволяет обнаруживать ошибки на ранних этапах и снижает вероятность серьезных проблем на стадии завершения проекта.</p></li><li><p><strong>Методика \\"Spiral\\":</strong> Этот подход предполагает постоянный цикл повторного тестирования и уточнения требований. Процесс строится как спираль, где каждый оборот - это новый этап тестирования с уточнением и анализом.</p></li><li><p><strong>Методика \\"Agile\\" и \\"Scrum\\":</strong> Эти методики базируются на итеративном подходе, когда разработка и тестирование происходят параллельно в рамках коротких итераций. Они позволяют быстро вносить изменения и адаптироваться к новым требованиям.</p></li></ul><p><strong>2. Тестирование модулей:</strong>\\nТестирование модулей - это тестирование отдельных компонентов программного обеспечения (модулей). Основные методики тестирования модулей:</p><ul><li><p><strong>Методика белого ящика (структурное тестирование):</strong> Включает в себя тестирование отдельных функций и путей выполнения кода внутри модуля.</p></li><li><p><strong>Методика черного ящика (функциональное тестирование):</strong> Тестирование модулей на основе внешних требований и без знания внутренней структуры кода.</p></li></ul><p><strong>3. Нисходящее и восходящее тестирование интеграции:</strong></p><ul><li><p><strong>Нисходящее тестирование интеграции:</strong> При этом подходе интегрированные модули тестируются снизу вверх - от наименьшей степени зависимости до более комплексных систем.</p></li><li><p><strong>Восходящее тестирование интеграции:</strong> Здесь интеграционное тестирование проводится от верхнего уровня системы к низшим уровням, чтобы проверить соответствие всей системы требованиям и ожиданиям.</p></li></ul><p><strong>4. Оценочное тестирование:</strong>\\nОценочное тестирование, также известное как тестирование производительности, целевое тестирование или нагрузочное тестирование, используется для проверки производительности и стабильности системы при различных нагрузках. Это важно для оценки способности программного обеспечения справиться с реальной нагрузкой, такой как большое количество пользователей или объем данных.</p><p>Организация тестирования ПО может включать различные методики, в зависимости от характеристик проекта, требований и доступных ресурсов. Цель тестирования - обеспечить высокое качество программного обеспечения, выявить и устранить ошибки, а также удовлетворить потребности пользователей.</p></div>"],["Особенности тестирования объектно-ориентированных программных систем. Проектирование объектно-ориентированных тестовых вариантов","<div class=\\"markdown prose w-full break-words dark:prose-invert light\\"><p><strong>Особенности тестирования объектно-ориентированных программных систем:</strong></p><p>Тестирование объектно-ориентированных программных систем (ООПС) имеет свои особенности, связанные с основными принципами ООП и специфическими характеристиками объектно-ориентированного программирования. Ниже представлены основные особенности тестирования ООПС:</p><p><strong>1. Инкапсуляция:</strong> ООПС использует инкапсуляцию для сокрытия внутренних деталей объектов от внешнего мира. Это может создавать сложности при доступе к приватным частям объекта для целей тестирования. Необходимо использовать методы доступа (геттеры и сеттеры) для получения доступа к закрытым данным.</p><p><strong>2. Наследование:</strong> Наследование позволяет создавать новые классы на основе уже существующих. Это приводит к цепочке зависимостей между классами. При тестировании классов, унаследованных от других классов, нужно учитывать как поведение унаследованных методов, так и новые методы, добавленные в производные классы.</p><p><strong>3. Полиморфизм:</strong> Полиморфизм позволяет объектам одного класса проявлять свои свойства и методы по-разному в зависимости от контекста. При тестировании необходимо учитывать различное поведение объектов в зависимости от их типа и контекста использования.</p><p><strong>4. Классы и объекты:</strong> Тестирование объектно-ориентированных систем требует проверки корректности работы отдельных классов и их взаимодействия друг с другом в виде объектов. Необходимо убедиться, что объекты взаимодействуют верно и передают друг другу необходимую информацию.</p><p><strong>Проектирование объектно-ориентированных тестовых вариантов:</strong></p><p>Проектирование тестовых вариантов для объектно-ориентированных программных систем требует особого внимания к структуре и поведению классов. Важно учитывать особенности ООП и специфику каждого класса при разработке тестов. Ниже представлены основные этапы проектирования объектно-ориентированных тестовых вариантов:</p><p><strong>1. Выбор тестируемых классов:</strong> Определите классы, которые необходимо протестировать. Это могут быть классы с ключевой функциональностью или классы, в которых вероятнее всего могут возникать ошибки.</p><p><strong>2. Определение тестовых случаев:</strong> Определите различные сценарии использования классов и методов. Каждый сценарий станет тестовым случаем, который нужно будет протестировать на различные входные данные и ожидаемые результаты.</p><p><strong>3. Создание тестовых данных:</strong> Подготовьте тестовые данные для выполнения тестовых случаев. Это может включать различные комбинации входных данных, включая граничные случаи и ошибочные значения.</p><p><strong>4. Разработка тестовых сценариев:</strong> Напишите код тестов, используя фреймворки для тестирования, такие как JUnit для Java или pytest для Python. Убедитесь, что тесты покрывают все аспекты функциональности классов и проверяют их корректность.</p><p><strong>5. Тестирование взаимодействия классов:</strong> При тестировании объектно-ориентированных систем также следует убедиться в корректности взаимодействия классов между собой. Это может включать проверку правильного наследования, вызов методов друг друга и передачу данных между объектами.</p><p><strong>6. Автоматизация тестов:</strong> При большом количестве тестовых случаев рекомендуется автоматизировать процесс тестирования с использованием соответствующих инструментов и фреймворков. Это поможет упростить процесс тестирования и повысить его эффективность.</p><p>Проектирование объектно-ориентированных тестовых вариантов требует тщательного планирования и учета особенностей ООПС. Цель заключается в обеспечении полного и качественного покрытия функциональности программных классов и их взаимодействия, чтобы обнаружить и устранить ошибки до выпуска программного продукта.</p></div>"]],"Объектно-ориентированное программирование":[["Основные принципы объектно-ориентированного программирования. Абстрагирование и инкапсуляция. Наследование. Полиморфизм","<div class=\\"markdown prose w-full break-words dark:prose-invert light\\"><p><strong>Основные принципы объектно-ориентированного программирования (ООП):</strong></p><p><strong>1. Абстрагирование:</strong> Абстрагирование представляет собой процесс выделения ключевых характеристик объекта или явления и их представление в программе в виде абстракций. Абстракции позволяют скрыть детали реализации и сосредоточиться на существенных аспектах объекта или системы. В ООП абстракции реализуются с помощью классов и интерфейсов.</p><p><strong>2. Инкапсуляция:</strong> Инкапсуляция представляет собой механизм, который объединяет данные и методы, работающие с этими данными, в одном объекте. Таким образом, объект скрывает внутренние детали своей реализации от внешнего мира. Инкапсуляция обеспечивает контроль доступа к данным и защиту от несанкционированного доступа, что способствует безопасности и надежности программного кода.</p><p><strong>3. Наследование:</strong> Наследование позволяет создавать новые классы на основе уже существующих, называемых базовыми классами или суперклассами. Новый класс, который наследует свойства и методы от базового класса, называется производным классом или подклассом. Наследование позволяет унаследованным классам переиспользовать функциональность базовых классов и в то же время вносить свои собственные изменения.</p><p><strong>4. Полиморфизм:</strong> Полиморфизм позволяет объектам одного типа проявлять различное поведение, исходя из контекста. Это может быть достигнуто через переопределение методов (полиморфизм подтипов) или использование методов с одинаковыми именами, но разной реализацией (полиморфизм перегрузки). Полиморфизм способствует упрощению работы с объектами различных классов и обеспечивает гибкость при работе с типизированными данных.</p><p>Основные принципы объектно-ориентированного программирования обеспечивают гибкость, повторное использование кода, легкость поддержки и расширения программного обеспечения, а также уменьшение сложности программ. ООП позволяет разрабатывать структурированный и понятный код, что делает его предпочтительным подходом в различных областях разработки программных продуктов.</p></div>"],["Основные понятия объектного подхода Виды объектов. Характеристики объектов. Понятие класса","<div class=\\"markdown prose w-full break-words dark:prose-invert light\\"><p><strong>Основные понятия объектного подхода:</strong></p><p><strong>1. Объект:</strong> Объект - это экземпляр класса, который представляет собой уникальный инстанс со своими уникальными значениями для каждого из своих атрибутов. Объекты являются основными строительными блоками объектно-ориентированных программ. Они могут иметь состояние (значения своих атрибутов) и поведение (методы, которые они могут вызывать).</p><p><strong>2. Виды объектов:</strong> В объектно-ориентированном программировании выделяют три основных вида объектов:</p><ul><li><p>Объекты реального мира: Представляют реальные сущности, которые могут быть абстрагированы в программный код. Например, объект \\"автомобиль\\" или \\"пользователь\\".</p></li><li><p>Объекты абстрактного мира: Представляют абстрактные сущности, которые существуют только в контексте программы. Например, объекты, представляющие математические операции или управление программой.</p></li><li><p>Объекты классов: Представляют собой экземпляры классов, которые определяют структуру и поведение объектов.</p></li></ul><p><strong>3. Характеристики объектов:</strong> Объекты имеют две основные характеристики:</p><ul><li><p>Состояние (State): Состояние объекта определяет его текущие данные или значения атрибутов в определенный момент времени.</p></li><li><p>Поведение (Behavior): Поведение объекта определяет, какие операции или методы могут быть выполнены над объектом, и что он может делать.</p></li></ul><p><strong>4. Класс:</strong> Класс - это шаблон или формальное описание, определяющее структуру, состояние и поведение объектов, которые создаются на его основе. Класс определяет атрибуты (переменные) и методы (функции), которые могут быть использованы объектами этого класса. Класс является абстракцией, которая определяет общие характеристики для всех объектов этого типа.</p><p>В объектно-ориентированном программировании объекты являются основными строительными блоками, а классы представляют собой их обобщения и шаблоны. Использование объектов и классов позволяет создавать модульный, гибкий и легко поддерживаемый код.</p></div>"],["Состав класса. Дружественные функции. Статические элементы класса. Конструкторы и деструкторы.","<div class=\\"markdown prose w-full break-words dark:prose-invert light\\"><p><strong>Состав класса:</strong></p><p>Класс в объектно-ориентированном программировании имеет следующие основные составляющие:</p><ol><li><p><strong>Атрибуты (переменные класса):</strong> Это переменные, которые хранят состояние объектов класса. Атрибуты определяют характеристики объектов этого класса. Они могут быть публичными (public), приватными (private), или защищенными (protected), в зависимости от уровня доступа к ним.</p></li><li><p><strong>Методы (функции класса):</strong> Это функции, которые определяют поведение объектов класса. Методы позволяют объектам выполнять определенные операции или действия. Как и атрибуты, методы могут быть публичными, приватными или защищенными.</p></li><li><p><strong>Дружественные функции (friend functions):</strong> Дружественные функции - это функции, которые имеют доступ к приватным и защищенным членам класса, но они не являются членами самого класса. Таким образом, они могут взаимодействовать с объектами класса и использовать его приватные данные.</p></li><li><p><strong>Статические элементы класса (static):</strong> Статические элементы класса принадлежат не отдельным объектам, а самому классу. Они существуют в единственном экземпляре для всего класса, вне зависимости от количества созданных объектов. Статические атрибуты и методы можно вызывать напрямую через имя класса, без создания объекта.</p></li><li><p><strong>Конструкторы (constructors) и деструкторы (destructors):</strong> Конструкторы - это специальные методы класса, которые вызываются при создании нового объекта класса. Они выполняют инициализацию объекта и могут принимать аргументы для установки начальных значений атрибутов. Деструкторы - это также специальные методы класса, которые вызываются при удалении объекта класса или выходе за его область видимости. Деструкторы выполняют очистку памяти или другие завершающие операции.</p></li></ol><p>Класс определяет интерфейс, с помощью которого объекты данного класса взаимодействуют с внешним миром. Атрибуты и методы класса образуют его состояние и поведение соответственно. Дружественные функции и статические элементы предоставляют дополнительные возможности для управления и использования классом и его объектами. Конструкторы и деструкторы обеспечивают правильную инициализацию и освобождение ресурсов в процессе работы с объектами класса.</p></div>"],["Наследование. Простое и множественное наследование. Конструкторы и деструкторы производных классов","<div class=\\"markdown prose w-full break-words dark:prose-invert light\\"><p><strong>Наследование:</strong></p><p>Наследование является одним из основных принципов объектно-ориентированного программирования и позволяет создавать иерархии классов, где производные классы наследуют свойства и методы от базовых (родительских) классов.</p><ol><li><strong>Простое наследование:</strong> В простом наследовании класс может наследовать свойства и методы только от одного базового класса. Например:</li></ol><pre><div class=\\"bg-black rounded-md mb-4\\"><div class=\\"flex items-center relative text-gray-200 bg-gray-800 px-4 py-2 text-xs font-sans justify-between rounded-t-md\\"><span>cpp</span><button class=\\"flex ml-auto gap-2\\"><svg stroke=\\"currentColor\\" fill=\\"none\\" stroke-width=\\"2\\" viewBox=\\"0 0 24 24\\" stroke-linecap=\\"round\\" stroke-linejoin=\\"round\\" class=\\"h-4 w-4\\" height=\\"1em\\" width=\\"1em\\" xmlns=\\"http://www.w3.org/2000/svg\\"><path d=\\"M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2\\"></path><rect x=\\"8\\" y=\\"2\\" width=\\"8\\" height=\\"4\\" rx=\\"1\\" ry=\\"1\\"></rect></svg>Copy code</button></div><div class=\\"p-4 overflow-y-auto\\"><code class=\\"!whitespace-pre hljs language-cpp\\"><span class=\\"hljs-keyword\\">class</span> <span class=\\"hljs-title class_\\">Base</span> {\\n<span class=\\"hljs-keyword\\">public</span>:\\n    <span class=\\"hljs-function\\"><span class=\\"hljs-type\\">void</span> <span class=\\"hljs-title\\">someMethod</span><span class=\\"hljs-params\\">()</span> </span>{\\n        <span class=\\"hljs-comment\\">// Код метода</span>\\n    }\\n};\\n\\n<span class=\\"hljs-keyword\\">class</span> <span class=\\"hljs-title class_\\">Derived</span> : <span class=\\"hljs-keyword\\">public</span> Base {\\n<span class=\\"hljs-keyword\\">public</span>:\\n    <span class=\\"hljs-comment\\">// Здесь класс Derived наследует someMethod() от класса Base</span>\\n};\\n</code></div></div></pre><ol start=\\"2\\"><li><strong>Множественное наследование:</strong> В множественном наследовании класс может наследовать свойства и методы от нескольких базовых классов. Например:</li></ol><pre><div class=\\"bg-black rounded-md mb-4\\"><div class=\\"flex items-center relative text-gray-200 bg-gray-800 px-4 py-2 text-xs font-sans justify-between rounded-t-md\\"><span>cpp</span><button class=\\"flex ml-auto gap-2\\"><svg stroke=\\"currentColor\\" fill=\\"none\\" stroke-width=\\"2\\" viewBox=\\"0 0 24 24\\" stroke-linecap=\\"round\\" stroke-linejoin=\\"round\\" class=\\"h-4 w-4\\" height=\\"1em\\" width=\\"1em\\" xmlns=\\"http://www.w3.org/2000/svg\\"><path d=\\"M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2\\"></path><rect x=\\"8\\" y=\\"2\\" width=\\"8\\" height=\\"4\\" rx=\\"1\\" ry=\\"1\\"></rect></svg>Copy code</button></div><div class=\\"p-4 overflow-y-auto\\"><code class=\\"!whitespace-pre hljs language-cpp\\"><span class=\\"hljs-keyword\\">class</span> <span class=\\"hljs-title class_\\">Base1</span> {\\n<span class=\\"hljs-keyword\\">public</span>:\\n    <span class=\\"hljs-function\\"><span class=\\"hljs-type\\">void</span> <span class=\\"hljs-title\\">method1</span><span class=\\"hljs-params\\">()</span> </span>{\\n        <span class=\\"hljs-comment\\">// Код метода 1</span>\\n    }\\n};\\n\\n<span class=\\"hljs-keyword\\">class</span> <span class=\\"hljs-title class_\\">Base2</span> {\\n<span class=\\"hljs-keyword\\">public</span>:\\n    <span class=\\"hljs-function\\"><span class=\\"hljs-type\\">void</span> <span class=\\"hljs-title\\">method2</span><span class=\\"hljs-params\\">()</span> </span>{\\n        <span class=\\"hljs-comment\\">// Код метода 2</span>\\n    }\\n};\\n\\n<span class=\\"hljs-keyword\\">class</span> <span class=\\"hljs-title class_\\">Derived</span> : <span class=\\"hljs-keyword\\">public</span> Base1, <span class=\\"hljs-keyword\\">public</span> Base2 {\\n<span class=\\"hljs-keyword\\">public</span>:\\n    <span class=\\"hljs-comment\\">// Здесь класс Derived наследует method1() от Base1 и method2() от Base2</span>\\n};\\n</code></div></div></pre><p><strong>Конструкторы и деструкторы производных классов:</strong></p><p>При создании объектов производных классов, конструкторы базовых классов вызываются автоматически перед выполнением конструкторов производных классов. При удалении объектов, сначала вызываются деструкторы производных классов, а затем деструкторы базовых классов.</p><p>Если в производном классе не определен конструктор, то используется конструктор по умолчанию. Если в базовом классе нет конструктора без параметров, то нужно явно вызвать конструктор базового класса в списке инициализации производного класса.</p><pre><div class=\\"bg-black rounded-md mb-4\\"><div class=\\"flex items-center relative text-gray-200 bg-gray-800 px-4 py-2 text-xs font-sans justify-between rounded-t-md\\"><span>cpp</span><button class=\\"flex ml-auto gap-2\\"><svg stroke=\\"currentColor\\" fill=\\"none\\" stroke-width=\\"2\\" viewBox=\\"0 0 24 24\\" stroke-linecap=\\"round\\" stroke-linejoin=\\"round\\" class=\\"h-4 w-4\\" height=\\"1em\\" width=\\"1em\\" xmlns=\\"http://www.w3.org/2000/svg\\"><path d=\\"M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2\\"></path><rect x=\\"8\\" y=\\"2\\" width=\\"8\\" height=\\"4\\" rx=\\"1\\" ry=\\"1\\"></rect></svg>Copy code</button></div><div class=\\"p-4 overflow-y-auto\\"><code class=\\"!whitespace-pre hljs language-cpp\\"><span class=\\"hljs-keyword\\">class</span> <span class=\\"hljs-title class_\\">Base</span> {\\n<span class=\\"hljs-keyword\\">public</span>:\\n    <span class=\\"hljs-built_in\\">Base</span>(<span class=\\"hljs-type\\">int</span> value) {\\n        <span class=\\"hljs-comment\\">// Конструктор базового класса</span>\\n    }\\n};\\n\\n<span class=\\"hljs-keyword\\">class</span> <span class=\\"hljs-title class_\\">Derived</span> : <span class=\\"hljs-keyword\\">public</span> Base {\\n<span class=\\"hljs-keyword\\">public</span>:\\n    <span class=\\"hljs-built_in\\">Derived</span>(<span class=\\"hljs-type\\">int</span> value) : <span class=\\"hljs-built_in\\">Base</span>(value) {\\n        <span class=\\"hljs-comment\\">// Конструктор производного класса</span>\\n    }\\n};\\n</code></div></div></pre><p>При множественном наследовании порядок вызова конструкторов и деструкторов зависит от порядка указания базовых классов в списке наследования. Деструкторы вызываются в обратном порядке, от производных классов к базовым.</p></div>"],["Полиморфизм. Виртуальные функции. Абстрактные классы","<div class=\\"markdown prose w-full break-words dark:prose-invert light\\"><p><strong>Полиморфизм:</strong></p><p>Полиморфизм - это возможность объектов различных типов обрабатываться одним и тем же обобщенным способом. В объектно-ориентированном программировании полиморфизм достигается через использование виртуальных функций и абстрактных классов.</p><p><strong>Виртуальные функции:</strong></p><p>Виртуальные функции - это функции, объявленные в базовом классе с ключевым словом <code>virtual</code>, и которые могут быть переопределены в производных классах. При вызове виртуальной функции через указатель или ссылку на базовый класс будет вызвана соответствующая функция производного класса.</p><p>Пример:</p><pre><div class=\\"bg-black rounded-md mb-4\\"><div class=\\"flex items-center relative text-gray-200 bg-gray-800 px-4 py-2 text-xs font-sans justify-between rounded-t-md\\"><span>cpp</span><button class=\\"flex ml-auto gap-2\\"><svg stroke=\\"currentColor\\" fill=\\"none\\" stroke-width=\\"2\\" viewBox=\\"0 0 24 24\\" stroke-linecap=\\"round\\" stroke-linejoin=\\"round\\" class=\\"h-4 w-4\\" height=\\"1em\\" width=\\"1em\\" xmlns=\\"http://www.w3.org/2000/svg\\"><path d=\\"M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2\\"></path><rect x=\\"8\\" y=\\"2\\" width=\\"8\\" height=\\"4\\" rx=\\"1\\" ry=\\"1\\"></rect></svg>Copy code</button></div><div class=\\"p-4 overflow-y-auto\\"><code class=\\"!whitespace-pre hljs language-cpp\\"><span class=\\"hljs-keyword\\">class</span> <span class=\\"hljs-title class_\\">Shape</span> {\\n<span class=\\"hljs-keyword\\">public</span>:\\n    <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">virtual</span> <span class=\\"hljs-type\\">void</span> <span class=\\"hljs-title\\">draw</span><span class=\\"hljs-params\\">()</span> </span>{\\n        <span class=\\"hljs-comment\\">// Реализация базовой функции draw</span>\\n    }\\n};\\n\\n<span class=\\"hljs-keyword\\">class</span> <span class=\\"hljs-title class_\\">Circle</span> : <span class=\\"hljs-keyword\\">public</span> Shape {\\n<span class=\\"hljs-keyword\\">public</span>:\\n    <span class=\\"hljs-function\\"><span class=\\"hljs-type\\">void</span> <span class=\\"hljs-title\\">draw</span><span class=\\"hljs-params\\">()</span> <span class=\\"hljs-keyword\\">override</span> </span>{\\n        <span class=\\"hljs-comment\\">// Реализация функции draw для класса Circle</span>\\n    }\\n};\\n\\n<span class=\\"hljs-keyword\\">class</span> <span class=\\"hljs-title class_\\">Square</span> : <span class=\\"hljs-keyword\\">public</span> Shape {\\n<span class=\\"hljs-keyword\\">public</span>:\\n    <span class=\\"hljs-function\\"><span class=\\"hljs-type\\">void</span> <span class=\\"hljs-title\\">draw</span><span class=\\"hljs-params\\">()</span> <span class=\\"hljs-keyword\\">override</span> </span>{\\n        <span class=\\"hljs-comment\\">// Реализация функции draw для класса Square</span>\\n    }\\n};\\n</code></div></div></pre><p><strong>Абстрактные классы:</strong></p><p>Абстрактный класс - это класс, который содержит хотя бы одну чисто виртуальную функцию. Чисто виртуальная функция объявляется в базовом классе без определения, используя <code>= 0</code>. Абстрактные классы не могут быть инстанцированы (созданы объекты), но они могут быть использованы в качестве интерфейсов для производных классов.</p><p>Пример:</p><pre><div class=\\"bg-black rounded-md mb-4\\"><div class=\\"flex items-center relative text-gray-200 bg-gray-800 px-4 py-2 text-xs font-sans justify-between rounded-t-md\\"><span>cpp</span><button class=\\"flex ml-auto gap-2\\"><svg stroke=\\"currentColor\\" fill=\\"none\\" stroke-width=\\"2\\" viewBox=\\"0 0 24 24\\" stroke-linecap=\\"round\\" stroke-linejoin=\\"round\\" class=\\"h-4 w-4\\" height=\\"1em\\" width=\\"1em\\" xmlns=\\"http://www.w3.org/2000/svg\\"><path d=\\"M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2\\"></path><rect x=\\"8\\" y=\\"2\\" width=\\"8\\" height=\\"4\\" rx=\\"1\\" ry=\\"1\\"></rect></svg>Copy code</button></div><div class=\\"p-4 overflow-y-auto\\"><code class=\\"!whitespace-pre hljs language-cpp\\"><span class=\\"hljs-keyword\\">class</span> <span class=\\"hljs-title class_\\">Shape</span> {\\n<span class=\\"hljs-keyword\\">public</span>:\\n    <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">virtual</span> <span class=\\"hljs-type\\">void</span> <span class=\\"hljs-title\\">draw</span><span class=\\"hljs-params\\">()</span> </span>= <span class=\\"hljs-number\\">0</span>; <span class=\\"hljs-comment\\">// Чисто виртуальная функция</span>\\n};\\n\\n<span class=\\"hljs-keyword\\">class</span> <span class=\\"hljs-title class_\\">Circle</span> : <span class=\\"hljs-keyword\\">public</span> Shape {\\n<span class=\\"hljs-keyword\\">public</span>:\\n    <span class=\\"hljs-function\\"><span class=\\"hljs-type\\">void</span> <span class=\\"hljs-title\\">draw</span><span class=\\"hljs-params\\">()</span> <span class=\\"hljs-keyword\\">override</span> </span>{\\n        <span class=\\"hljs-comment\\">// Реализация функции draw для класса Circle</span>\\n    }\\n};\\n\\n<span class=\\"hljs-keyword\\">class</span> <span class=\\"hljs-title class_\\">Square</span> : <span class=\\"hljs-keyword\\">public</span> Shape {\\n<span class=\\"hljs-keyword\\">public</span>:\\n    <span class=\\"hljs-function\\"><span class=\\"hljs-type\\">void</span> <span class=\\"hljs-title\\">draw</span><span class=\\"hljs-params\\">()</span> <span class=\\"hljs-keyword\\">override</span> </span>{\\n        <span class=\\"hljs-comment\\">// Реализация функции draw для класса Square</span>\\n    }\\n};\\n</code></div></div></pre><p>Абстрактные классы предоставляют общий интерфейс для различных классов и позволяют реализовать полиморфизм через виртуальные функции.</p></div>"],["Параметризованные функции и классы. Стандартная библиотека шаблонов (STL)","<div class=\\"markdown prose w-full break-words dark:prose-invert light\\"><p><strong>Параметризованные функции и классы:</strong></p><p>Параметризованные функции и классы - это функции и классы, которые могут принимать один или несколько параметров, называемых шаблонными параметрами. Шаблонные параметры позволяют создавать универсальные и переиспользуемые функции и классы, которые могут работать с различными типами данных, без необходимости написания отдельного кода для каждого типа.</p><p><strong>Пример параметризованной функции:</strong></p><pre><div class=\\"bg-black rounded-md mb-4\\"><div class=\\"flex items-center relative text-gray-200 bg-gray-800 px-4 py-2 text-xs font-sans justify-between rounded-t-md\\"><span>cpp</span><button class=\\"flex ml-auto gap-2\\"><svg stroke=\\"currentColor\\" fill=\\"none\\" stroke-width=\\"2\\" viewBox=\\"0 0 24 24\\" stroke-linecap=\\"round\\" stroke-linejoin=\\"round\\" class=\\"h-4 w-4\\" height=\\"1em\\" width=\\"1em\\" xmlns=\\"http://www.w3.org/2000/svg\\"><path d=\\"M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2\\"></path><rect x=\\"8\\" y=\\"2\\" width=\\"8\\" height=\\"4\\" rx=\\"1\\" ry=\\"1\\"></rect></svg>Copy code</button></div><div class=\\"p-4 overflow-y-auto\\"><code class=\\"!whitespace-pre hljs language-cpp\\"><span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">template</span>&lt;<span class=\\"hljs-keyword\\">typename</span> T&gt;\\nT <span class=\\"hljs-title\\">maximum</span><span class=\\"hljs-params\\">(T a, T b)</span> </span>{\\n    <span class=\\"hljs-keyword\\">return</span> (a &gt; b) ? a : b;\\n}\\n</code></div></div></pre><p><strong>Пример параметризованного класса:</strong></p><pre><div class=\\"bg-black rounded-md mb-4\\"><div class=\\"flex items-center relative text-gray-200 bg-gray-800 px-4 py-2 text-xs font-sans justify-between rounded-t-md\\"><span>cpp</span><button class=\\"flex ml-auto gap-2\\"><svg stroke=\\"currentColor\\" fill=\\"none\\" stroke-width=\\"2\\" viewBox=\\"0 0 24 24\\" stroke-linecap=\\"round\\" stroke-linejoin=\\"round\\" class=\\"h-4 w-4\\" height=\\"1em\\" width=\\"1em\\" xmlns=\\"http://www.w3.org/2000/svg\\"><path d=\\"M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2\\"></path><rect x=\\"8\\" y=\\"2\\" width=\\"8\\" height=\\"4\\" rx=\\"1\\" ry=\\"1\\"></rect></svg>Copy code</button></div><div class=\\"p-4 overflow-y-auto\\"><code class=\\"!whitespace-pre hljs language-cpp\\"><span class=\\"hljs-keyword\\">template</span>&lt;<span class=\\"hljs-keyword\\">typename</span> T&gt;\\n<span class=\\"hljs-keyword\\">class</span> <span class=\\"hljs-title class_\\">Stack</span> {\\n<span class=\\"hljs-keyword\\">private</span>:\\n    T* data;\\n    <span class=\\"hljs-type\\">int</span> top;\\n    <span class=\\"hljs-type\\">int</span> capacity;\\n\\n<span class=\\"hljs-keyword\\">public</span>:\\n    <span class=\\"hljs-comment\\">// Конструктор</span>\\n    <span class=\\"hljs-built_in\\">Stack</span>(<span class=\\"hljs-type\\">int</span> size) {\\n        data = <span class=\\"hljs-keyword\\">new</span> T[size];\\n        top = <span class=\\"hljs-number\\">-1</span>;\\n        capacity = size;\\n    }\\n\\n    <span class=\\"hljs-comment\\">// Добавить элемент в стек</span>\\n    <span class=\\"hljs-function\\"><span class=\\"hljs-type\\">void</span> <span class=\\"hljs-title\\">push</span><span class=\\"hljs-params\\">(T element)</span> </span>{\\n        <span class=\\"hljs-keyword\\">if</span> (top &lt; capacity - <span class=\\"hljs-number\\">1</span>) {\\n            data[++top] = element;\\n        }\\n    }\\n\\n    <span class=\\"hljs-comment\\">// Извлечь элемент из стека</span>\\n    <span class=\\"hljs-function\\">T <span class=\\"hljs-title\\">pop</span><span class=\\"hljs-params\\">()</span> </span>{\\n        <span class=\\"hljs-keyword\\">if</span> (top &gt;= <span class=\\"hljs-number\\">0</span>) {\\n            <span class=\\"hljs-keyword\\">return</span> data[top--];\\n        }\\n        <span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-built_in\\">T</span>();\\n    }\\n};\\n</code></div></div></pre><p><strong>Стандартная библиотека шаблонов (STL):</strong></p><p>Стандартная библиотека шаблонов (STL) - это часть стандартной библиотеки C++, которая предоставляет широкий набор готовых шаблонных контейнеров и алгоритмов для упрощения программирования. STL включает контейнеры, такие как векторы, списки, множества и карты, а также алгоритмы, такие как сортировка, поиск, удаление элементов и т.д.</p><p>Пример использования STL для сортировки вектора:</p><pre><div class=\\"bg-black rounded-md mb-4\\"><div class=\\"flex items-center relative text-gray-200 bg-gray-800 px-4 py-2 text-xs font-sans justify-between rounded-t-md\\"><span>cpp</span><button class=\\"flex ml-auto gap-2\\"><svg stroke=\\"currentColor\\" fill=\\"none\\" stroke-width=\\"2\\" viewBox=\\"0 0 24 24\\" stroke-linecap=\\"round\\" stroke-linejoin=\\"round\\" class=\\"h-4 w-4\\" height=\\"1em\\" width=\\"1em\\" xmlns=\\"http://www.w3.org/2000/svg\\"><path d=\\"M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2\\"></path><rect x=\\"8\\" y=\\"2\\" width=\\"8\\" height=\\"4\\" rx=\\"1\\" ry=\\"1\\"></rect></svg>Copy code</button></div><div class=\\"p-4 overflow-y-auto\\"><code class=\\"!whitespace-pre hljs language-cpp\\"><span class=\\"hljs-meta\\">#<span class=\\"hljs-keyword\\">include</span> <span class=\\"hljs-string\\">&lt;iostream&gt;</span></span>\\n<span class=\\"hljs-meta\\">#<span class=\\"hljs-keyword\\">include</span> <span class=\\"hljs-string\\">&lt;vector&gt;</span></span>\\n<span class=\\"hljs-meta\\">#<span class=\\"hljs-keyword\\">include</span> <span class=\\"hljs-string\\">&lt;algorithm&gt;</span></span>\\n\\n<span class=\\"hljs-function\\"><span class=\\"hljs-type\\">int</span> <span class=\\"hljs-title\\">main</span><span class=\\"hljs-params\\">()</span> </span>{\\n    std::vector&lt;<span class=\\"hljs-type\\">int</span>&gt; vec = {<span class=\\"hljs-number\\">5</span>, <span class=\\"hljs-number\\">2</span>, <span class=\\"hljs-number\\">9</span>, <span class=\\"hljs-number\\">1</span>, <span class=\\"hljs-number\\">5</span>, <span class=\\"hljs-number\\">6</span>};\\n    \\n    std::<span class=\\"hljs-built_in\\">sort</span>(vec.<span class=\\"hljs-built_in\\">begin</span>(), vec.<span class=\\"hljs-built_in\\">end</span>());\\n\\n    <span class=\\"hljs-keyword\\">for</span> (<span class=\\"hljs-type\\">int</span> num : vec) {\\n        std::cout &lt;&lt; num &lt;&lt; <span class=\\"hljs-string\\">\\" \\"</span>;\\n    }\\n\\n    <span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-number\\">0</span>;\\n}\\n</code></div></div></pre><p>STL значительно упрощает разработку программ, так как позволяет использовать готовые и эффективные реализации контейнеров и алгоритмов для работы с данными.</p></div>"]],"Операционные системы":[["Процессы и потоки. Классификация операционных систем.","<div class=\\"markdown prose w-full break-words dark:prose-invert light\\"><p><strong>Процессы и потоки:</strong></p><ul><li><p><strong>Процесс:</strong> Процесс представляет собой исполняющуюся программу в операционной системе. Каждый процесс имеет свое собственное адресное пространство, стек, и данные, что обеспечивает изоляцию и защиту данных между различными процессами. Процессы могут быть независимыми друг от друга и выполняться параллельно.</p></li><li><p><strong>Поток (Thread):</strong> Поток является легковесным исполнительным контекстом внутри процесса. Потоки внутри одного процесса используют общее адресное пространство, стек и данные, что позволяет им легко обмениваться данными. Потоки могут выполняться параллельно, что обеспечивает более эффективное использование ресурсов процессора.</p></li></ul><p><strong>Классификация операционных систем:</strong></p><p>Операционные системы можно классифицировать по различным признакам, вот некоторые из них:</p><ol><li><p><strong>По количеству пользователей:</strong></p><ul><li>Однопользовательские: Разрешается работа только одного пользователя за раз (например, Windows).</li><li>Многопользовательские: Поддерживают работу нескольких пользователей одновременно (например, Linux, UNIX).</li></ul></li><li><p><strong>По количеству задач (процессов), которые могут выполняться одновременно:</strong></p><ul><li>Однопрограммные: Позволяют выполнять только одну программу за раз.</li><li>Многопрограммные (многозадачные): Позволяют одновременно выполнять несколько программ.</li></ul></li><li><p><strong>По способу организации процессов и ресурсов:</strong></p><ul><li>Однопоточные: Поддерживают выполнение только одного потока за раз.</li><li>Многопоточные: Поддерживают выполнение нескольких потоков в рамках одного процесса.</li></ul></li><li><p><strong>По типу интерфейса:</strong></p><ul><li>Командная строка: Взаимодействие с системой осуществляется через текстовый интерфейс.</li><li>Графический интерфейс (GUI): Имеется графический пользовательский интерфейс.</li></ul></li><li><p><strong>По типу задач, которые система предназначена обслуживать:</strong></p><ul><li>Серверные ОС: Предназначены для обеспечения работы серверов и предоставления услуг клиентам (например, Windows Server, Linux Server).</li><li>Клиентские ОС: Предназначены для использования на персональных компьютерах и ноутбуках (например, Windows, macOS).</li></ul></li><li><p><strong>По устройству, на которых они работают:</strong></p><ul><li>Десктопные ОС: Предназначены для работы на стационарных компьютерах.</li><li>Мобильные ОС: Предназначены для работы на мобильных устройствах (смартфоны, планшеты) (например, Android, iOS).</li></ul></li><li><p><strong>По степени открытости исходного кода:</strong></p><ul><li>Проприетарные ОС: Исходный код закрыт, доступен только компании-разработчику (например, Windows).</li><li>Открытые ОС: Исходный код доступен для общественности и может быть изменен и улучшен (например, Linux).</li></ul></li></ol></div>"],["Функциональные компоненты ОС. Управление процессами. Управление памятью. Управление файлами и внешними устройствами.","<div class=\\"markdown prose w-full break-words dark:prose-invert light\\"><p><strong>Функциональные компоненты операционных систем:</strong></p><ol><li><p><strong>Управление процессами:</strong> Компонент, отвечающий за управление процессами в системе. Это включает создание, запуск, приостановку, возобновление, остановку и удаление процессов. Он также обеспечивает планирование процессорного времени и распределение ресурсов между процессами.</p></li><li><p><strong>Управление памятью:</strong> Этот компонент отвечает за управление оперативной памятью компьютера. В основном, его задачи включают выделение и освобождение памяти для процессов, поддержание виртуальной памяти, обработку фрагментации и управление общей памятью системы.</p></li><li><p><strong>Управление файлами:</strong> Осуществляет управление файловой системой. Это включает создание, удаление, переименование и копирование файлов и каталогов. Также обеспечивает доступ и безопасность к файлам, а также поддерживает файловые атрибуты и разрешения.</p></li><li><p><strong>Управление внешними устройствами:</strong> Компонент операционной системы, отвечающий за взаимодействие с внешними устройствами, такими как принтеры, сканеры, мониторы и другие периферийные устройства. Обеспечивает их инициализацию, доступ и управление ими.</p></li><li><p><strong>Сетевые функции:</strong> Этот компонент отвечает за поддержку сетевых функций, таких как установка и разрыв соединений, передача данных через сеть, обработка сетевых запросов и обмен информацией между устройствами в сети.</p></li><li><p><strong>Управление учетными записями и безопасностью:</strong> Обеспечивает управление пользователями, ролями и группами, а также реализует механизмы безопасности для защиты системы и данных от несанкционированного доступа.</p></li><li><p><strong>Интерфейс пользователя:</strong> Отвечает за взаимодействие пользователя с операционной системой через графический интерфейс, командную строку или другие интерфейсы. Обеспечивает пользовательский опыт и управление оконными приложениями.</p></li><li><p><strong>Системные библиотеки:</strong> Предоставляют набор функций и процедур, которые разработчики могут использовать при создании приложений. Включают функции для работы с файлами, сетью, памятью и другими компонентами системы.</p></li><li><p><strong>Драйверы устройств:</strong> Этот компонент предоставляет интерфейс для работы с оборудованием компьютера. Драйверы устройств переводят команды операционной системы в команды, которые могут понимать и обрабатывать устройства.</p></li><li><p><strong>Ядро операционной системы:</strong> Это основная часть операционной системы, которая предоставляет базовые службы и управляет работой всех компонентов. Ядро работает на самом низком уровне и имеет прямой доступ к аппаратным ресурсам компьютера.</p></li></ol><p>Обратите внимание, что у различных операционных систем могут быть свои особенности и дополнительные компоненты, но перечисленные выше являются основными функциональными компонентами.</p></div>"],["Создание процессов и потоков.","<div class=\\"markdown prose w-full break-words dark:prose-invert light\\"><p><strong>Создание процессов и потоков в операционных системах:</strong></p><p><strong>Процессы:</strong></p><ol><li><strong>Создание процесса:</strong> Процесс может быть создан с помощью системного вызова, который запрашивает операционную систему создать новый процесс. При создании процесса, операционная система выделяет ему собственное адресное пространство и другие ресурсы, такие как файловые дескрипторы и переменные окружения.</li><li><strong>Форк (fork()):</strong> В некоторых операционных системах, например, в UNIX-подобных системах, для создания нового процесса используется системный вызов fork(). Этот вызов создает точную копию текущего процесса, называемого дочерним процессом.</li><li><strong>Exec (exec()):</strong> После форка дочерний процесс может выполнить системный вызов exec(), чтобы заменить свой код на новую программу. Таким образом, процесс может переключиться на выполнение другой программы.</li></ol><p><strong>Потоки:</strong></p><ol><li><strong>Создание потоков:</strong> Потоки могут быть созданы в рамках процесса. Операционные системы обычно предоставляют API для создания потоков. Например, в Windows можно использовать функцию CreateThread(), а в POSIX-совместимых системах можно использовать функцию pthread_create().</li><li><strong>Многопоточность в одном процессе:</strong> В отличие от процессов, потоки разделяют адресное пространство процесса, что позволяет им обмениваться данными без необходимости использования механизмов межпроцессного взаимодействия.</li><li><strong>Системные потоки:</strong> Некоторые операционные системы могут создавать системные потоки для выполнения определенных задач, например, управления сетевыми запросами или вводом-выводом. Эти потоки не управляются пользователем и работают параллельно с пользовательскими потоками.</li></ol><p>Создание процессов и потоков позволяет операционной системе эффективно использовать ресурсы компьютера и обеспечивать параллельное выполнение задач, что является одной из ключевых функций операционных систем.</p></div>"],["Независимые и взаимодействующие вычислительные процессы и потоки.","<div class=\\"markdown prose w-full break-words dark:prose-invert light\\"><p><strong>Независимые и взаимодействующие вычислительные процессы и потоки:</strong></p><p><strong>Независимые процессы и потоки:</strong></p><ol><li><p><strong>Независимые процессы:</strong> Независимые процессы - это процессы, которые не зависят друг от друга и работают независимо. Каждый процесс имеет свои собственные ресурсы, включая адресное пространство, файловые дескрипторы и переменные окружения. Каждый процесс выполняет свою задачу, и его выполнение не зависит от других процессов в системе. Процессы обычно обмениваются данными и взаимодействуют через механизмы межпроцессного взаимодействия, такие как каналы, сигналы или сокеты.</p></li><li><p><strong>Независимые потоки:</strong> В многопоточной системе независимые потоки также выполняются независимо друг от друга и имеют собственные наборы регистров и стеков. Каждый поток выполняет свою функцию или задачу, и его выполнение не зависит от других потоков. Однако независимые потоки разделяют адресное пространство процесса, что позволяет им обмениваться данными без необходимости использования механизмов межпоточного взаимодействия.</p></li></ol><p><strong>Взаимодействующие процессы и потоки:</strong></p><ol><li><p><strong>Взаимодействующие процессы:</strong> Взаимодействующие процессы - это процессы, которые взаимодействуют друг с другом для выполнения совместных задач. Взаимодействие между процессами обычно осуществляется через механизмы межпроцессного взаимодействия (IPC), такие как сигналы, сокеты, каналы и разделяемая память.</p></li><li><p><strong>Взаимодействующие потоки:</strong> В многопоточной системе взаимодействующие потоки также могут взаимодействовать друг с другом для совместного выполнения задач. Потоки могут обмениваться данными и синхронизироваться с помощью механизмов межпоточного взаимодействия, таких как блокировки, семафоры, условные переменные и каналы.</p></li></ol><p><strong>Заключение:</strong>\\nНезависимые процессы и потоки выполняются независимо друг от друга, в то время как взаимодействующие процессы и потоки взаимодействуют друг с другом для совместного выполнения задач и обмена данными. Взаимодействие происходит через различные механизмы, предоставляемые операционной системой. Выбор между независимыми и взаимодействующими процессами и потоками зависит от требований конкретной задачи и особенностей системы.</p></div>"],["Семафарные примитивы Дейкстры. Использование семафоров при проектировании взаимодействующих вычислительных процессов и потоков. Мьютексы.","<div class=\\"markdown prose w-full break-words dark:prose-invert light\\"><p><strong>Семафорные примитивы Дейкстры и использование семафоров:</strong></p><p><strong>1. Семафоры Дейкстры:</strong>\\nСемафоры Дейкстры – это механизм синхронизации, предложенный Эдсгером Дейкстрой, который используется для управления доступом к общим ресурсам в многопроцессорных и многопоточных системах. Семафор – это неотрицательное целое число, которое может быть увеличено или уменьшено только специальными операциями P (proberen - проверить) и V (vrijgeven - освободить).</p><ul><li><strong>P (Proberen):</strong> Операция уменьшения значения семафора на 1. Если значение становится отрицательным, поток или процесс, выполняющий операцию P, блокируется до тех пор, пока значение семафора не станет положительным.</li><li><strong>V (Vrijgeven):</strong> Операция увеличения значения семафора на 1. Если перед операцией V были заблокированные потоки или процессы, один из них будет разблокирован и получит доступ к общему ресурсу.</li></ul><p><strong>2. Использование семафоров при проектировании взаимодействующих вычислительных процессов и потоков:</strong>\\nСемафоры могут быть использованы для решения проблем синхронизации и взаимодействия между вычислительными процессами и потоками. Они позволяют синхронизировать доступ к общим ресурсам и предотвращать состояния гонки и другие проблемы, которые могут возникнуть при параллельном выполнении.</p><p>Примеры использования семафоров:</p><ul><li>Реализация критической секции, где только один процесс или поток может одновременно получить доступ к общему ресурсу.</li><li>Реализация ограничения на количество одновременно работающих потоков или процессов.</li><li>Синхронизация потоков для выполнения определенной последовательности операций.</li></ul><p><strong>3. Мьютексы:</strong>\\nМьютексы – это семафоры, которые используются для обеспечения взаимоисключения при доступе к общим ресурсам. Они обладают булевым значением и могут быть заблокированы или разблокированы только одним потоком или процессом за раз.</p><ul><li><strong>Lock (заблокировать):</strong> Если мьютекс заблокирован другим потоком или процессом, операция lock блокирует текущий поток и ждет, пока мьютекс не будет разблокирован.</li><li><strong>Unlock (разблокировать):</strong> Операция unlock разблокирует мьютекс, позволяя другим потокам или процессам получить доступ к общему ресурсу.</li></ul><p>Мьютексы обеспечивают более гибкий и удобный способ реализации взаимоисключения по сравнению с обычными семафорами.</p><p><strong>Заключение:</strong>\\nСемафоры Дейкстры и мьютексы являются мощными средствами для синхронизации взаимодействующих вычислительных процессов и потоков в многопроцессорных и многопоточных системах. Они позволяют управлять доступом к общим ресурсам, предотвращать состояния гонки и обеспечив</p></div>"]],"Защита информации":[["Организационные и правовые основы обеспечения защиты информации (ЗИ).","<div class=\\"markdown prose w-full break-words dark:prose-invert light\\"><p><strong>Организационные и правовые основы обеспечения защиты информации (ЗИ):</strong></p><p><strong>Организационные основы ЗИ:</strong></p><ol><li><p><strong>Политика информационной безопасности:</strong> Организации должны разрабатывать и внедрять политику информационной безопасности, которая определяет общие принципы и цели обеспечения защиты информации. Политика должна быть принята руководством и представлять обязательные правила и рекомендации для сотрудников.</p></li><li><p><strong>Управление доступом:</strong> Ограничение доступа к информации только для авторизованных пользователей, применение принципа \\"необходимости знания\\" – каждый пользователь должен иметь доступ только к той информации, которая необходима для его работы.</p></li><li><p><strong>Обучение и осведомленность:</strong> Обучение сотрудников основам информационной безопасности, пропаганда осведомленности о рисках и правилах безопасного обращения с информацией.</p></li><li><p><strong>Аудит информационной безопасности:</strong> Регулярные проверки и аудит информационных систем для выявления уязвимостей и проверки соответствия политике безопасности.</p></li><li><p><strong>Управление рисками:</strong> Анализ рисков безопасности информации и принятие мер по их минимизации.</p></li><li><p><strong>Физическая защита:</strong> Обеспечение безопасности физических объектов, где хранится информация, например, серверных комнат и центров обработки данных.</p></li></ol><p><strong>Правовые основы ЗИ:</strong></p><ol><li><p><strong>Законы и нормативные акты:</strong> Существуют законы и нормативные акты, регулирующие вопросы защиты информации, такие как законы о защите персональных данных, об информации, составляющей государственную тайну и др.</p></li><li><p><strong>Стандарты и рекомендации:</strong> Организации могут руководствоваться стандартами и рекомендациями в области информационной безопасности, такими как ISO/IEC 27001.</p></li><li><p><strong>Конфиденциальность и соглашения о неразглашении:</strong> Заключение соглашений о неразглашении с сотрудниками и партнерами охраняет интересы организации и предотвращает утечку информации.</p></li><li><p><strong>Ответственность:</strong> Установление ответственности за нарушения информационной безопасности, возможные дисциплинарные и юридические меры.</p></li><li><p><strong>Сотрудничество с правоохранительными органами:</strong> Предоставление информации и сотрудничество с правоохранительными органами при выявлении и расследовании инцидентов информационной безопасности.</p></li></ol><p><strong>Заключение:</strong></p><p>Организационные и правовые основы обеспечения защиты информации играют ключевую роль в обеспечении безопасности информационных систем и данных. Совместное внедрение организационных мер и соблюдение правовых требований позволяют минимизировать риски утечки, повреждения или несанкционированного доступа к информации.</p></div>"],["Возможные угрозы безопасности для компьютерных систем (КС) и их специфика.","<div class=\\"markdown prose w-full break-words dark:prose-invert light\\"><p><strong>Возможные угрозы безопасности для компьютерных систем (КС) и их специфика:</strong></p><ol><li><p><strong>Вирусы и вредоносные программы:</strong> Это программы, разработанные для нанесения вреда компьютерной системе, их основная цель - заражение и разрушение данных, кража информации и прочие негативные действия.</p></li><li><p><strong>Межсетевые атаки:</strong> Злоумышленники могут попытаться получить несанкционированный доступ к сетевым ресурсам, использовать уязвимости в программном обеспечении или сетевых протоколах.</p></li><li><p><strong>Фишинг и социальная инженерия:</strong> Атаки, направленные на обман пользователя и получение его личной информации, таких как пароли или данные банковских карт.</p></li><li><p><strong>Отказ в обслуживании (DoS и DDoS):</strong> Целью таких атак является перегрузка ресурсов компьютерной системы или сети, чтобы временно или полностью прекратить её функционирование.</p></li><li><p><strong>Утечка данных:</strong> Несанкционированный доступ к конфиденциальной информации, включая персональные данные пользователей или бизнес-данные компании.</p></li><li><p><strong>Физические угрозы:</strong> Кража или уничтожение компьютеров и другого оборудования, что может привести к потере данных или нарушению работы системы.</p></li><li><p><strong>Использование слабых паролей:</strong> Ненадежные пароли могут стать лёгкой мишенью для взлома или несанкционированного доступа.</p></li><li><p><strong>Неактуальное программное обеспечение:</strong> Необновленное или неактуальное ПО может содержать известные уязвимости, которые могут быть использованы для взлома или вредоносных действий.</p></li><li><p><strong>Несанкционированный доступ:</strong> Посторонние лица, получающие доступ к компьютерной системе без разрешения, могут нанести ущерб или кражу данных.</p></li></ol><p><strong>Специфика угроз:</strong></p><ul><li>Компьютерные системы связаны с сетью, что позволяет злоумышленникам из других географических местоположений осуществлять атаки.</li><li>Возможность массовых атак (например, через ботнеты) может существенно повысить уровень опасности.</li><li>Быстрое распространение вредоносных программ через сети может привести к быстрому ущербу.</li><li>Современные угрозы становятся все более утонченными и изощренными, что требует непрерывного совершенствования методов защиты и контрмер.</li><li>С развитием технологий, появляются новые виды угроз, такие как угрозы для мобильных устройств и облачных вычислений.</li></ul><p><strong>Заключение:</strong></p><p>С увеличением зависимости от компьютерных систем и сетей угрозы безопасности становятся все более серьезными и разнообразными. Для защиты компьютерных систем и данных необходимо постоянно обновлять методы обнаружения и предотвращения атак, а также проводить обучение пользователей и сотрудников для повышения осведомленности о возможных угрозах и методах защиты.</p></div>"],["Обобщенная структура системы ЗИ в КС.","<div class=\\"markdown prose w-full break-words dark:prose-invert light\\"><p><strong>Обобщенная структура системы защиты информации (ЗИ) в компьютерных системах (КС)</strong> включает несколько основных компонентов и механизмов, которые совместно обеспечивают безопасность информации. Эти компоненты работают в совокупности, чтобы обнаруживать, предотвращать, анализировать и реагировать на угрозы безопасности. Обобщенная структура системы ЗИ в КС может быть представлена следующим образом:</p><ol><li><p><strong>Идентификация и аутентификация пользователей:</strong> Важный компонент безопасности, который позволяет проверять личность и права доступа пользователей к системе. Для этого используются пароли, биометрические данные, смарт-карты и другие методы аутентификации.</p></li><li><p><strong>Управление доступом:</strong> Этот компонент определяет права доступа пользователей и ограничивает их возможности в соответствии с уровнем разрешений. Реализуется через права доступа, ролевые модели и т.д.</p></li><li><p><strong>Шифрование:</strong> Защищает конфиденциальность данных путем их преобразования в зашифрованный формат, который может быть прочитан только с помощью ключа. Используются различные алгоритмы шифрования для защиты информации.</p></li><li><p><strong>Аудит и мониторинг:</strong> Этот компонент отслеживает действия пользователей и системы, регистрирует события, а также анализирует логи для обнаружения аномалий или подозрительных действий.</p></li><li><p><strong>Брандмауэры и контроль сетевого трафика:</strong> Брандмауэры предоставляют контроль доступа к сетевым ресурсам и фильтруют сетевой трафик для предотвращения несанкционированного доступа и атак извне.</p></li><li><p><strong>Антивирусные программы и анти-шпионы:</strong> Обнаруживают и предотвращают вредоносные программы, вирусы и вредоносные объекты, которые могут проникнуть в систему.</p></li><li><p><strong>Физическая безопасность:</strong> Осуществляется через ограниченный доступ к серверным помещениям, защиту компьютеров от кражи или несанкционированного доступа.</p></li><li><p><strong>Резервное копирование и восстановление:</strong> Обеспечивает сохранность данных путем регулярного создания резервных копий и возможность быстрого восстановления системы в случае сбоя или атаки.</p></li><li><p><strong>Обновление программного обеспечения:</strong> Регулярное обновление операционной системы и прикладных программ для устранения уязвимостей и ошибок, что повышает безопасность системы.</p></li><li><p><strong>Обучение пользователей:</strong> Важная часть системы защиты информации - обучение пользователей безопасным практикам, правилам обращения с информацией и опознаванию угроз безопасности.</p></li></ol><p>Обобщенная структура системы ЗИ может меняться в зависимости от типа компьютерных системы, её функций, размера организации и уровня требований к безопасности. Однако эти компоненты являются основными строительными блоками системы безопасности, направленной на защиту информации от угроз.</p></div>"],["Методы идентификации и аутентификации пользователей в КС.","<div class=\\"markdown prose w-full break-words dark:prose-invert light\\"><p>Методы идентификации и аутентификации пользователей в компьютерных системах (КС) представляют собой способы проверки личности и прав доступа пользователей к системе. Они служат для обеспечения безопасности и защиты информации от несанкционированного доступа. Вот некоторые из основных методов идентификации и аутентификации:</p><ol><li><p><strong>Пароль:</strong> Это один из самых распространенных методов аутентификации. Пользователь должен предоставить комбинацию символов (пароль), которая соответствует заранее заданной комбинации в системе.</p></li><li><p><strong>Биометрическая аутентификация:</strong> Этот метод использует уникальные биологические характеристики пользователей для идентификации, такие как отпечатки пальцев, сетчатка глаза, голос или лицо.</p></li><li><p><strong>Смарт-карты и токены:</strong> Смарт-карты и токены содержат уникальные идентификаторы и генерируют временные или одноразовые коды для аутентификации.</p></li><li><p><strong>Многофакторная аутентификация:</strong> Этот метод сочетает несколько различных способов аутентификации, например, пароль и биометрические данные, для повышения уровня безопасности.</p></li><li><p><strong>Сетевые ключи:</strong> Этот метод используется в сетевых системах для проверки подлинности клиентов или серверов.</p></li><li><p><strong>Публичные и приватные ключи (шифрование с открытым ключом):</strong> Этот метод используется для шифрования и проверки подписей данных и обмена ключами для симметричного шифрования.</p></li><li><p><strong>Одноразовые пароли:</strong> Пароли, которые действительны только один раз, обычно генерируются специальным образом и отправляются пользователю для каждого входа в систему.</p></li><li><p><strong>Капча:</strong> Защитная мера для проверки, что пользователь является человеком, а не автоматическим ботом.</p></li></ol><p>Каждый метод имеет свои преимущества и ограничения. Безопасность системы может быть повышена путем комбинирования нескольких методов аутентификации, таких как многофакторная аутентификация, чтобы создать более надежную систему защиты информации.</p></div>"],["Управление доступом в КС.","<div class=\\"markdown prose w-full break-words dark:prose-invert light\\"><p>Управление доступом в компьютерных системах (КС) является важной составляющей обеспечения безопасности и защиты информации. Этот процесс регулирует права доступа пользователей и программ к ресурсам и функциям системы. Основные механизмы управления доступом в КС включают:</p><ol><li><p><strong>Идентификация и аутентификация:</strong> Перед тем как предоставить доступ к системе, пользователи должны пройти процедуры идентификации (предоставить уникальный идентификатор) и аутентификации (подтвердить свою личность). Это позволяет системе определить, кто запрашивает доступ, и проверить его правомерность.</p></li><li><p><strong>Ролевая модель доступа:</strong> В ролевой модели доступа определяются различные роли, которые могут быть назначены пользователям. Каждая роль имеет свой набор прав доступа к определенным ресурсам или функциям системы. Администраторы могут назначать роли пользователям в соответствии с их обязанностями и нуждами.</p></li><li><p><strong>Уровни доступа:</strong> Системы могут определять уровни доступа, которые разделяются на разные категории с различными правами доступа. Например, это может быть уровень чтения, записи, выполнения, администрирования и т.д.</p></li><li><p><strong>Матрица доступа:</strong> Матрица доступа представляет собой таблицу, в которой перечислены субъекты (пользователи) и объекты (ресурсы) системы, а в ячейках указываются права доступа для каждой комбинации субъекта и объекта. Это позволяет наглядно представить права доступа в системе.</p></li><li><p><strong>Аудит доступа:</strong> Системы могут вести аудит доступа, чтобы фиксировать действия пользователей и программ, а также проверять соответствие их действий установленным правилам. Аудит позволяет выявить и предотвратить несанкционированный доступ и злоупотребления.</p></li><li><p><strong>Белые списки и черные списки:</strong> Белые списки определяют список допустимых программ, пользователей или ресурсов, которые имеют доступ к системе. Черные списки определяют список недопустимых элементов, которые запрещены в системе.</p></li><li><p><strong>Шифрование данных:</strong> Шифрование используется для защиты данных от несанкционированного доступа, даже если злоумышленник получит физический доступ к хранилищу данных.</p></li><li><p><strong>Права доступа к файлам и каталогам:</strong> Системы операционных файлов имеют механизмы управления доступом к файлам и каталогам, позволяющие ограничивать права чтения, записи и выполнения для каждого пользователя.</p></li></ol><p>Все эти механизмы управления доступом совместно способствуют обеспечению безопасности компьютерной системы и защите информации от несанкционированного доступа и использования.</p></div>"],["Протоколирование и аудит в КС.","<div class=\\"markdown prose w-full break-words dark:prose-invert light\\"><p>Протоколирование и аудит в компьютерных системах (КС) играют важную роль в обеспечении безопасности и защите информации. Эти процессы позволяют записывать и анализировать события, происходящие в системе, что помогает выявлять несанкционированные действия и злоупотребления, а также обеспечивает возможность восстановления системы в случае инцидентов.</p><p><strong>Протоколирование</strong> - это процесс записи событий, происходящих в компьютерной системе, в специальные файлы, называемые журналами событий или логами. В журналах фиксируются различные операции, такие как вход и выход пользователя, доступ к файлам, изменения конфигурации системы, ошибки и предупреждения, сетевые взаимодействия и т.д. Протоколирование помогает ведению аудита и обеспечивает историю действий в системе, что полезно для анализа произошедших событий.</p><p><strong>Аудит</strong> - это процесс анализа и интерпретации журналов событий с целью обнаружения несанкционированных действий, нарушений безопасности, аномалий или других проблем в системе. Аудит позволяет выявить потенциальные уязвимости и проблемы безопасности, а также помогает следить за соответствием системы установленным правилам и нормативам.</p><p>Основные задачи протоколирования и аудита в КС:</p><ol><li><p><strong>Обнаружение безопасности:</strong> Аудит журналов событий позволяет выявлять несанкционированный доступ, попытки взлома, злоумышленные действия и другие подозрительные события.</p></li><li><p><strong>Исследование инцидентов:</strong> При возникновении инцидентов, таких как нарушения безопасности или сбои, протоколирование позволяет проанализировать последовательность событий и выяснить причины и последствия инцидента.</p></li><li><p><strong>Анализ производительности:</strong> Протоколирование может использоваться для анализа производительности системы, выявления узких мест и оптимизации работы.</p></li><li><p><strong>Соответствие и нормативы:</strong> Журналы событий могут быть использованы для проверки соответствия системы установленным стандартам, правилам и нормативам безопасности.</p></li><li><p><strong>Восстановление после инцидентов:</strong> Протоколирование позволяет восстановить последовательность событий после инцидентов и определить, какие меры нужно предпринять для восстановления системы.</p></li><li><p><strong>Ответственность и юридические вопросы:</strong> Протоколирование служит важным доказательством в случае юридических разбирательств и споров.</p></li></ol><p>Протоколирование и аудит должны проводиться систематически и регулярно, чтобы обеспечить эффективную защиту информации и оперативную реакцию на возможные инциденты безопасности.</p></div>"],["Криптографические методы ЗИ в КС.","<div class=\\"markdown prose w-full break-words dark:prose-invert light\\"><p>Криптографические методы защиты информации включают в себя различные алгоритмы и протоколы, используемые для обеспечения конфиденциальности, целостности и аутентичности данных. Криптография в контексте защиты информации включает следующие методы:</p><ol><li><p>Симметричное шифрование: Это метод, при котором один и тот же ключ используется для шифрования и дешифрования данных. Примеры симметричных алгоритмов включают AES (Advanced Encryption Standard) и DES (Data Encryption Standard).</p></li><li><p>Асимметричное шифрование: Также называемое публичным шифрованием, использует пару ключей - публичный и приватный. Публичный ключ используется для шифрования данных, и только соответствующий приватный ключ может расшифровать эти данные. RSA (Rivest-Shamir-Adleman) - один из наиболее распространенных асимметричных алгоритмов.</p></li><li><p>Хэширование: Этот метод используется для создания уникальной хэш-суммы из исходных данных. Хэш-сумма является фиксированной длиной и представляет собой уникальный \\"отпечаток\\" данных. MD5 и SHA (Secure Hash Algorithm) являются примерами хэш-функций.</p></li><li><p>Цифровые подписи: Они обеспечивают аутентификацию и целостность данных. Цифровая подпись создается с использованием приватного ключа и проверяется с помощью соответствующего публичного ключа. Электронная подпись - пример цифровой подписи.</p></li><li><p>Протоколы обмена ключами: Для обеспечения безопасного обмена симметричными ключами между сторонами используются протоколы, такие как Diffie-Hellman и ECDH (Elliptic Curve Diffie-Hellman).</p></li><li><p>Цифровые сертификаты: Они используются для связывания публичных ключей с сущностями, такими как организации или человек. Цифровые сертификаты помогают удостоверить подлинность публичного ключа и выступают важной ролью в аутентификации.</p></li><li><p>Электронные алгоритмы ЭЦП (Электронная Цифровая Подпись): Эти алгоритмы используются для создания и проверки электронных подписей, обеспечивая аутентичность и невозможность отказа от подписи.</p></li></ol><p>Это основные криптографические методы, которые применяются для защиты информации в компьютерных системах.</p></div>"],["Экранирование. Классификация межсетевых экранов.","<div class=\\"markdown prose w-full break-words dark:prose-invert light\\"><p>Экранирование (файрволлы) - это процесс обеспечения безопасности компьютерных сетей путем контроля и фильтрации трафика, проходящего между различными сетями. Файрволлы работают на уровне сетевого соединения, определяя, какие сетевые пакеты разрешено передавать, а какие следует блокировать, исходя из определенных правил и политик безопасности.</p><p>Классификация межсетевых экранов:</p><ol><li><p>По способу фильтрации трафика:</p><ul><li>Пакетный фильтр: Фильтрация осуществляется на основе информации, содержащейся в заголовках пакетов данных. Принимаются решения о передаче или блокировке пакета на основе IP-адресов и портов отправителя и получателя.</li><li>Состояний сессий (stateful firewall): Этот тип фаервола отслеживает состояние активных сетевых соединений и принимает решения о передаче пакета на основе его контекста (состояния).</li><li>Прокси-фильтр: Фильтрация осуществляется через прокси-серверы, которые анализируют всю информацию пакета, а не только его заголовки. Прокси-фильтры могут более тщательно контролировать данные, проходящие через них.</li></ul></li><li><p>По уровню сетевого соединения:</p><ul><li>Уровень сетевого соединения (сетевой фаервол): Работает на сетевом уровне модели OSI (например, на уровне IP-адресов).</li><li>Уровень транспортного соединения (транспортный фаервол): Фильтрация трафика происходит на уровне транспортных протоколов, таких как TCP или UDP.</li><li>Уровень приложения (прикладной фаервол): Анализирует содержимое пакетов на уровне приложений, что позволяет принимать решения на основе типа приложения или службы.</li></ul></li><li><p>По политике доступа:</p><ul><li>Фаервол с разрешающей политикой (allow-list): Запрещается все, что не разрешено явно в политиках.</li><li>Фаервол с запрещающей политикой (deny-list): Разрешается все, что не запрещено явно в политиках.</li></ul></li></ol><p>Комбинация различных типов экранирования и классификации позволяет создавать более надежные системы защиты информации, адаптированные к конкретным потребностям и уровню безопасности организации.</p></div>"]],"Проектирование человеко-машинного интерфейса":[["Информационное взаимодействие. Взаимодействие человека и машины.","<div class=\\"markdown prose w-full break-words dark:prose-invert light\\"><p>Информационное взаимодействие в контексте проектирования человеко-машинного интерфейса описывает способы обмена информацией между человеком и машиной. Взаимодействие человека и машины играет ключевую роль в создании удобных и эффективных интерфейсов, которые позволяют пользователям взаимодействовать с компьютерной системой, управлять ею и получать от нее необходимую информацию.</p><p>Основные аспекты информационного взаимодействия и взаимодействия человека и машины включают:</p><ol><li><p>Ввод информации: Пользователь взаимодействует с системой, предоставляя ей информацию. Это может быть выполнено различными способами, такими как нажатие кнопок, ввод текста, использование жестов или голосовых команд.</p></li><li><p>Визуализация данных: Система отображает информацию пользователю, представляя данные в удобном и понятном виде. Это может включать графику, текст, диаграммы, анимации и другие элементы, которые помогают передать информацию.</p></li><li><p>Обратная связь: Система предоставляет обратную связь пользователю, позволяя узнать, что происходит в данный момент или результаты выполненных действий. Обратная связь может быть визуальной, звуковой или тактильной.</p></li><li><p>Интерактивность: Человек может влиять на ход процесса и взаимодействия с системой. Интерактивность обеспечивает возможность адаптировать работу системы под индивидуальные потребности и предпочтения пользователей.</p></li><li><p>Управление и контроль: Взаимодействие человека и машины включает способы управления системой и контроля ее действий. Это включает функциональные элементы, такие как кнопки, ползунки, переключатели и другие средства управления.</p></li><li><p>Понятность и простота: Человеко-машинный интерфейс должен быть понятным и простым в использовании, чтобы пользователь мог без труда осваивать систему и выполнять необходимые задачи.</p></li><li><p>Ошибки и обработка исключительных ситуаций: Взаимодействие должно предусматривать возможность обработки ошибок и исключительных ситуаций, чтобы пользователи получали информативные сообщения и инструкции при возникновении проблем.</p></li></ol><p>Успешное информационное взаимодействие и эффективное взаимодействие человека и машины являются важными аспектами проектирования человеко-машинного интерфейса, которые влияют на удовлетворенность пользователей и результативность работы с системой.</p></div>"],["Работа нервной системы. Характеристики и особенности анализаторов.","<div class=\\"markdown prose w-full break-words dark:prose-invert light\\"><p>Работа нервной системы в контексте проектирования человеко-машинного интерфейса связана с пониманием характеристик и особенностей анализаторов - органов чувств, которые позволяют человеку получать информацию из внешнего мира.</p><p>Характеристики анализаторов:</p><ol><li><p>Модальность: Каждый анализатор специализируется на восприятии определенного вида информации из внешнего мира. Например, зрительный анализатор (зрение) воспринимает световые волны, а слуховой анализатор (слух) обрабатывает звуковые волны.</p></li><li><p>Рецепторы: Анализаторы содержат специализированные рецепторы, которые реагируют на определенные стимулы. Например, зрительные рецепторы (фоторецепторы) в глазу реагируют на свет, а рецепторы в коже отвечают за тактильные ощущения.</p></li><li><p>Пороги восприятия: Каждый анализатор имеет свой порог восприятия - минимальное значение стимула, которое человек может воспринять. Например, в зрении это яркость света, а в слухе - громкость звука.</p></li><li><p>Адаптация: Анализаторы могут адаптироваться к постоянным стимулам, что может привести к снижению чувствительности. Например, при длительном пребывании в тихой комнате увеличивается чувствительность слуха.</p></li><li><p>Пространственное и временное разрешение: Анализаторы имеют различную способность разрешать детали в пространстве и времени. Например, зрение имеет высокое пространственное разрешение, что позволяет различать мелкие детали, а слух обладает хорошим временным разрешением, что позволяет различать звуки с разными частотами.</p></li><li><p>Интеграция: Часто информация из различных анализаторов интегрируется в единое восприятие. Например, восприятие объекта может включать информацию, полученную из зрения, слуха и тактильных ощущений.</p></li></ol><p>При проектировании человеко-машинного интерфейса важно учитывать особенности работы анализаторов человека, чтобы создать удобный и эффективный интерфейс, который соответствует способностям человека воспринимать информацию. Например, использование ярких цветов и хорошее размещение элементов интерфейса может улучшить визуальное восприятие, а ясные и информативные звуковые сигналы могут улучшить восприятие через слуховой анализатор.</p></div>"],["Сущность, факторы, показатели и динамика работоспособности.","<div class=\\"markdown prose w-full break-words dark:prose-invert light\\"><p>Сущность работоспособности в контексте проектирования человеко-машинного интерфейса относится к способности пользователя эффективно выполнять задачи и функции с использованием интерфейса. Работоспособность интерфейса зависит от соответствия его характеристик и возможностей особенностям человеческой психофизиологии и когнитивных возможностей.</p><p>Факторы, влияющие на работоспособность интерфейса:</p><ol><li><p>Удобство использования: Простота, интуитивность и понятность интерфейса позволяют пользователям легко осваивать и выполнять операции.</p></li><li><p>Эффективность: Количество и качество достигаемых результатов с использованием интерфейса. Быстрый и точный выполнения задач способствует повышению эффективности.</p></li><li><p>Надежность: Стабильность и отсутствие ошибок в работе интерфейса способствуют поддержанию работоспособности.</p></li><li><p>Гибкость: Возможность настройки интерфейса под потребности и предпочтения различных пользователей повышает его работоспособность.</p></li><li><p>Эстетика: Внешний вид и дизайн интерфейса могут повлиять на его привлекательность для пользователей.</p></li></ol><p>Показатели работоспособности:</p><ol><li><p>Время выполнения задач: Количество времени, необходимое для выполнения определенных задач с помощью интерфейса.</p></li><li><p>Количество ошибок: Число ошибок, допущенных пользователями при работе с интерфейсом.</p></li><li><p>Уровень удовлетворенности пользователей: Мера удовлетворенности пользователя отношением к интерфейсу и его функциональности.</p></li><li><p>Производительность: Количество задач, выполненных пользователем за определенный промежуток времени.</p></li></ol><p>Динамика работоспособности:</p><p>Динамика работоспособности связана с изменениями в уровне работоспособности интерфейса во времени. Она может быть измерена с помощью повторных тестирований пользователей после внесения изменений в интерфейс или сравнением работоспособности различных версий интерфейса. Регулярное обновление и улучшение интерфейса может способствовать повышению его работоспособности и соответствия изменяющимся потребностям пользователей.</p></div>"],["Характеристики человека-оператора.","<div class=\\"markdown prose w-full break-words dark:prose-invert light\\"><p>Характеристики человека-оператора играют важную роль в проектировании человеко-машинного интерфейса, так как они определяют, каким образом пользователи будут взаимодействовать с системой и какую поддержку им необходимо предоставить. Некоторые из ключевых характеристик человека-оператора включают:</p><ol><li><p>Психофизиологические особенности: Каждый человек уникален и обладает своими психофизиологическими особенностями, такими как возраст, пол, физические возможности, зрение, слух и т.д. Проектирование интерфейса должно учитывать эти различия, чтобы обеспечить оптимальное взаимодействие для различных пользователей.</p></li><li><p>Опыт и обучаемость: Уровень опыта и знаний пользователей влияет на их способность осваивать и эффективно использовать интерфейс. Проектирование должно учитывать разные уровни опыта и предоставлять необходимое обучение новым пользователям.</p></li><li><p>Когнитивные возможности: Различные люди обладают разной когнитивной способностью, такой как способность к запоминанию, обработке информации и принятию решений. Интерфейс должен быть спроектирован так, чтобы минимизировать нагрузку на когнитивные возможности пользователей и упростить процесс взаимодействия.</p></li><li><p>Мотивация и интересы: Человек работает с системой, чтобы достичь определенных целей или выполнять задачи. Понимание мотивации и интересов пользователей помогает создать интерфейс, который будет стимулировать их к эффективной работе.</p></li><li><p>Работа в экстремальных условиях: Некоторые пользователи могут работать в условиях, которые отличаются от обычных, например, в условиях высокой нагрузки или стресса. Интерфейс должен быть спроектирован с учетом таких экстремальных условий.</p></li><li><p>Взаимодействие с другими пользователями: Взаимодействие между пользователями также может повлиять на проектирование интерфейса. Например, если пользователи работают в коллаборативной среде, интерфейс должен поддерживать совместную работу и коммуникацию.</p></li><li><p>Ошибки и усталость: Пользователи могут допускать ошибки или испытывать усталость в процессе работы с интерфейсом. Проектирование должно учитывать возможность минимизации ошибок и снижения усталости.</p></li></ol><p>Учет характеристик человека-оператора при проектировании человеко-машинного интерфейса помогает создать удобный, эффективный и приятный для использования интерфейс, способствующий повышению производительности и удовлетворенности пользователей.</p></div>"],["Инженерно-психологическая оценка способов кодирования визуальной информации.","<div class=\\"markdown prose w-full break-words dark:prose-invert light\\"><p>Инженерно-психологическая оценка способов кодирования визуальной информации связана с анализом различных методов представления данных и графических элементов в интерфейсе с точки зрения их восприятия и воздействия на человека-пользователя. Это важный аспект проектирования человеко-машинного интерфейса, так как эффективное представление информации визуально может существенно повысить удобство и понятность интерфейса.</p><p>Оценка способов кодирования визуальной информации включает следующие аспекты:</p><ol><li><p>Визуальная восприимчивость: Исследование того, как пользователи воспринимают различные графические элементы и какую информацию они способны извлекать из представленных данных.</p></li><li><p>Зрительная память: Анализ того, насколько хорошо пользователи запоминают и узнают различные визуальные символы, исходя из их формы, цвета, размера и т.д.</p></li><li><p>Читаемость и различимость: Оценка того, насколько легко пользователи могут читать текст и различать различные элементы интерфейса, такие как иконки, кнопки, элементы меню и т.д.</p></li><li><p>Контрастность: Изучение оптимального сочетания цветов и контрастности для достижения максимальной читаемости и восприятия информации.</p></li><li><p>Иконографика: Оценка эффективности иконок и их семантической нагрузки, чтобы удостовериться, что они понятны и соответствуют ожиданиям пользователей.</p></li><li><p>Визуальная иерархия: Исследование, каким образом пользователи оценивают и обрабатывают информацию в зависимости от ее расположения, размера, цвета и других атрибутов.</p></li><li><p>Ориентация и навигация: Анализ того, какие визуальные подсказки и элементы управления помогают пользователям ориентироваться и перемещаться в интерфейсе.</p></li></ol><p>Инженерно-психологическая оценка способов кодирования визуальной информации позволяет создавать более удобные и эффективные интерфейсы, которые лучше соответствуют потребностям и способностям пользователей при взаимодействии с компьютерными системами.</p></div>"],["Пользовательский интерфейс.","<div class=\\"markdown prose w-full break-words dark:prose-invert light\\"><p>Пользовательский интерфейс (ПИ) - это средство взаимодействия между человеком и компьютерной системой, которое позволяет пользователям взаимодействовать с программами, приложениями или устройствами. Пользовательский интерфейс играет ключевую роль в проектировании человеко-машинного интерфейса и определяет, как пользователи будут взаимодействовать с техническими системами и выполнять задачи.</p><p>Основные характеристики пользовательского интерфейса включают:</p><ol><li><p>Удобство использования: Пользовательский интерфейс должен быть простым, интуитивным и легко осваиваемым, чтобы даже неопытные пользователи могли комфортно выполнять задачи.</p></li><li><p>Эффективность: Интерфейс должен позволять пользователям выполнять задачи с минимальными усилиями и потерями времени.</p></li><li><p>Читаемость и понятность: Текст и графические элементы интерфейса должны быть легко читаемы и понятны, чтобы пользователи могли без труда интерпретировать предоставляемую информацию.</p></li><li><p>Консистентность: Единообразие и последовательность в представлении элементов интерфейса обеспечивают понятность и предсказуемость для пользователей.</p></li><li><p>Обратная связь: Пользователи должны получать информацию о результатах своих действий в интерфейсе, чтобы быть уверенными в выполнении команд и операций.</p></li><li><p>Гибкость: Интерфейс должен быть настраиваемым и способствовать адаптации к индивидуальным потребностям пользователей.</p></li><li><p>Визуальная привлекательность: Эстетика и дизайн интерфейса могут повысить его привлекательность и удовлетворенность пользователей.</p></li></ol><p>Пользовательский интерфейс может быть представлен в различных формах, таких как графический интерфейс пользователя (GUI), командная строка, голосовой интерфейс, сенсорные экраны и т.д. Каждый тип интерфейса имеет свои особенности и применение в зависимости от конкретной ситуации и задач пользователя. При проектировании пользовательского интерфейса важно учитывать потребности и характеристики пользователей, чтобы создать максимально удобный и эффективный интерфейс.</p></div>"],["Графический пользовательский интерфейс.","<div class=\\"markdown prose w-full break-words dark:prose-invert light\\"><p>Графический пользовательский интерфейс (GUI) - это тип пользовательского интерфейса, который использует графические элементы, такие как иконки, кнопки, окна, меню, текстовые поля и т.д., для предоставления информации и возможностей взаимодействия пользователю. GUI позволяет пользователям взаимодействовать с компьютерной системой, используя мышь, клавиатуру или сенсорный экран, что делает его одним из самых распространенных и удобных типов интерфейса.</p><p>Характеристики графического пользовательского интерфейса:</p><ol><li><p>Иконки и изображения: Графический интерфейс использует иконки и изображения для представления команд, функций или объектов, что позволяет пользователям быстро узнавать и запоминать операции.</p></li><li><p>Окна и диалоговые окна: GUI предоставляет окна, которые содержат содержимое и функциональные элементы для выполнения задач, а также диалоговые окна, которые запрашивают информацию или уведомляют о событиях.</p></li><li><p>Меню: Интерфейс содержит меню, которые представляют доступные опции и команды, организованные в иерархическую структуру.</p></li><li><p>Кнопки и переключатели: Для выполнения операций и выбора опций предоставляются графические элементы в виде кнопок и переключателей.</p></li><li><p>Текстовые поля: GUI позволяет пользователям вводить текст или данные в текстовые поля для выполнения определенных операций или поиска информации.</p></li><li><p>Мышь и клавиатура: Графический интерфейс поддерживает использование мыши для выбора элементов и взаимодействия с интерфейсом, а также клавиатуры для ввода текста и управления.</p></li></ol><p>Преимущества графического пользовательского интерфейса:</p><ul><li><p>Интуитивность: GUI обычно более интуитивен и легко понимаем для новых пользователей.</p></li><li><p>Визуализация: Использование графических элементов позволяет визуализировать информацию и операции.</p></li><li><p>Удобство: Графический интерфейс предоставляет простые и понятные средства взаимодействия.</p></li><li><p>Многозадачность: GUI позволяет пользователям работать с несколькими окнами и приложениями одновременно.</p></li><li><p>Адаптивность: GUI может быть настроен под различные потребности и предпочтения пользователей.</p></li></ul><p>Графические пользовательские интерфейсы широко используются в современных операционных системах и приложениях благодаря своей удобности, эффективности и дружественности к пользователям.</p></div>"]],"Управление программными проектами":[["Основные понятия программного проекта","<div class=\\"markdown prose w-full break-words dark:prose-invert light\\"><p>Основные понятия программного проекта:</p><ol><li><p>Программный проект: Это временное предприятие, предназначенное для создания уникального продукта, услуги или результата в виде программного обеспечения. Программные проекты часто характеризуются уникальностью, определенной продолжительностью и ограниченными ресурсами.</p></li><li><p>Заказчик: Заказчик (клиент) – это лицо или организация, которая заказывает и финансирует разработку программного продукта или услуги.</p></li><li><p>Заказ: Заказ - это формализованный запрос от заказчика на разработку программного продукта или предоставление определенной услуги.</p></li><li><p>Программная система: Программная система – это комплекс программных компонентов, включая программное обеспечение, данные и документацию, которые вместе решают определенные задачи и обеспечивают функционирование программного продукта.</p></li><li><p>Программное обеспечение: Программное обеспечение - это набор программ, инструкций и данных, которые используются для работы компьютерной системы или решения конкретных задач.</p></li><li><p>Жизненный цикл проекта: Жизненный цикл проекта - это последовательность фаз и этапов проекта, начиная от его инициации и заканчивая завершением и передачей результатов заказчику.</p></li><li><p>Планирование проекта: Это процесс определения целей, задач, ресурсов, сроков и последовательности действий для достижения успеха проекта.</p></li><li><p>Риски проекта: Риски проекта – это возможные события или обстоятельства, которые могут повлиять на результаты проекта, как положительно, так и отрицательно.</p></li><li><p>Майлстоны: Майлстоны - это важные этапы или события в жизненном цикле проекта, которые служат ориентирами для измерения прогресса и успеха.</p></li><li><p>Команда проекта: Команда проекта – это группа людей, работающих над реализацией программного проекта и воплощающих его цели и задачи.</p></li><li><p>Управление изменениями: Управление изменениями - это процесс контроля и управления изменениями в проекте для минимизации негативного влияния на его успех.</p></li></ol><p>Эти основные понятия играют важную роль в управлении программными проектами и предоставляют общий каркас для понимания и организации работы над проектами.</p></div>"],["Модели жизненного цикла программного проекта","<div class=\\"markdown prose w-full break-words dark:prose-invert light\\"><p>Модели жизненного цикла программного проекта представляют собой различные подходы и методологии, определяющие этапы и последовательность действий для разработки и управления программным проектом от его инициации до завершения. Каждая модель имеет свои особенности и применяется в зависимости от характера проекта и его требований. Ниже перечислены некоторые из популярных моделей жизненного цикла программного проекта:</p><ol><li><p>Модель Waterfall (Водопадная модель): Это классическая линейная модель, где разработка происходит последовательно от одной фазы к другой - от определения требований до развертывания и сопровождения. Каждая фаза завершается перед переходом к следующей.</p></li><li><p>Модель Spiral (Спиральная модель): Это итеративная модель, которая сочетает элементы водопадной модели и прототипирования. Проект разбивается на циклы, называемые спиралями, каждый из которых включает в себя планирование, риски, разработку и оценку.</p></li><li><p>Модель Incremental (Инкрементальная модель): Это модель, основанная на последовательном выпуске функциональных блоков (инкрементов) продукта на каждой итерации. Каждый инкремент добавляет новые функции или улучшает существующие.</p></li><li><p>Модель Agile (Гибкая модель): Это набор подходов и методологий, которые поддерживают гибкий, итеративный подход к разработке. Проект разбивается на короткие спринты, и разработчики и заказчики тесно сотрудничают на протяжении всего процесса.</p></li><li><p>Модель V-образная (V-модель): Это расширение модели Waterfall, где каждый этап разработки имеет соответствующий этап тестирования. Это помогает своевременно проверять соответствие требованиям и устранять ошибки.</p></li><li><p>Модель RAD (Rapid Application Development - Быстрая разработка приложений): Это модель, которая сосредотачивается на быстрой разработке прототипов и вовлечении заказчика на ранних этапах для уточнения требований.</p></li><li><p>Модель Spiral DSDM (Dynamic Systems Development Method): Это методология, объединяющая принципы Agile и спиральной модели, и уделяющая особое внимание вовлечению пользователя и достижению бизнес-целей.</p></li></ol><p>Каждая модель имеет свои преимущества и ограничения, и выбор конкретной модели зависит от характеристик проекта, степени его сложности, требований заказчика и предпочтений команды разработчиков.</p></div>"],["Инициация программного проекта","<div class=\\"markdown prose w-full break-words dark:prose-invert light\\"><p>Инициация программного проекта - это первый этап жизненного цикла проекта, на котором осуществляется официальное запуск проекта и определяются его цели, основные параметры и ограничения. В этой фазе происходит подготовка к разработке, планированию и управлению проектом. Ниже перечислены основные шаги и активности, которые выполняются в процессе инициации программного проекта:</p><ol><li><p>Определение бизнес-потребности: Анализируется бизнес-среда и выявляются потребности и проблемы, которые могут быть решены с помощью программного проекта. Определяются бизнес-цели и выгода от успешной реализации проекта.</p></li><li><p>Составление предварительного плана проекта: Разрабатывается предварительный план проекта, который содержит общий обзор проекта, его сроки, бюджет и основные этапы. Это позволяет оценить основные параметры проекта и его целесообразность.</p></li><li><p>Определение интересующих сторон: Выявляются заинтересованные стороны (стейкхолдеры) проекта, такие как заказчики, пользователи, исполнители, аналитики, руководство, чтобы понять их потребности и ожидания от проекта.</p></li><li><p>Проведение предварительной оценки рисков: Идентифицируются потенциальные риски и препятствия, которые могут повлиять на успешность проекта. Это позволяет разработать стратегии управления рисками.</p></li><li><p>Проведение исследования и изучение альтернатив: Исследуются возможные альтернативы для реализации проекта, а также технические и технологические подходы. Проводятся исследования, анализируются опыт других проектов и рассматриваются различные варианты.</p></li><li><p>Определение предварительного бюджета: Оценивается предварительный бюджет, необходимый для реализации проекта. Это помогает определить финансовую сторону проекта и его экономическую целесообразность.</p></li><li><p>Разработка деловой документации: Создаются необходимые документы, такие как предварительное исследование, бизнес-план, инициирующий документ, для поддержки и одобрения проекта руководством и заинтересованными сторонами.</p></li><li><p>Одобрение и старт проекта: После завершения инициации, проект подвергается оценке и утверждению руководством. Если проект одобрен, он официально стартует и переходит к следующей фазе разработки и планирования.</p></li></ol><p>Инициация программного проекта позволяет убедиться в его жизнеспособности, установить цели и ограничения, а также определить основные пути и риски, что обеспечивает успешное начало и управление проектом.</p></div>"],["Планирование программного проекта","<div class=\\"markdown prose w-full break-words dark:prose-invert light\\"><p>Планирование программного проекта - это этап в управлении проектами, на котором определяются конкретные шаги, ресурсы, сроки и задачи, необходимые для успешной реализации проекта. План проекта служит основным документом, который определяет всю работу, которая должна быть выполнена, и устанавливает базу для контроля и управления проектом. Ниже перечислены основные шаги и активности, выполняемые в процессе планирования программного проекта:</p><ol><li><p>Определение целей и требований: На этом этапе уточняются цели проекта и его требования, выявляются ожидания заказчика и заинтересованных сторон, а также устанавливаются критерии успеха.</p></li><li><p>Разработка структуры проекта: Определяются основные компоненты проекта и их взаимосвязи, составляется рабочая структура проекта (WBS), которая разбивает проект на более мелкие и управляемые части.</p></li><li><p>Определение задач и ресурсов: Каждому элементу WBS присваиваются конкретные задачи, определяются ресурсы, необходимые для их выполнения, а также оценивается затрачиваемое время.</p></li><li><p>Определение зависимостей и графика проекта: Определяются логические зависимости между задачами, чтобы установить последовательность и связи между ними. Составляется график выполнения проекта (план-график).</p></li><li><p>Распределение ресурсов: Выполняется распределение ресурсов, таких как люди, оборудование, бюджет, материалы и другие, между различными задачами и этапами проекта.</p></li><li><p>Оценка рисков: Идентифицируются возможные риски проекта, анализируется их воздействие на проект и разрабатываются стратегии управления рисками.</p></li><li><p>Подготовка бюджета: Разрабатывается детализированный бюджет проекта, который включает расходы на ресурсы, затраты на оборудование, материалы, обучение и другие расходы.</p></li><li><p>Составление команды проекта: Формируется команда проекта, назначаются ответственные за различные задачи, и определяется их роли и обязанности.</p></li><li><p>Утверждение плана: Готовый план проекта представляется для утверждения заказчика и руководства, и после одобрения становится основой для реализации проекта.</p></li></ol><p>Планирование программного проекта позволяет предвидеть и организовать все необходимые этапы и ресурсы, что обеспечивает более эффективное управление, предсказуемость и контроль в ходе его выполнения.</p></div>"],["Управление рисками программного проекта","<div class=\\"markdown prose w-full break-words dark:prose-invert light\\"><p>Управление рисками программного проекта - это процесс и методология, которые позволяют выявлять, анализировать, оценивать и управлять потенциальными рисками, которые могут повлиять на успешность проекта. Риски могут быть связаны с техническими, организационными, финансовыми, временными или другими аспектами проекта. Ниже перечислены основные шаги и подходы, применяемые в управлении рисками программного проекта:</p><ol><li><p>Идентификация рисков: На этом этапе происходит выявление всех возможных рисков, которые могут повлиять на проект. Это включает проведение сессий брейншторминга, анализ опыта предыдущих проектов, консультации со специалистами и т.д.</p></li><li><p>Анализ рисков: Каждый выявленный риск анализируется на предмет его потенциального воздействия на проект. Определяется вероятность возникновения риска и его возможные последствия.</p></li><li><p>Оценка рисков: Производится количественная или качественная оценка рисков с учетом их важности и приоритетности для проекта. Это позволяет определить наиболее критические риски, требующие особого внимания.</p></li><li><p>Планирование реагирования на риски: Для каждого выявленного риска разрабатываются стратегии управления. Это включает определение предупредительных мер, планов реагирования в случае возникновения риска и идентификацию ответственных лиц.</p></li><li><p>Мониторинг и контроль рисков: В ходе выполнения проекта риски должны постоянно мониториться. При возникновении риска или изменении его вероятности/воздействия, применяются заранее спланированные меры реагирования.</p></li><li><p>Риск-менеджмент в команде проекта: Каждый участник команды должен быть осведомлен о выявленных рисках и понимать свою роль в минимизации их воздействия на проект.</p></li><li><p>Своевременное информирование заказчика: Руководство и заказчик должны быть осведомлены о выявленных рисках и предпринимаемых мерах управления. Это обеспечивает прозрачность процесса и согласование мероприятий по минимизации рисков.</p></li><li><p>Заключение рисков после завершения проекта: После завершения проекта производится анализ и заключение по управлению рисками, что позволяет выделить успешные подходы и опыт для будущих проектов.</p></li></ol><p>Управление рисками является важной частью процесса управления программными проектами, так как позволяет предотвращать или минимизировать возможные проблемы и неудачи, обеспечивая более успешную реализацию проекта.</p></div>"],["Ключевые участники и заинтересованные стороны","<div class=\\"markdown prose w-full break-words dark:prose-invert light\\"><p>Ключевые участники и заинтересованные стороны (стейкхолдеры) в программном проекте - это лица или группы, которые имеют интерес в проекте, его результате или его выполнении. Успешное управление и удовлетворение потребностей стейкхолдеров играют важную роль в достижении целей проекта. Ниже перечислены некоторые из ключевых участников и заинтересованных сторон в программных проектах:</p><ol><li><p>Заказчик (клиент): Это лицо или организация, которая инициировала и финансирует программный проект. Заказчик имеет основной интерес в успешной реализации проекта, соответствии его результатов ожиданиям и получении созданного продукта или услуги.</p></li><li><p>Пользователи: Пользователи - это те, кто будет использовать программный продукт или получать услуги от проекта. Их потребности и удовлетворенность являются ключевыми факторами успеха проекта.</p></li><li><p>Руководство компании: Руководство компании, к которой относится проект, также является заинтересованной стороной. Их интересы могут быть связаны с финансовой успешностью проекта, его влиянием на организацию и выполнением стратегических целей.</p></li><li><p>Команда проекта: Члены команды, работающие над реализацией проекта, также являются ключевыми участниками. Их роли и усилия направлены на достижение целей проекта и его успешное выполнение.</p></li><li><p>Функциональные менеджеры: Функциональные менеджеры предоставляют ресурсы для проекта и имеют интерес в его успехе, а также влиянии на их собственные функциональные области.</p></li><li><p>Поставщики и партнеры: Поставщики и партнеры, которые предоставляют продукты, услуги или ресурсы для проекта, также являются заинтересованными сторонами, у которых есть свои интересы и ожидания от проекта.</p></li><li><p>Государственные и регулирующие органы: Если проект связан с государственными или регулирующими органами, они могут быть заинтересованы в соответствии проекта законодательству и нормативным требованиям.</p></li><li><p>Общество и общественность: В некоторых проектах общественное мнение и интересы могут иметь значение. Это особенно касается проектов, которые могут повлиять на окружающую среду, здоровье и безопасность людей.</p></li></ol><p>Управление интересами и ожиданиями стейкхолдеров является важной задачей для успешного управления программным проектом. Учитывание их потребностей и вовлечение их в процесс принятия решений помогает достичь согласованных результатов и удовлетворения всех заинтересованных сторон.</p></div>"],["Мониторинг и контроль","<div class=\\"markdown prose w-full break-words dark:prose-invert light\\"><p>Мониторинг и контроль в управлении программными проектами - это процессы и методы, которые позволяют отслеживать выполнение проекта, анализировать его прогресс, выявлять отклонения от плана и принимать корректирующие меры для достижения поставленных целей. Эти процессы осуществляются на протяжении всего жизненного цикла проекта. Ниже перечислены основные шаги и активности, которые выполняются в процессе мониторинга и контроля программного проекта:</p><ol><li><p>Установление метрик и показателей проекта: Определяются ключевые показатели производительности (KPI) и метрики, которые будут использоваться для измерения прогресса и достижения целей проекта.</p></li><li><p>Составление плана мониторинга: Разрабатывается план мониторинга, который определяет, кто и как будет отслеживать и анализировать данные проекта, а также какие инструменты и методы будут использоваться.</p></li><li><p>Сбор данных: Команда проекта собирает данные о выполнении задач, затратах ресурсов, прогрессе работ, рисках и других важных аспектах проекта.</p></li><li><p>Анализ данных: Собранные данные анализируются для определения степени соответствия выполнения проекта его плану, выявления отклонений и идентификации проблемных областей.</p></li><li><p>Выявление рисков и проблем: В процессе мониторинга выявляются новые риски и проблемы, которые могут повлиять на успех проекта.</p></li><li><p>Принятие корректирующих мер: Если выявляются отклонения от плана или проблемы, команда проекта принимает корректирующие меры, чтобы устранить проблемы и вернуть проект на правильный путь.</p></li><li><p>Отчетность: Регулярно составляются отчеты о прогрессе проекта, которые предоставляются руководству и заинтересованным сторонам. Отчеты могут быть формальными или информационными.</p></li><li><p>Вовлечение заинтересованных сторон: Заинтересованные стороны регулярно информируются о прогрессе проекта, и их обратная связь учитывается в принятии решений и планировании дальнейших действий.</p></li><li><p>Регулярные обзоры и аудиты: Производятся регулярные обзоры проекта и аудиты для оценки эффективности мониторинга и контроля и выявления областей для улучшения.</p></li></ol><p>Мониторинг и контроль играют ключевую роль в успешном управлении программными проектами, позволяя своевременно выявлять проблемы, риски и отклонения, а также предпринимать меры для достижения целей и успешной реализации проекта.</p></div>"],["Принципы количественного управления","<div class=\\"markdown prose w-full break-words dark:prose-invert light\\"><p>Принципы количественного управления в программных проектах представляют собой подходы и методологии, которые базируются на анализе данных и использовании количественных показателей для принятия решений и управления проектами. Это позволяет более объективно оценивать проект и его состояние, а также прогнозировать результаты. Ниже перечислены некоторые из принципов количественного управления в программных проектах:</p><ol><li><p>Использование метрик и KPI: Определение ключевых показателей производительности (KPI) и метрик, которые позволяют измерить прогресс, качество и успех проекта.</p></li><li><p>Данные основанные решения: Принятие решений на основе анализа данных и фактов, а не на основе субъективных мнений или предположений.</p></li><li><p>Оценка рисков и прогнозирование: Применение статистических методов для оценки рисков и прогнозирования результатов проекта.</p></li><li><p>Циклический подход: Применение итеративных методологий и циклического подхода к управлению, позволяющего постоянно улучшать процессы и результаты.</p></li><li><p>Контроль качества: Использование статистического контроля качества для отслеживания соответствия проекта установленным стандартам и требованиям.</p></li><li><p>Сравнение с базой данных и стандартами: Сравнение производительности проекта с предыдущими проектами, базами данных и установленными стандартами, чтобы выявить области для улучшения.</p></li><li><p>Оценка производительности команды: Использование данных о производительности команды для определения ее эффективности и выявления возможностей для повышения производительности.</p></li><li><p>Процесс улучшения: Постоянное улучшение процессов управления на основе анализа данных и обратной связи.</p></li><li><p>Фактам и доказательствам основанные отчеты: Составление отчетов на основе фактов и доказательств, а также прозрачная коммуникация результатов проекта и планируемых мер.</p></li></ol><p>Принципы количественного управления позволяют увеличить эффективность управления программными проектами, повысить прозрачность и точность принимаемых решений, а также достичь лучших результатов. Они основываются на применении математических и статистических методов и помогают более обоснованно и объективно управлять проектами.</p></div>"],["Проект и организационная структура компании","<div class=\\"markdown prose w-full break-words dark:prose-invert light\\"><p>Проект и организационная структура компании тесно связаны, и эффективное управление программными проектами требует согласования между этими двумя аспектами. Ниже перечислены основные аспекты, связанные с взаимодействием проекта и организационной структуры компании:</p><ol><li><p>Организационная структура: Организационная структура компании определяет иерархию, деловые отношения и роли сотрудников. В зависимости от типа организационной структуры (функциональной, матричной, проектной и т.д.), роль проекта и его влияние на организацию может различаться.</p></li><li><p>Проектное управление: Успешное выполнение программных проектов требует проектного управления. Это может включать формирование специальной проектной команды, назначение проектного менеджера и установление проектной организационной структуры.</p></li><li><p>Матричная структура: Матричная организационная структура сочетает элементы функциональной и проектной структур. Проектные команды могут состоять из сотрудников разных функциональных подразделений, и управление ресурсами происходит совместно функциональными и проектными менеджерами.</p></li><li><p>Ресурсы и приоритеты: Проектам часто требуется доступ к ресурсам компании, таким как сотрудники, бюджет, оборудование и другие. Организационная структура должна обеспечивать проектам достаточные ресурсы и приоритеты для успешной реализации.</p></li><li><p>Вовлечение руководства: Важным аспектом является вовлечение руководства компании в управление программными проектами. Руководство должно поддерживать проектные инициативы, принимать решения и обеспечивать стратегическую поддержку.</p></li><li><p>Культура организации: Культура организации, ее ценности и подход к управлению проектами также могут повлиять на успех программных проектов. Компания должна обладать гибкой, инновационной и проектно ориентированной культурой для поддержки проектов.</p></li><li><p>Коммуникация и синхронизация: Важно обеспечивать открытую коммуникацию между проектами и организацией. Взаимодействие между проектами и функциональными подразделениями должно быть хорошо синхронизировано для избежания конфликтов и проблем.</p></li><li><p>Управление изменениями: Программные проекты могут вносить изменения в организацию, и организационная структура должна быть готова к адаптации и управлению изменениями.</p></li></ol><p>Успешное управление программными проектами требует гармоничного взаимодействия проекта с организационной структурой компании. Это позволяет максимально использовать ресурсы и оптимизировать работу проектных команд для достижения поставленных целей и обеспечения успеха проектов.</p></div>"],["Управление приоритетами проектов","<div class=\\"markdown prose w-full break-words dark:prose-invert light\\"><p>Управление приоритетами проектов - это процесс определения, оценки и установления приоритетов для различных проектов компании или организации. Поскольку ограниченные ресурсы (бюджет, время, персонал и т.д.) могут быть распределены между несколькими проектами, управление приоритетами позволяет оптимизировать ресурсы и сосредотачиваться на проектах с наибольшей стратегической и бизнес-ценностью. Ниже перечислены основные аспекты управления приоритетами проектов:</p><ol><li><p>Стратегическое выравнивание: Проекты должны быть выровнены с общей стратегией компании или организации. Отбираются проекты, которые наилучшим образом поддерживают стратегические цели и ценности компании.</p></li><li><p>Бизнес-ценность: Каждый проект должен быть оценен с точки зрения его бизнес-ценности и вклада в достижение бизнес-целей. Проекты, которые предоставляют наибольшую ценность и имеют наибольший потенциал возврата, получают более высокий приоритет.</p></li><li><p>Риски и сложность: Оцениваются риски и сложность каждого проекта. Проекты с более низкими рисками или более низкой сложностью могут получить приоритет над проектами с более высокими рисками или сложностью.</p></li><li><p>Доступные ресурсы: Анализируется доступность ресурсов (финансы, персонал, оборудование) для каждого проекта. Проекты, для которых есть достаточные ресурсы, получают более высокий приоритет.</p></li><li><p>Временные рамки: Анализируются сроки выполнения проектов. Проекты, которые должны быть завершены в кратчайшие сроки или имеют важные сроки, могут получить приоритет перед проектами с более гибкими сроками.</p></li><li><p>Отношения с клиентами и заинтересованными сторонами: Взаимодействие с клиентами и заинтересованными сторонами учитывается при определении приоритетов проектов. Проекты, которые имеют стратегическое значение для клиентов, могут получить более высокий приоритет.</p></li><li><p>Постоянное обновление приоритетов: Приоритеты проектов могут меняться в зависимости от изменяющихся условий и потребностей компании. Поэтому управление приоритетами должно быть гибким и регулярно обновляться.</p></li><li><p>Принятие решений на основе данных: Решения о приоритетах проектов должны быть основаны на анализе данных, фактах и целевых показателях, а не на субъективных мнениях или предположениях.</p></li></ol><p>Управление приоритетами проектов помогает компании максимизировать свою эффективность и достигать своих стратегических целей, сосредотачиваясь на наиболее важных и ценных проектах и оптимизируя распределение ресурсов.</p></div>"],["Мотивация","<div class=\\"markdown prose w-full break-words dark:prose-invert light\\"><p>Мотивация в управлении программными проектами - это процесс стимулирования и поддержания интереса, усилий и преданности участников проекта, чтобы они работали на достижение целей проекта с максимальной эффективностью. Мотивация играет важную роль в обеспечении высокой производительности и успешного выполнения проектов. Ниже перечислены основные аспекты мотивации в управлении программными проектами:</p><ol><li><p>Четкие цели и связь с миссией компании: Участники проекта должны четко понимать цели проекта и его вклад в достижение общих стратегических целей компании. Это помогает создать чувство значимости и целенаправленности работы.</p></li><li><p>Признание и вознаграждение: Признание и награды за хорошую работу могут стимулировать участников проекта и повысить их мотивацию. Это может быть как финансовое вознаграждение, так и нематериальные формы признания, такие как похвалы или возможность продвижения.</p></li><li><p>Развитие карьеры и профессиональное развитие: Предоставление возможностей для развития карьеры и повышения профессиональных навыков может стимулировать участников проекта и дать им ощущение роста и прогресса.</p></li><li><p>Участие в принятии решений: Вовлечение участников проекта в принятие решений и предоставление возможности для высказывания своих идей и мнений может усилить их чувство принадлежности и ответственности за проект.</p></li><li><p>Четкое планирование и ресурсное обеспечение: Четкое планирование и обеспечение необходимыми ресурсами проекта создают условия для успешной работы и уменьшают чувство неопределенности, что положительно сказывается на мотивации.</p></li><li><p>Создание положительной рабочей атмосферы: Создание приятной и поддерживающей атмосферы в команде проекта, где сотрудники чувствуют себя уважаемыми и поддержанными, способствует повышению мотивации и эффективности.</p></li><li><p>Поддержка лидерства и команды проекта: Лидеры проекта должны быть вдохновляющими, поддерживающими и обеспечивающими команду необходимой помощью и ресурсами для успешного выполнения проекта.</p></li><li><p>Обратная связь и возможности для улучшения: Предоставление обратной связи участникам проекта помогает им оценить свою работу и узнать, что можно улучшить, что стимулирует стремление к самосовершенствованию.</p></li></ol><p>Мотивация является ключевым элементом управления программными проектами, поскольку она влияет на уровень энергии, участия и преданности участников проекта, что способствует успешной реализации проекта и достижению его целей.</p></div>"],["Жизненный цикл проекта. Фазы и продукты","<div class=\\"markdown prose w-full break-words dark:prose-invert light\\"><p>Жизненный цикл проекта - это последовательность этапов или фаз, через которые проходит проект, начиная с его создания и заканчивая завершением и передачей результатов. Каждая фаза имеет определенные цели, задачи и продукты, которые должны быть достигнуты. Ниже перечислены основные фазы и типичные продукты, которые могут присутствовать на каждом этапе жизненного цикла программного проекта:</p><ol><li><p>Инициация (Initiation):</p><ul><li>Цели и задачи проекта</li><li>Бизнес-кейс (обоснование проекта)</li><li>Анализ заинтересованных сторон</li><li>Определение предварительного бюджета и сроков</li><li>Формирование команды проекта</li><li>Согласование проекта с руководством и заинтересованными сторонами</li></ul></li><li><p>Планирование (Planning):</p><ul><li>Подробное определение задач и работ проекта</li><li>Разработка графика проекта (гантограмма)</li><li>Определение требований к ресурсам и бюджету</li><li>Определение рисков и разработка стратегий управления рисками</li><li>Создание плана коммуникации</li><li>Разработка плана качества и контроля</li></ul></li><li><p>Выполнение (Execution):</p><ul><li>Разработка и тестирование продукта или результата проекта</li><li>Управление ресурсами и командой проекта</li><li>Контроль выполнения работ и сроков</li><li>Решение проблем и рисков</li><li>Контроль качества</li></ul></li><li><p>Мониторинг и контроль (Monitoring and Control):</p><ul><li>Оценка выполнения проекта по плану</li><li>Анализ прогресса и выявление отклонений</li><li>Корректировка плана при необходимости</li><li>Управление рисками</li><li>Обновление и отчетность о прогрессе проекта</li></ul></li><li><p>Завершение (Closure):</p><ul><li>Передача результатов проекта заказчику или пользователю</li><li>Оценка успешности проекта</li><li>Анализ уроков, извлеченных из проекта</li><li>Завершение работы команды проекта</li><li>Закрытие документации и отчетов</li></ul></li></ol><p>Жизненный цикл проекта может различаться в зависимости от типа и характера проекта, а также применяемой методологии управления (например, водопадная, инкрементальная, спиральная и др.). Каждая из этих фаз имеет свои уникальные характеристики и цели, и они обеспечивают структурированный и контролируемый подход к выполнению программного проекта.</p></div>"],["Главные риски программных проектов и способы реагирования","<div class=\\"markdown prose w-full break-words dark:prose-invert light\\"><p>Главные риски программных проектов могут быть разнообразными и зависят от многих факторов, таких как размер и сложность проекта, опытность команды, доступность ресурсов и технологий, изменения требований и другие внешние факторы. Однако ниже перечислены некоторые типичные риски программных проектов и способы реагирования на них:</p><ol><li><p>Неправильное определение требований:</p><ul><li>Способ реагирования: Проактивный анализ и согласование требований с заинтересованными сторонами. Применение методологий с принципами изменения требований (например, гибкие методологии разработки).</li></ul></li><li><p>Ошибки в оценках и планировании:</p><ul><li>Способ реагирования: Реалистичная оценка времени и ресурсов на каждый этап проекта. Использование опытных оценщиков и исторических данных.</li></ul></li><li><p>Недостаточные ресурсы:</p><ul><li>Способ реагирования: Предварительное выделение достаточных ресурсов. Мониторинг доступности ресурсов и их рациональное использование.</li></ul></li><li><p>Технические риски:</p><ul><li>Способ реагирования: Раннее выявление технических сложностей. Применение технических аудитов и профессионального тестирования.</li></ul></li><li><p>Неудачная коммуникация:</p><ul><li>Способ реагирования: Разработка плана коммуникации и своевременное информирование всех заинтересованных сторон. Постоянное обновление коммуникационных каналов.</li></ul></li><li><p>Конфликты в команде:</p><ul><li>Способ реагирования: Проактивное разрешение конфликтов и построение положительной рабочей атмосферы. Поддержка развития команды.</li></ul></li><li><p>Зависимость от внешних поставщиков:</p><ul><li>Способ реагирования: Анализ и диверсификация рисков, связанных с внешними поставщиками. Заключение контрактов с определенными гарантиями.</li></ul></li><li><p>Изменение требований или приоритетов:</p><ul><li>Способ реагирования: Гибкая адаптация проектного плана. Регулярное взаимодействие с заказчиком и принятие обоснованных решений.</li></ul></li><li><p>Недостаточное управление рисками:</p><ul><li>Способ реагирования: Раннее выявление и оценка рисков проекта. Разработка стратегий управления рисками и контроль выполнения этих стратегий.</li></ul></li><li><p>Неправильное управление изменениями:</p></li></ol><ul><li>Способ реагирования: Разработка процесса управления изменениями. Оценка влияния изменений на проект и адаптация плана.</li></ul><p>Каждый риск должен быть выявлен и оценен на ранних стадиях проекта, чтобы предпринимать соответствующие меры по предотвращению или смягчению их последствий. Успешное управление рисками является важным аспектом управления программными проектами и помогает повысить вероятность успешной реализации проекта.</p></div>"],["Лидерство и управление","<div class=\\"markdown prose w-full break-words dark:prose-invert light\\"><p>Лидерство и управление - это две взаимосвязанные, но различные концепции, которые играют ключевую роль в управлении программными проектами. Ниже перечислены основные различия и важные аспекты лидерства и управления в контексте программных проектов:</p><p>Лидерство:</p><ol><li><p>Ориентировано на людей: Лидерство сосредоточено на вдохновении и мотивации команды проекта. Лидеры стремятся развивать потенциал участников проекта, выявлять их сильные стороны и поддерживать их в достижении целей проекта.</p></li><li><p>Влияние и вдохновение: Лидеры влияют на команду не только путем указания задач и контроля, но и путем вдохновения и поддержки. Они стремятся создать эмоциональную связь с командой, чтобы участники проекта чувствовали себя ответственными и преданными проекту.</p></li><li><p>Фокус на видение и стратегию: Лидеры работают над разработкой видения проекта и стратегией для его достижения. Они показывают команде цель проекта и его важность для компании или организации.</p></li><li><p>Продвижение инноваций: Лидеры стимулируют команду на исследование новых и инновационных подходов к решению задач проекта. Они поощряют творческие решения и поддерживают эксперименты.</p></li></ol><p>Управление:</p><ol><li><p>Ориентировано на задачи и процессы: Управление программными проектами сосредоточено на разработке планов, контроле выполнения работ, управлении ресурсами и соблюдении сроков. Управляющие обеспечивают, чтобы все задачи выполнялись в соответствии с планом и процедурами.</p></li><li><p>Контроль и организация: Управляющие обеспечивают соблюдение установленных стандартов и контролируют выполнение проекта. Они организуют работу команды, распределяют ресурсы и решают проблемы, которые могут возникнуть в процессе проекта.</p></li><li><p>Фокус на достижение целей: Управляющие концентрируются на достижении определенных целей проекта. Они заботятся о том, чтобы проект был выполнен в рамках установленного бюджета, сроков и качества.</p></li><li><p>Систематичность и структурированность: Управление проектами строится на структурированных методологиях и подходах к планированию, контролю и управлению рисками. Оно следует определенным процессам и процедурам.</p></li></ol><p>Лидерство и управление оба необходимы для успешного выполнения программных проектов. Лидеры вдохновляют и направляют команду, а управляющие обеспечивают эффективное выполнение работ и достижение целей проекта. Хорошие лидеры-управляющие обладают как навыками мотивации и вдохновения, так и навыками планирования и организации, что позволяет им эффективно управлять проектами и достигать успеха.</p></div>"],["Управление приоритетами проектов","<div class=\\"markdown prose w-full break-words dark:prose-invert light\\"><p>Управление приоритетами проектов - это процесс определения и установления приоритетов для различных проектов в организации или компании. Поскольку ресурсы ограничены, а проектов может быть много, управление приоритетами позволяет оптимизировать распределение ресурсов и сосредотачиваться на наиболее важных и стратегически значимых проектах. Вот основные аспекты управления приоритетами проектов:</p><ol><li><p>Стратегическое выравнивание: Проекты должны быть выровнены с общей стратегией и целями организации. Приоритет следует отдавать проектам, которые наилучшим образом поддерживают стратегические приоритеты компании.</p></li><li><p>Бизнес-ценность: Оценка бизнес-ценности каждого проекта играет важную роль в установлении приоритетов. Проекты, которые предоставляют наибольшую добавленную стоимость или имеют стратегическое значение, должны иметь более высокий приоритет.</p></li><li><p>Ресурсы: Анализ доступности ресурсов (как человеческих, так и финансовых) помогает определить, какие проекты можно выполнить в заданных ограничениях. Приоритет следует отдавать проектам, которые могут быть успешно реализованы с доступными ресурсами.</p></li><li><p>Риски: Оценка рисков каждого проекта также влияет на установление приоритетов. Проекты с высокими рисками или неопределенными факторами могут требовать более тщательного анализа и управления, что может повлиять на их приоритеты.</p></li><li><p>Сроки и срочность: Проекты с жесткими сроками выполнения или с высокой степенью срочности могут получить более высокий приоритет, чтобы обеспечить их своевременное выполнение.</p></li><li><p>Клиентские и внутренние запросы: Приоритет следует отдавать проектам, которые имеют стратегическую значимость для клиентов или других заинтересованных сторон организации.</p></li><li><p>Постоянное обновление: Приоритеты проектов могут меняться со временем в зависимости от изменяющихся потребностей организации, рыночной ситуации и других факторов. Управление приоритетами должно быть гибким и регулярно обновляться.</p></li></ol><p>Управление приоритетами проектов позволяет сосредотачиваться на наиболее важных и ценных проектах, что способствует эффективному использованию ресурсов и достижению стратегических целей компании.</p></div>"],["Управление проектом, направленное на снижение рисков","<div class=\\"markdown prose w-full break-words dark:prose-invert light\\"><p>Управление проектом, направленное на снижение рисков, это подход к управлению программными проектами, который активно уделяет внимание выявлению, анализу и управлению рисками, с целью минимизации возможных негативных последствий и повышения вероятности успешной реализации проекта. Вот некоторые основные аспекты управления проектом, направленного на снижение рисков:</p><ol><li><p>Идентификация рисков: В начале проекта проводится тщательный анализ, чтобы выявить потенциальные риски, которые могут повлиять на проект. Это включает оценку технических, организационных, экономических и других рисков.</p></li><li><p>Анализ и оценка рисков: Выявленные риски анализируются с точки зрения вероятности и воздействия на проект. Оценка рисков позволяет определить, какие риски являются критическими, и разработать стратегии их управления.</p></li><li><p>Планирование управления рисками: Для каждого выявленного риска разрабатываются планы управления рисками, которые включают стратегии по предотвращению, смягчению или переносу рисков, а также определение ответственных за реализацию этих стратегий.</p></li><li><p>Мониторинг рисков: В течение всего проекта риски мониторятся и оцениваются. Это позволяет выявлять новые риски и отслеживать эффективность применяемых стратегий управления рисками.</p></li><li><p>Регулярное обновление плана: План управления рисками должен быть динамическим и регулярно обновляться в соответствии с изменяющимся контекстом проекта. Новые риски могут возникать, а существующие риски могут изменяться, поэтому план управления рисками должен быть гибким.</p></li><li><p>Участие всех заинтересованных сторон: Управление рисками должно быть процессом, вовлекающим все заинтересованные стороны проекта. Каждый участник проекта должен быть в курсе потенциальных рисков и своей роли в их управлении.</p></li><li><p>Культура управления рисками: В организации должна существовать культура управления рисками, которая поддерживает проактивный подход к выявлению и реагированию на риски. Важно стимулировать команду проекта на поиск и анализ рисков, а не скрывать их.</p></li></ol><p>Управление проектом, направленное на снижение рисков, помогает создать более устойчивые и успешные программные проекты, минимизируя возможные угрозы и повышая вероятность достижения поставленных целей.</p></div>"]],"Логическое и функциональное программирование":[["Особенности языков логического программирования","<div class=\\"markdown prose w-full break-words dark:prose-invert light\\"><p>Особенности языков логического программирования:</p><ol><li><p>Декларативный подход: Языки логического программирования основаны на декларативном подходе, который описывает, что должно быть сделано, а не как это должно быть сделано. Программист указывает логические отношения и правила, и система самостоятельно находит способы их выполнения.</p></li><li><p>Использование формальной логики: В основе языков логического программирования лежит математическая логика. Программы формулируются в терминах предикатов, правил вывода и логических утверждений.</p></li><li><p>Использование правил и фактов: Программы на языках логического программирования состоят из правил и фактов. Факты представляют информацию, а правила определяют логические связи между фактами.</p></li><li><p>Обратное унификация: Процесс обратной унификации является основной особенностью языков логического программирования. Он позволяет системе находить значения переменных, которые удовлетворяют логическим отношениям и правилам.</p></li><li><p>Неизменяемость данных: Данные в языках логического программирования обычно являются неизменяемыми. После объявления фактов, они не могут быть изменены или модифицированы.</p></li><li><p>Рекурсия: Рекурсия является важным средством в языках логического программирования. Программы могут вызывать сами себя для решения задачи.</p></li><li><p>Неопределенность порядка выполнения: В логических языках не указывается точный порядок выполнения правил и утверждений. Система сама определяет оптимальный порядок для получения результата.</p></li><li><p>Применение в искусственном интеллекте: Языки логического программирования находят широкое применение в искусственном интеллекте, логическом выводе, базах знаний и экспертных системах.</p></li></ol><p>Примеры популярных языков логического программирования включают Prolog (Programming in Logic) и Datalog (Declarative Datalog). Эти языки обеспечивают элегантный и декларативный способ описания знаний и логических отношений, что делает их полезными инструментами для решения задач, связанных с логическим выводом и рассуждением.</p></div>"],["Особенности языков функционального программирования","<div class=\\"markdown prose w-full break-words dark:prose-invert light\\"><p>Особенности языков функционального программирования:</p><ol><li><p>Функции первого класса: Функции в языках функционального программирования являются объектами первого класса. Это означает, что функции могут передаваться в качестве аргументов другим функциям, возвращаться как результат выполнения функции и сохраняться в переменных.</p></li><li><p>Неизменяемость данных: В функциональном программировании данные обычно считаются неизменяемыми. После создания значения оно не может быть изменено. Вместо этого создаются новые значения на основе старых.</p></li><li><p>Рекурсия: Рекурсия является естественной и распространенной конструкцией в функциональных языках. Вместо циклов, функции часто вызывают сами себя для решения задачи.</p></li><li><p>Отсутствие побочных эффектов: Функциональные языки стараются минимизировать побочные эффекты. Это означает, что функции, как правило, не изменяют состояние программы или внешние данные, а зависят только от входных аргументов.</p></li><li><p>Возможность ленивого вычисления: Некоторые функциональные языки поддерживают ленивое вычисление, что позволяет откладывать вычисление значений до момента, когда они действительно необходимы.</p></li><li><p>Функции высшего порядка: Функциональные языки поддерживают функции высшего порядка, которые могут принимать другие функции в качестве аргументов или возвращать функции как результат выполнения.</p></li><li><p>Каррирование: В некоторых функциональных языках функции автоматически каррируются, что позволяет работать с функциями, имеющими несколько аргументов, как с последовательностью функций с одним аргументом.</p></li><li><p>Программирование без состояния: Функциональные языки стремятся минимизировать использование изменяемых переменных и состояний, что упрощает понимание программы и делает ее более безопасной.</p></li></ol><p>Примеры популярных языков функционального программирования включают Haskell, Lisp, Clojure, Erlang, F# и Scala. Эти языки предоставляют мощные средства для работы с функциями и обработки данных, что делает их привлекательными для решения различных задач, особенно в области параллельного и распределенного программирования.</p></div>"],["Работа со списками на Прологе","<div class=\\"markdown prose w-full break-words dark:prose-invert light\\"><p>Работа со списками на Прологе:</p><p>Пролог предоставляет мощные средства для работы со списками, которые являются одной из основных структур данных в этом языке. Вот основные операции и понятия, связанные с работой со списками на Прологе:</p><ol><li><p>Определение списка: Список в Прологе представляется в виде последовательности элементов, заключенных в квадратные скобки. Например: <code>[a, b, c, d]</code>.</p></li><li><p>Пустой список: Пустой список представляется в Прологе как <code>[]</code>. Он не содержит ни одного элемента.</p></li><li><p>Рекурсивное определение списка: Список в Прологе может быть определен рекурсивно. Например, список <code>[a, b, c, d]</code> можно определить следующим образом: <code>[a | [b, c, d]]</code>.</p></li><li><p>Голова и хвост списка: Голова списка - это его первый элемент, а хвост - это список, который остается после удаления первого элемента. В Прологе используются предикаты <code>head/2</code> и <code>tail/2</code> для работы с головой и хвостом списка соответственно.</p></li><li><p>Длина списка: Длину списка можно вычислить с помощью рекурсивной функции. Например:</p></li></ol><pre><div class=\\"bg-black rounded-md mb-4\\"><div class=\\"flex items-center relative text-gray-200 bg-gray-800 px-4 py-2 text-xs font-sans justify-between rounded-t-md\\"><span>prolog</span><button class=\\"flex ml-auto gap-2\\"><svg stroke=\\"currentColor\\" fill=\\"none\\" stroke-width=\\"2\\" viewBox=\\"0 0 24 24\\" stroke-linecap=\\"round\\" stroke-linejoin=\\"round\\" class=\\"h-4 w-4\\" height=\\"1em\\" width=\\"1em\\" xmlns=\\"http://www.w3.org/2000/svg\\"><path d=\\"M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2\\"></path><rect x=\\"8\\" y=\\"2\\" width=\\"8\\" height=\\"4\\" rx=\\"1\\" ry=\\"1\\"></rect></svg>Copy code</button></div><div class=\\"p-4 overflow-y-auto\\"><code class=\\"!whitespace-pre hljs language-prolog\\">length([], 0).  % Пустой список имеет длину 0\\nlength([_|T], N) :- length(T, N1), N is N1 + 1.  % Длина списка равна длине хвоста плюс 1\\n</code></div></div></pre><ol start=\\"6\\"><li>Объединение списков: Два списка можно объединить с помощью оператора <code>|</code>. Например:</li></ol><pre><div class=\\"bg-black rounded-md mb-4\\"><div class=\\"flex items-center relative text-gray-200 bg-gray-800 px-4 py-2 text-xs font-sans justify-between rounded-t-md\\"><span>prolog</span><button class=\\"flex ml-auto gap-2\\"><svg stroke=\\"currentColor\\" fill=\\"none\\" stroke-width=\\"2\\" viewBox=\\"0 0 24 24\\" stroke-linecap=\\"round\\" stroke-linejoin=\\"round\\" class=\\"h-4 w-4\\" height=\\"1em\\" width=\\"1em\\" xmlns=\\"http://www.w3.org/2000/svg\\"><path d=\\"M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2\\"></path><rect x=\\"8\\" y=\\"2\\" width=\\"8\\" height=\\"4\\" rx=\\"1\\" ry=\\"1\\"></rect></svg>Copy code</button></div><div class=\\"p-4 overflow-y-auto\\"><code class=\\"!whitespace-pre hljs language-prolog\\">append([], L, L).  % Объединение пустого списка и списка L дает сам список L\\nappend([H|T], L, [H|R]) :- append(T, L, R).  % Объединение списка с головой H и хвостом T со списком L дает список с головой H и хвостом R, который получен объединением T и L\\n</code></div></div></pre><ol start=\\"7\\"><li>Поиск элемента в списке: Для поиска элемента в списке используется рекурсивный поиск. Например:</li></ol><pre><div class=\\"bg-black rounded-md mb-4\\"><div class=\\"flex items-center relative text-gray-200 bg-gray-800 px-4 py-2 text-xs font-sans justify-between rounded-t-md\\"><span>prolog</span><button class=\\"flex ml-auto gap-2\\"><svg stroke=\\"currentColor\\" fill=\\"none\\" stroke-width=\\"2\\" viewBox=\\"0 0 24 24\\" stroke-linecap=\\"round\\" stroke-linejoin=\\"round\\" class=\\"h-4 w-4\\" height=\\"1em\\" width=\\"1em\\" xmlns=\\"http://www.w3.org/2000/svg\\"><path d=\\"M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2\\"></path><rect x=\\"8\\" y=\\"2\\" width=\\"8\\" height=\\"4\\" rx=\\"1\\" ry=\\"1\\"></rect></svg>Copy code</button></div><div class=\\"p-4 overflow-y-auto\\"><code class=\\"!whitespace-pre hljs language-prolog\\">member(X, [X|_]).  % Элемент X содержится в списке, если он равен его голове\\nmember(X, [_|T]) :- member(X, T).  % Иначе, ищем X в хвосте списка\\n</code></div></div></pre><ol start=\\"8\\"><li>Удаление элемента из списка: Для удаления элемента из списка можно использовать рекурсивную функцию. Например:</li></ol><pre><div class=\\"bg-black rounded-md mb-4\\"><div class=\\"flex items-center relative text-gray-200 bg-gray-800 px-4 py-2 text-xs font-sans justify-between rounded-t-md\\"><span>prolog</span><button class=\\"flex ml-auto gap-2\\"><svg stroke=\\"currentColor\\" fill=\\"none\\" stroke-width=\\"2\\" viewBox=\\"0 0 24 24\\" stroke-linecap=\\"round\\" stroke-linejoin=\\"round\\" class=\\"h-4 w-4\\" height=\\"1em\\" width=\\"1em\\" xmlns=\\"http://www.w3.org/2000/svg\\"><path d=\\"M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2\\"></path><rect x=\\"8\\" y=\\"2\\" width=\\"8\\" height=\\"4\\" rx=\\"1\\" ry=\\"1\\"></rect></svg>Copy code</button></div><div class=\\"p-4 overflow-y-auto\\"><code class=\\"!whitespace-pre hljs language-prolog\\">remove(X, [X|T], T).  % Если X равен голове списка, то удаление X из списка дает его хвост T\\nremove(X, [H|T], [H|R]) :- remove(X, T, R).  % Иначе, ищем X в хвосте списка и удаляем его оттуда\\n</code></div></div></pre><p>Работа со списками в Прологе позволяет эффективно решать задачи, связанные с обработкой данных и логическим выводом, что делает этот язык мощным инструментом для логического программирования.</p></div>"],["Работа со списками на Haskell","<div class=\\"markdown prose w-full break-words dark:prose-invert light\\"><p>Работа со списками на Haskell:</p><p>Haskell предоставляет богатые средства для работы со списками, которые являются одной из основных структур данных в этом функциональном языке. Вот основные операции и понятия, связанные с работой со списками на Haskell:</p><ol><li><p>Определение списка: Список в Haskell представляется в виде последовательности элементов, разделенных запятыми и заключенных в квадратные скобки. Например: <code>[1, 2, 3, 4]</code>.</p></li><li><p>Пустой список: Пустой список представляется в Haskell как <code>[]</code>. Он не содержит ни одного элемента.</p></li><li><p>Рекурсивное определение списка: Список в Haskell может быть определен рекурсивно. Например, список <code>[1, 2, 3, 4]</code> можно определить следующим образом: <code>1 : (2 : (3 : (4 : [])))</code>, где <code>:</code> - оператор добавления элемента в голову списка.</p></li><li><p>Голова и хвост списка: Голова списка - это его первый элемент, а хвост - это список, который остается после удаления первого элемента. В Haskell используются функции <code>head</code> и <code>tail</code> для работы с головой и хвостом списка соответственно.</p></li><li><p>Длина списка: Длину списка можно вычислить с помощью встроенной функции <code>length</code>.</p></li><li><p>Объединение списков: Два списка можно объединить с помощью оператора <code>++</code>. Например: <code>[1, 2, 3] ++ [4, 5, 6]</code> даст список <code>[1, 2, 3, 4, 5, 6]</code>.</p></li><li><p>Поиск элемента в списке: Для поиска элемента в списке можно использовать функцию <code>elem</code> или оператор <code>elem</code>. Например: <code>elem 3 [1, 2, 3, 4]</code> вернет <code>True</code>, так как элемент <code>3</code> содержится в списке.</p></li><li><p>Удаление элемента из списка: Для удаления элемента из списка можно использовать списковые выражения (list comprehension) или функции высших порядков, такие как <code>filter</code>. Например: <code>filter (/=3) [1, 2, 3, 4]</code> даст список <code>[1, 2, 4]</code>, так как элемент <code>3</code> был удален.</p></li></ol><p>Работа со списками в Haskell позволяет эффективно решать задачи, связанные с обработкой данных, функциональным программированием и реализацией алгоритмов, что делает этот язык мощным инструментом для функционального программирования.</p></div>"],["Рекурсия на прологе","<div class=\\"markdown prose w-full break-words dark:prose-invert light\\"><p>Рекурсия на Прологе:</p><p>Рекурсия в программировании - это процесс, при котором функция вызывает саму себя для решения задачи. Рекурсия является одним из ключевых инструментов в Прологе и широко используется для обработки структур данных, таких как списки и деревья. Вот некоторые особенности и примеры рекурсии на Прологе:</p><ol><li><p>Особенности рекурсии на Прологе:</p><ul><li>В Прологе рекурсия основана на правиле резолюции, которое позволяет системе логического программирования выполнять логический вывод с использованием правил и фактов.</li><li>Рекурсивные правила в Прологе имеют базовый случай (base case), который определяет завершение рекурсии, и рекурсивный случай (recursive case), который определяет вызов функции с измененными параметрами.</li><li>Пролог использует механизм унификации для сопоставления параметров рекурсивного вызова с базовым случаем, что позволяет системе выполнить рекурсивные вызовы до достижения базового случая.</li></ul></li><li><p>Пример рекурсивной функции на Прологе (вычисление факториала):</p></li></ol><pre><div class=\\"bg-black rounded-md mb-4\\"><div class=\\"flex items-center relative text-gray-200 bg-gray-800 px-4 py-2 text-xs font-sans justify-between rounded-t-md\\"><span>prolog</span><button class=\\"flex ml-auto gap-2\\"><svg stroke=\\"currentColor\\" fill=\\"none\\" stroke-width=\\"2\\" viewBox=\\"0 0 24 24\\" stroke-linecap=\\"round\\" stroke-linejoin=\\"round\\" class=\\"h-4 w-4\\" height=\\"1em\\" width=\\"1em\\" xmlns=\\"http://www.w3.org/2000/svg\\"><path d=\\"M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2\\"></path><rect x=\\"8\\" y=\\"2\\" width=\\"8\\" height=\\"4\\" rx=\\"1\\" ry=\\"1\\"></rect></svg>Copy code</button></div><div class=\\"p-4 overflow-y-auto\\"><code class=\\"!whitespace-pre hljs language-prolog\\">factorial(0, 1).  % Базовый случай: факториал 0 равен 1\\nfactorial(N, Result) :-\\n    N &gt; 0,\\n    N1 is N - 1,\\n    factorial(N1, SubResult),\\n    Result is N * SubResult.  % Рекурсивный случай: факториал N равен N умножить на факториал (N - 1)\\n</code></div></div></pre><ol start=\\"3\\"><li>Пример рекурсивной функции на Прологе (поиск элемента в списке):</li></ol><pre><div class=\\"bg-black rounded-md mb-4\\"><div class=\\"flex items-center relative text-gray-200 bg-gray-800 px-4 py-2 text-xs font-sans justify-between rounded-t-md\\"><span>prolog</span><button class=\\"flex ml-auto gap-2\\"><svg stroke=\\"currentColor\\" fill=\\"none\\" stroke-width=\\"2\\" viewBox=\\"0 0 24 24\\" stroke-linecap=\\"round\\" stroke-linejoin=\\"round\\" class=\\"h-4 w-4\\" height=\\"1em\\" width=\\"1em\\" xmlns=\\"http://www.w3.org/2000/svg\\"><path d=\\"M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2\\"></path><rect x=\\"8\\" y=\\"2\\" width=\\"8\\" height=\\"4\\" rx=\\"1\\" ry=\\"1\\"></rect></svg>Copy code</button></div><div class=\\"p-4 overflow-y-auto\\"><code class=\\"!whitespace-pre hljs language-prolog\\">member(X, [X|_]).  % Базовый случай: элемент X содержится в списке, если он равен его голове\\nmember(X, [_|T]) :- member(X, T).  % Рекурсивный случай: ищем X в хвосте списка\\n</code></div></div></pre><ol start=\\"4\\"><li>Рекурсия и рекурсивные структуры:<ul><li>В Прологе можно использовать рекурсивные структуры данных, такие как списки и деревья, и рекурсивные функции для их обработки.</li><li>Пример рекурсивной структуры - рекурсивный список: <code>[[1, 2], [3, 4, [5]], [6]]</code>.</li></ul></li></ol><p>Рекурсия на Прологе является мощным средством для обработки данных и решения различных задач, связанных с логическим программированием. Однако при использовании рекурсии необходимо учитывать возможность зацикливания программы при неправильном определении базового случая или условий рекурсии.</p></div>"],["Рекурсия на Haskell","<div class=\\"markdown prose w-full break-words dark:prose-invert light\\"><p>Рекурсия на Haskell:</p><p>Рекурсия в Haskell - это процесс, при котором функция вызывает саму себя для решения задачи. Haskell является функциональным языком программирования, и рекурсия в нем играет важную роль при обработке данных и решении различных задач. Вот некоторые особенности и примеры рекурсии на Haskell:</p><ol><li><p>Особенности рекурсии на Haskell:</p><ul><li>В Haskell рекурсия основана на принципе математической индукции. Каждая рекурсивная функция имеет базовый случай (base case), который определяет завершение рекурсии, и рекурсивный случай (recursive case), который определяет вызов функции с измененными аргументами.</li><li>В Haskell рекурсия обычно применяется к спискам и рекурсивным структурам данных, таким как деревья.</li></ul></li><li><p>Пример рекурсивной функции на Haskell (вычисление факториала):</p></li></ol><pre><div class=\\"bg-black rounded-md mb-4\\"><div class=\\"flex items-center relative text-gray-200 bg-gray-800 px-4 py-2 text-xs font-sans justify-between rounded-t-md\\"><span>haskell</span><button class=\\"flex ml-auto gap-2\\"><svg stroke=\\"currentColor\\" fill=\\"none\\" stroke-width=\\"2\\" viewBox=\\"0 0 24 24\\" stroke-linecap=\\"round\\" stroke-linejoin=\\"round\\" class=\\"h-4 w-4\\" height=\\"1em\\" width=\\"1em\\" xmlns=\\"http://www.w3.org/2000/svg\\"><path d=\\"M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2\\"></path><rect x=\\"8\\" y=\\"2\\" width=\\"8\\" height=\\"4\\" rx=\\"1\\" ry=\\"1\\"></rect></svg>Copy code</button></div><div class=\\"p-4 overflow-y-auto\\"><code class=\\"!whitespace-pre hljs language-haskell\\">factorial :: Integer -&gt; Integer\\nfactorial 0 = 1  -- Базовый случай: факториал 0 равен 1\\nfactorial n = n * factorial (n - 1)  -- Рекурсивный случай: факториал N равен N умножить на факториал (N - 1)\\n</code></div></div></pre><ol start=\\"3\\"><li>Пример рекурсивной функции на Haskell (поиск элемента в списке):</li></ol><pre><div class=\\"bg-black rounded-md mb-4\\"><div class=\\"flex items-center relative text-gray-200 bg-gray-800 px-4 py-2 text-xs font-sans justify-between rounded-t-md\\"><span>haskell</span><button class=\\"flex ml-auto gap-2\\"><svg stroke=\\"currentColor\\" fill=\\"none\\" stroke-width=\\"2\\" viewBox=\\"0 0 24 24\\" stroke-linecap=\\"round\\" stroke-linejoin=\\"round\\" class=\\"h-4 w-4\\" height=\\"1em\\" width=\\"1em\\" xmlns=\\"http://www.w3.org/2000/svg\\"><path d=\\"M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2\\"></path><rect x=\\"8\\" y=\\"2\\" width=\\"8\\" height=\\"4\\" rx=\\"1\\" ry=\\"1\\"></rect></svg>Copy code</button></div><div class=\\"p-4 overflow-y-auto\\"><code class=\\"!whitespace-pre hljs language-haskell\\">member :: Eq a =&gt; a -&gt; [a] -&gt; Bool\\nmember _ [] = False  -- Базовый случай: элемент не найден в пустом списке\\nmember x (h:t) = x == h || member x t  -- Рекурсивный случай: ищем X в хвосте списка\\n</code></div></div></pre><ol start=\\"4\\"><li>Рекурсия и рекурсивные структуры:<ul><li>В Haskell можно использовать рекурсивные структуры данных, такие как списки и деревья, и рекурсивные функции для их обработки.</li><li>Пример рекурсивной структуры - рекурсивный список: <code>[1, [2], [3, [4]], [5, 6]]</code>.</li></ul></li></ol><p>Рекурсия на Haskell позволяет эффективно решать задачи, связанные с функциональным программированием, обработкой данных и реализацией алгоритмов. Однако при использовании рекурсии необходимо учитывать возможность переполнения стека (stack overflow) при слишком глубокой рекурсии, поэтому иногда требуется использовать хвостовую рекурсию или другие оптимизации.</p></div>"],["Бесконечные структуры данных и ленивые вычисления.","<div class=\\"markdown prose w-full break-words dark:prose-invert light\\"><p>Бесконечные структуры данных и ленивые вычисления:</p><p>Бесконечные структуры данных и ленивые вычисления - это особенности функциональных языков программирования, таких как Haskell, которые позволяют эффективно работать с бесконечными или потенциально бесконечными структурами данных.</p><ol><li><p>Ленивые вычисления:</p><ul><li>Ленивые вычисления (lazy evaluation) означают откладывание вычислений до момента, когда результат станет фактически необходимым.</li><li>В языке Haskell вычисления происходят \\"по требованию\\". Когда функция вызывается, вычисление её результатов может быть отложено до тех пор, пока результат не будет использован в дальнейшем коде.</li><li>Это позволяет работать с бесконечными или потенциально бесконечными структурами данных, такими как бесконечные списки или потоки (streams), не занимая при этом всю доступную память.</li></ul></li><li><p>Пример бесконечной структуры данных - бесконечный список:</p></li></ol><pre><div class=\\"bg-black rounded-md mb-4\\"><div class=\\"flex items-center relative text-gray-200 bg-gray-800 px-4 py-2 text-xs font-sans justify-between rounded-t-md\\"><span>haskell</span><button class=\\"flex ml-auto gap-2\\"><svg stroke=\\"currentColor\\" fill=\\"none\\" stroke-width=\\"2\\" viewBox=\\"0 0 24 24\\" stroke-linecap=\\"round\\" stroke-linejoin=\\"round\\" class=\\"h-4 w-4\\" height=\\"1em\\" width=\\"1em\\" xmlns=\\"http://www.w3.org/2000/svg\\"><path d=\\"M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2\\"></path><rect x=\\"8\\" y=\\"2\\" width=\\"8\\" height=\\"4\\" rx=\\"1\\" ry=\\"1\\"></rect></svg>Copy code</button></div><div class=\\"p-4 overflow-y-auto\\"><code class=\\"!whitespace-pre hljs language-haskell\\">infiniteList :: [Int]\\ninfiniteList = [1..]\\n</code></div></div></pre><p>Этот список будет представлять все положительные целые числа, начиная с 1 и до бесконечности. Он будет доступен для использования, но не будет вычислен полностью.</p><ol start=\\"3\\"><li>Пример ленивых вычислений на Haskell:</li></ol><pre><div class=\\"bg-black rounded-md mb-4\\"><div class=\\"flex items-center relative text-gray-200 bg-gray-800 px-4 py-2 text-xs font-sans justify-between rounded-t-md\\"><span>haskell</span><button class=\\"flex ml-auto gap-2\\"><svg stroke=\\"currentColor\\" fill=\\"none\\" stroke-width=\\"2\\" viewBox=\\"0 0 24 24\\" stroke-linecap=\\"round\\" stroke-linejoin=\\"round\\" class=\\"h-4 w-4\\" height=\\"1em\\" width=\\"1em\\" xmlns=\\"http://www.w3.org/2000/svg\\"><path d=\\"M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2\\"></path><rect x=\\"8\\" y=\\"2\\" width=\\"8\\" height=\\"4\\" rx=\\"1\\" ry=\\"1\\"></rect></svg>Copy code</button></div><div class=\\"p-4 overflow-y-auto\\"><code class=\\"!whitespace-pre hljs language-haskell\\">squareList :: [Int] -&gt; [Int]\\nsquareList xs = map (\\\\x -&gt; x * x) xs\\n</code></div></div></pre><p>В этом примере, когда <code>squareList</code> вызывается с аргументом <code>xs</code>, вычисления для каждого элемента списка <code>xs</code> будут откладываться до тех пор, пока результат не будет реально использован.</p><p>Благодаря ленивым вычислениям, Haskell может эффективно работать с бесконечными или большими структурами данных без необходимости хранить их полностью в памяти. Это делает Haskell мощным инструментом для работы с задачами, связанными с обработкой потоков данных, бесконечными последовательностями и другими сценариями, где требуется эффективная работа с большими объемами данных.</p></div>"],["Сопоставление с образцом. As-образцы. Универсальные образцы.","<div class=\\"markdown prose w-full break-words dark:prose-invert light\\"><p>Сопоставление с образцом (Pattern Matching), As-образцы и Универсальные образцы - это важные концепции, применяемые в функциональных языках программирования, таких как Haskell и ML.</p><ol><li><p>Сопоставление с образцом:</p><ul><li>Сопоставление с образцом - это процесс сопоставления значения или структуры данных с заданным образцом (шаблоном).</li><li>В функциональных языках программирования, сопоставление с образцом используется для выбора соответствующей ветви исполнения на основе структуры или значений аргументов функции.</li></ul></li><li><p>As-образцы (As-patterns):</p><ul><li>As-образцы позволяют привязать переменную к части структуры данных при сопоставлении с образцом.</li><li>Они позволяют использовать имя переменной для обращения к определенной части структуры данных в теле функции.</li><li>Синтаксис As-образца в Haskell выглядит так: <code>var@pattern</code>, где <code>var</code> - имя переменной, а <code>pattern</code> - образец.</li></ul></li></ol><p>Пример As-образца на Haskell:</p><pre><div class=\\"bg-black rounded-md mb-4\\"><div class=\\"flex items-center relative text-gray-200 bg-gray-800 px-4 py-2 text-xs font-sans justify-between rounded-t-md\\"><span>haskell</span><button class=\\"flex ml-auto gap-2\\"><svg stroke=\\"currentColor\\" fill=\\"none\\" stroke-width=\\"2\\" viewBox=\\"0 0 24 24\\" stroke-linecap=\\"round\\" stroke-linejoin=\\"round\\" class=\\"h-4 w-4\\" height=\\"1em\\" width=\\"1em\\" xmlns=\\"http://www.w3.org/2000/svg\\"><path d=\\"M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2\\"></path><rect x=\\"8\\" y=\\"2\\" width=\\"8\\" height=\\"4\\" rx=\\"1\\" ry=\\"1\\"></rect></svg>Copy code</button></div><div class=\\"p-4 overflow-y-auto\\"><code class=\\"!whitespace-pre hljs language-haskell\\">data Point = Point Int Int\\n\\ngetX :: Point -&gt; Int\\ngetX (p@(Point x _)) = x  -- Используем As-образец, чтобы привязать имя \\"p\\" ко всей структуре Point и получить доступ к полю \\"x\\"\\n</code></div></div></pre><ol start=\\"3\\"><li>Универсальные образцы (Wildcards):<ul><li>Универсальные образцы (wildcards) используются для игнорирования значения или структуры данных при сопоставлении.</li><li>Они обозначаются символом подчеркивания <code>_</code> и позволяют сопоставлять только часть аргумента, игнорируя остальное.</li></ul></li></ol><p>Пример универсального образца на Haskell:</p><pre><div class=\\"bg-black rounded-md mb-4\\"><div class=\\"flex items-center relative text-gray-200 bg-gray-800 px-4 py-2 text-xs font-sans justify-between rounded-t-md\\"><span>haskell</span><button class=\\"flex ml-auto gap-2\\"><svg stroke=\\"currentColor\\" fill=\\"none\\" stroke-width=\\"2\\" viewBox=\\"0 0 24 24\\" stroke-linecap=\\"round\\" stroke-linejoin=\\"round\\" class=\\"h-4 w-4\\" height=\\"1em\\" width=\\"1em\\" xmlns=\\"http://www.w3.org/2000/svg\\"><path d=\\"M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2\\"></path><rect x=\\"8\\" y=\\"2\\" width=\\"8\\" height=\\"4\\" rx=\\"1\\" ry=\\"1\\"></rect></svg>Copy code</button></div><div class=\\"p-4 overflow-y-auto\\"><code class=\\"!whitespace-pre hljs language-haskell\\">isThree :: Int -&gt; Bool\\nisThree 3 = True\\nisThree _ = False  -- Универсальный образец для любого другого аргумента, не равного 3\\n</code></div></div></pre><p>Сопоставление с образцом, As-образцы и Универсальные образцы позволяют удобно и эффективно работать с различными структурами данных и значениями в функциональных языках программирования. Они играют важную роль в обработке данных и логическом программировании.</p></div>"],["Семантика сопоставления с образцом. Выражение case. Ленивые образцы.","<div class=\\"markdown prose w-full break-words dark:prose-invert light\\"><p>Семантика сопоставления с образцом, выражение case и ленивые образцы:</p><ol><li><p>Семантика сопоставления с образцом:</p><ul><li>Сопоставление с образцом (Pattern Matching) - это процесс сравнения структуры или значений данных с заданными образцами (шаблонами) и выбора соответствующей ветви исполнения на основе сопоставления.</li><li>Семантика сопоставления с образцом описывает, как выбирается и исполняется соответствующая ветвь на основе заданных образцов.</li></ul></li><li><p>Выражение case:</p><ul><li>Выражение case - это конструкция в функциональных языках программирования, которая используется для сопоставления значения с образцами и определения соответствующего поведения в каждом случае.</li><li>Оно позволяет заменить последовательность вложенных условных операторов, что делает код более читаемым и поддерживаемым.</li></ul></li></ol><p>Пример выражения case на Haskell:</p><pre><div class=\\"bg-black rounded-md mb-4\\"><div class=\\"flex items-center relative text-gray-200 bg-gray-800 px-4 py-2 text-xs font-sans justify-between rounded-t-md\\"><span>haskell</span><button class=\\"flex ml-auto gap-2\\"><svg stroke=\\"currentColor\\" fill=\\"none\\" stroke-width=\\"2\\" viewBox=\\"0 0 24 24\\" stroke-linecap=\\"round\\" stroke-linejoin=\\"round\\" class=\\"h-4 w-4\\" height=\\"1em\\" width=\\"1em\\" xmlns=\\"http://www.w3.org/2000/svg\\"><path d=\\"M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2\\"></path><rect x=\\"8\\" y=\\"2\\" width=\\"8\\" height=\\"4\\" rx=\\"1\\" ry=\\"1\\"></rect></svg>Copy code</button></div><div class=\\"p-4 overflow-y-auto\\"><code class=\\"!whitespace-pre hljs language-haskell\\">dayType :: Int -&gt; String\\ndayType day = case day of\\n    1 -&gt; \\"Weekend\\"\\n    6 -&gt; \\"Weekend\\"\\n    _ -&gt; \\"Weekday\\"\\n</code></div></div></pre><ol start=\\"3\\"><li>Ленивые образцы (Lazy patterns):<ul><li>Ленивые образцы позволяют производить ленивое (отложенное) вычисление при сопоставлении с образцами.</li><li>В Haskell ленивые образцы обозначаются символом <code>~</code> и позволяют отложить вычисление значения до тех пор, пока оно не станет фактически необходимым.</li></ul></li></ol><p>Пример ленивого образца на Haskell:</p><pre><div class=\\"bg-black rounded-md mb-4\\"><div class=\\"flex items-center relative text-gray-200 bg-gray-800 px-4 py-2 text-xs font-sans justify-between rounded-t-md\\"><span>haskell</span><button class=\\"flex ml-auto gap-2\\"><svg stroke=\\"currentColor\\" fill=\\"none\\" stroke-width=\\"2\\" viewBox=\\"0 0 24 24\\" stroke-linecap=\\"round\\" stroke-linejoin=\\"round\\" class=\\"h-4 w-4\\" height=\\"1em\\" width=\\"1em\\" xmlns=\\"http://www.w3.org/2000/svg\\"><path d=\\"M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2\\"></path><rect x=\\"8\\" y=\\"2\\" width=\\"8\\" height=\\"4\\" rx=\\"1\\" ry=\\"1\\"></rect></svg>Copy code</button></div><div class=\\"p-4 overflow-y-auto\\"><code class=\\"!whitespace-pre hljs language-haskell\\">lazyPattern :: (Int, Int) -&gt; Int\\nlazyPattern ~(x, y) = x + y\\n</code></div></div></pre><p>Здесь ленивый образец <code>~(x, y)</code> откладывает вычисление значений <code>x</code> и <code>y</code> до момента их реального использования в теле функции.</p><p>Семантика сопоставления с образцом, выражение case и ленивые образцы являются важными инструментами в функциональных языках программирования. Они позволяют более эффективно и удобно обрабатывать данные и принимать решения на основе их структуры или значений.</p></div>"],["Лексическая видимость и вложенные формы. Let-выражения. Предложение where.","<div class=\\"markdown prose w-full break-words dark:prose-invert light\\"><p>Лексическая видимость, вложенные формы, Let-выражения и предложение where:</p><ol><li><p>Лексическая видимость:</p><ul><li>Лексическая видимость (lexical scoping) - это правило определения области видимости переменных на основе структуры исходного кода программы.</li><li>Переменные, объявленные внутри блока кода, доступны только внутри этого блока и его вложенных блоков, но не видны за их пределами.</li><li>Это правило позволяет избежать конфликтов и неоднозначности имен переменных и обеспечивает более предсказуемое поведение программы.</li></ul></li><li><p>Вложенные формы:</p><ul><li>В функциональных языках программирования возможно создание вложенных форм, таких как вложенные функции, условные выражения и циклы.</li><li>Вложенные формы позволяют более компактно и эффективно описывать логику программы, а также повторно использовать код.</li></ul></li><li><p>Let-выражения:</p><ul><li>Let-выражения представляют собой способ определения локальных переменных в Haskell и других функциональных языках программирования.</li><li>Синтаксис Let-выражения в Haskell выглядит следующим образом:</li></ul><pre><div class=\\"bg-black rounded-md mb-4\\"><div class=\\"flex items-center relative text-gray-200 bg-gray-800 px-4 py-2 text-xs font-sans justify-between rounded-t-md\\"><span>haskell</span><button class=\\"flex ml-auto gap-2\\"><svg stroke=\\"currentColor\\" fill=\\"none\\" stroke-width=\\"2\\" viewBox=\\"0 0 24 24\\" stroke-linecap=\\"round\\" stroke-linejoin=\\"round\\" class=\\"h-4 w-4\\" height=\\"1em\\" width=\\"1em\\" xmlns=\\"http://www.w3.org/2000/svg\\"><path d=\\"M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2\\"></path><rect x=\\"8\\" y=\\"2\\" width=\\"8\\" height=\\"4\\" rx=\\"1\\" ry=\\"1\\"></rect></svg>Copy code</button></div><div class=\\"p-4 overflow-y-auto\\"><code class=\\"!whitespace-pre hljs language-haskell\\">let &lt;binding&gt;\\nin &lt;expression&gt;\\n</code></div></div></pre><ul><li>Они позволяют определить локальные переменные, которые будут доступны только в выражении после ключевого слова <code>in</code>.</li></ul></li></ol><p>Пример Let-выражения на Haskell:</p><pre><div class=\\"bg-black rounded-md mb-4\\"><div class=\\"flex items-center relative text-gray-200 bg-gray-800 px-4 py-2 text-xs font-sans justify-between rounded-t-md\\"><span>haskell</span><button class=\\"flex ml-auto gap-2\\"><svg stroke=\\"currentColor\\" fill=\\"none\\" stroke-width=\\"2\\" viewBox=\\"0 0 24 24\\" stroke-linecap=\\"round\\" stroke-linejoin=\\"round\\" class=\\"h-4 w-4\\" height=\\"1em\\" width=\\"1em\\" xmlns=\\"http://www.w3.org/2000/svg\\"><path d=\\"M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2\\"></path><rect x=\\"8\\" y=\\"2\\" width=\\"8\\" height=\\"4\\" rx=\\"1\\" ry=\\"1\\"></rect></svg>Copy code</button></div><div class=\\"p-4 overflow-y-auto\\"><code class=\\"!whitespace-pre hljs language-haskell\\">squareSum :: Int -&gt; Int -&gt; Int\\nsquareSum x y = let squaredX = x * x\\n                   squaredY = y * y\\n               in squaredX + squaredY\\n</code></div></div></pre><ol start=\\"4\\"><li>Предложение where:<ul><li>Предложение where - это ещё один способ определения локальных переменных в Haskell.</li><li>Оно позволяет определить локальные переменные, которые будут доступны в теле функции, следующем за предложением where.</li><li>Синтаксис предложения where выглядит следующим образом:</li></ul><pre><div class=\\"bg-black rounded-md mb-4\\"><div class=\\"flex items-center relative text-gray-200 bg-gray-800 px-4 py-2 text-xs font-sans justify-between rounded-t-md\\"><span>haskell</span><button class=\\"flex ml-auto gap-2\\"><svg stroke=\\"currentColor\\" fill=\\"none\\" stroke-width=\\"2\\" viewBox=\\"0 0 24 24\\" stroke-linecap=\\"round\\" stroke-linejoin=\\"round\\" class=\\"h-4 w-4\\" height=\\"1em\\" width=\\"1em\\" xmlns=\\"http://www.w3.org/2000/svg\\"><path d=\\"M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2\\"></path><rect x=\\"8\\" y=\\"2\\" width=\\"8\\" height=\\"4\\" rx=\\"1\\" ry=\\"1\\"></rect></svg>Copy code</button></div><div class=\\"p-4 overflow-y-auto\\"><code class=\\"!whitespace-pre hljs language-haskell\\">&lt;expression&gt;\\nwhere &lt;binding&gt;\\n</code></div></div></pre></li></ol><p>Пример предложения where на Haskell:</p><pre><div class=\\"bg-black rounded-md mb-4\\"><div class=\\"flex items-center relative text-gray-200 bg-gray-800 px-4 py-2 text-xs font-sans justify-between rounded-t-md\\"><span>haskell</span><button class=\\"flex ml-auto gap-2\\"><svg stroke=\\"currentColor\\" fill=\\"none\\" stroke-width=\\"2\\" viewBox=\\"0 0 24 24\\" stroke-linecap=\\"round\\" stroke-linejoin=\\"round\\" class=\\"h-4 w-4\\" height=\\"1em\\" width=\\"1em\\" xmlns=\\"http://www.w3.org/2000/svg\\"><path d=\\"M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2\\"></path><rect x=\\"8\\" y=\\"2\\" width=\\"8\\" height=\\"4\\" rx=\\"1\\" ry=\\"1\\"></rect></svg>Copy code</button></div><div class=\\"p-4 overflow-y-auto\\"><code class=\\"!whitespace-pre hljs language-haskell\\">squareSum :: Int -&gt; Int -&gt; Int\\nsquareSum x y = squaredX + squaredY\\n    where\\n        squaredX = x * x\\n        squaredY = y * y\\n</code></div></div></pre><p>Лексическая видимость, вложенные формы, Let-выражения и предложение where позволяют структурировать код, избегать конфликтов и повторно использовать локальные переменные, делая функциональные языки программирования более выразительными и гибкими.</p></div>"],["Комбинаторная логика Х. Карри. Программирование в функциональных обозначениях Л. В. Канторовича.","<div class=\\"markdown prose w-full break-words dark:prose-invert light\\"><p>Комбинаторная логика Х. Карри и программирование в функциональных обозначениях Л. В. Канторовича:</p><ol><li><p>Комбинаторная логика Х. Карри:</p><ul><li>Комбинаторная логика Х. Карри (Combinatory Logic) - это формальная система, разработанная американским математиком Хаскелем Карри, которая изучает комбинаторы и их комбинации для представления и обработки функций.</li><li>Комбинаторы - это функциональные символы без свободных переменных, которые могут быть использованы для построения функций путем комбинирования.</li><li>Комбинаторная логика обладает свойством выразительной силы и универсальности, и она может представить любую вычислимую функцию.</li></ul></li><li><p>Программирование в функциональных обозначениях Л. В. Канторовича:</p><ul><li>Программирование в функциональных обозначениях - это идея разработанная русским математиком и программистом Леонидом Витальевичем Канторовичем, основывающаяся на теории функций и их применении для описания алгоритмов.</li><li>Это подход к программированию, при котором алгоритмы выражаются в терминах функций и их композиций.</li><li>Функции рассматриваются как основной строительный блок программы, и при программировании в функциональных обозначениях акцент делается на использование функций как абстракций и на избегание изменяемого состояния и побочных эффектов.</li></ul></li></ol><p>Оба подхода - комбинаторная логика Х. Карри и программирование в функциональных обозначениях Л. В. Канторовича - относятся к функциональному программированию и обладают сильными математическими основами. Они предоставляют мощные инструменты для разработки алгоритмов и построения выразительных и чистых программ.</p></div>"],["Строго функциональный язык. Элементарные понятия. Символьные данные: лямбда-выражения и представление данных. Элементарные селекторы и конструкторы лямбда-выражений. Элементарные предикаты и арифметика. Рекурсивные функции: разбор случаев, рекурсивные определения, выбор подфункций. Примеры обработки списков.","<div class=\\"markdown prose w-full break-words dark:prose-invert light\\"><p>Строго функциональный язык, элементарные понятия, символьные данные, рекурсивные функции и примеры обработки списков:</p><ol><li><p>Строго функциональный язык:</p><ul><li>Строго функциональный язык программирования - это язык, в котором все вычисления основаны на функциях, и отсутствует понятие изменяемого состояния.</li><li>В строго функциональном языке каждая функция является чистой и детерминированной, то есть для одних и тех же аргументов она всегда возвращает один и тот же результат.</li><li>Отсутствие побочных эффектов делает программы на строго функциональных языках более предсказуемыми, легкими для понимания и тестирования.</li></ul></li><li><p>Символьные данные и лямбда-выражения:</p><ul><li>Символьные данные представляют собой базовые элементы языка, которые используются для создания выражений и данных.</li><li>Лямбда-выражения представляют функции в функциональных языках программирования.</li><li>Лямбда-выражение состоит из абстрактного символа (переменной), точки и тела функции, которое определяет, как функция обрабатывает свой аргумент.</li></ul></li><li><p>Элементарные селекторы и конструкторы лямбда-выражений:</p><ul><li>Элементарные селекторы (selector functions) - это функции, которые возвращают значение одного из аргументов лямбда-выражения.</li><li>Конструкторы (constructor functions) - это функции, которые создают составные данные, объединяя несколько значений в структуру.</li></ul></li><li><p>Элементарные предикаты и арифметика:</p><ul><li>Элементарные предикаты - это функции, которые возвращают булево значение (истина или ложь) на основе свойств данных или их отношений.</li><li>Арифметика в функциональных языках позволяет выполнять арифметические операции над числами.</li></ul></li><li><p>Рекурсивные функции и обработка списков:</p><ul><li>Рекурсивные функции - это функции, которые вызывают сами себя для решения задачи, используя промежуточные результаты.</li><li>Обработка списков является частой задачей в функциональных языках программирования. Списки могут быть рекурсивно разобраны и обработаны с помощью различных функций, таких как функции для добавления элементов в список, удаления элементов, поиска, фильтрации и других манипуляций со списками.</li></ul></li></ol><p>Примеры обработки списков и рекурсивных функций широко используются в функциональных языках программирования для решения различных задач и алгоритмов.</p></div>"],["Дополнительные возможности. Приемы программирования. Аккумуляторы.","<div class=\\"markdown prose w-full break-words dark:prose-invert light\\"><p>Дополнительные возможности, приемы программирования и аккумуляторы:</p><ol><li><p>Дополнительные возможности:</p><ul><li>Функциональные языки программирования предоставляют множество дополнительных возможностей, которые упрощают и облегчают разработку программ:<ul><li>Замыкания (closures) - функции, которые могут захватывать и работать с переменными из окружающего контекста.</li><li>Каррирование (currying) - преобразование функции с несколькими аргументами в последовательность функций с одним аргументом.</li><li>Функции высшего порядка (higher-order functions) - функции, которые могут принимать другие функции в качестве аргументов или возвращать их в качестве результата.</li><li>Рекурсивные типы данных - определение типов данных, которые могут содержать сами себя в качестве части своей структуры.</li><li>Композиция функций - объединение функций для создания новых функций путем последовательного применения.</li><li>Инфиксные и постфиксные операции - возможность использовать операции с различными стилями записи, помимо префиксной (применение операторов к аргументам).</li></ul></li></ul></li><li><p>Приемы программирования:</p><ul><li>В функциональном программировании применяются различные приемы для решения задач и организации кода:<ul><li>Разделение задач на подзадачи и рекурсивное решение их с использованием базовых случаев.</li><li>Использование высокоуровневых абстракций и функций высшего порядка для упрощения кода и улучшения его читаемости.</li><li>Минимизация изменяемого состояния и использование иммутабельных (неизменяемых) данных для предотвращения побочных эффектов.</li><li>Применение подходов к параллельному и конкурентному программированию, так как функциональные языки часто обладают хорошей поддержкой для параллелизма.</li></ul></li></ul></li><li><p>Аккумуляторы:</p><ul><li>В функциональном программировании аккумуляторы представляют собой параметры функций, которые используются для накопления результатов в процессе рекурсивного обхода структур данных.</li><li>Аккумуляторы обычно передаются в рекурсивные функции и используются для хранения промежуточных результатов вычислений.</li><li>Они позволяют избежать необходимости использования изменяемого состояния и сделать функциональный код более чистым и предсказуемым.</li></ul></li></ol><p>Использование дополнительных возможностей, приемов программирования и аккумуляторов позволяет разрабатывать более гибкие, модульные и эффективные функциональные программы, которые легко поддаются масштабированию и поддержке.</p></div>"],["Локальные определения. Функционалы и другие функции высших порядков.","<div class=\\"markdown prose w-full break-words dark:prose-invert light\\"><p>Локальные определения, функционалы и другие функции высших порядков:</p><ol><li>Локальные определения:<ul><li>Локальные определения позволяют определять функции или переменные внутри тела другой функции, которые будут видны только внутри этой функции.</li><li>Это позволяет создавать вспомогательные функции или переменные, которые используются только внутри определенной функции, не загромождая глобальное пространство имен.</li><li>Локальные определения обычно используются в функциональных языках программирования, чтобы сделать код более компактным и легче читаемым.</li></ul></li></ol><p>Пример локального определения на Haskell:</p><pre><div class=\\"bg-black rounded-md mb-4\\"><div class=\\"flex items-center relative text-gray-200 bg-gray-800 px-4 py-2 text-xs font-sans justify-between rounded-t-md\\"><span>haskell</span><button class=\\"flex ml-auto gap-2\\"><svg stroke=\\"currentColor\\" fill=\\"none\\" stroke-width=\\"2\\" viewBox=\\"0 0 24 24\\" stroke-linecap=\\"round\\" stroke-linejoin=\\"round\\" class=\\"h-4 w-4\\" height=\\"1em\\" width=\\"1em\\" xmlns=\\"http://www.w3.org/2000/svg\\"><path d=\\"M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2\\"></path><rect x=\\"8\\" y=\\"2\\" width=\\"8\\" height=\\"4\\" rx=\\"1\\" ry=\\"1\\"></rect></svg>Copy code</button></div><div class=\\"p-4 overflow-y-auto\\"><code class=\\"!whitespace-pre hljs language-haskell\\">-- В данной функции \\"addAndDouble\\" определены локальные функции \\"add\\" и \\"double\\".\\naddAndDouble :: Int -&gt; Int -&gt; Int\\naddAndDouble x y = add x y * 2\\n  where\\n    add a b = a + b\\n    double z = z * 2\\n</code></div></div></pre><ol start=\\"2\\"><li>Функционалы:<ul><li>Функционалы (functionals) - это функции высшего порядка, которые принимают другие функции в качестве аргументов или возвращают их в качестве результата.</li><li>Функционалы позволяют абстрагироваться от конкретных операций и создавать более общие функции, которые могут применяться к различным типам данных или функциональным аргументам.</li></ul></li></ol><p>Пример функционала на Haskell:</p><pre><div class=\\"bg-black rounded-md mb-4\\"><div class=\\"flex items-center relative text-gray-200 bg-gray-800 px-4 py-2 text-xs font-sans justify-between rounded-t-md\\"><span>haskell</span><button class=\\"flex ml-auto gap-2\\"><svg stroke=\\"currentColor\\" fill=\\"none\\" stroke-width=\\"2\\" viewBox=\\"0 0 24 24\\" stroke-linecap=\\"round\\" stroke-linejoin=\\"round\\" class=\\"h-4 w-4\\" height=\\"1em\\" width=\\"1em\\" xmlns=\\"http://www.w3.org/2000/svg\\"><path d=\\"M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2\\"></path><rect x=\\"8\\" y=\\"2\\" width=\\"8\\" height=\\"4\\" rx=\\"1\\" ry=\\"1\\"></rect></svg>Copy code</button></div><div class=\\"p-4 overflow-y-auto\\"><code class=\\"!whitespace-pre hljs language-haskell\\">-- Функционал \\"applyTwice\\" принимает функцию \\"f\\" и аргумент \\"x\\" и применяет функцию \\"f\\" дважды к \\"x\\".\\napplyTwice :: (a -&gt; a) -&gt; a -&gt; a\\napplyTwice f x = f (f x)\\n</code></div></div></pre><ol start=\\"3\\"><li>Другие функции высших порядков:<ul><li>Помимо функционалов, функциональные языки программирования поддерживают множество других функций высших порядков, таких как:<ul><li>Функции отображения (map) - применение функции к каждому элементу списка или другой структуры данных.</li><li>Функции свертки (fold) - комбинирование элементов списка с использованием некоторой ассоциативной операции.</li><li>Функции фильтрации (filter) - выбор элементов списка, которые удовлетворяют заданному условию.</li><li>Функции композиции (compose) - объединение нескольких функций в одну функцию путем последовательного применения.</li></ul></li></ul></li></ol><p>Функциональные языки программирования обладают мощной поддержкой для локальных определений, функционалов и других функций высших порядков, что делает их очень удобными для работы с функциями и абстракциями, способствуя улучшению структуры и читаемости кода.</p></div>"],["Соответствие между функциональными и императивными программами.","<div class=\\"markdown prose w-full break-words dark:prose-invert light\\"><p>Соответствие между функциональными и императивными программами:</p><p>Соответствие между функциональными и императивными программами заключается в том, что многие алгоритмы и задачи могут быть представлены как в функциональном, так и в императивном стиле программирования. Несмотря на то, что данные стили имеют различные подходы к решению задач, важно понимать, что взаимодействие и взаимозаменяемость между ними возможны.</p><ol><li>Императивное программирование:<ul><li>В императивном программировании код описывает последовательность команд, которые указывают, как выполнять действия над данными и как изменять состояние программы.</li><li>Императивный код акцентирует внимание на \\"как\\" и \\"что делать\\" для достижения цели.</li></ul></li></ol><p>Пример императивного кода на Python:</p><pre><div class=\\"bg-black rounded-md mb-4\\"><div class=\\"flex items-center relative text-gray-200 bg-gray-800 px-4 py-2 text-xs font-sans justify-between rounded-t-md\\"><span>python</span><button class=\\"flex ml-auto gap-2\\"><svg stroke=\\"currentColor\\" fill=\\"none\\" stroke-width=\\"2\\" viewBox=\\"0 0 24 24\\" stroke-linecap=\\"round\\" stroke-linejoin=\\"round\\" class=\\"h-4 w-4\\" height=\\"1em\\" width=\\"1em\\" xmlns=\\"http://www.w3.org/2000/svg\\"><path d=\\"M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2\\"></path><rect x=\\"8\\" y=\\"2\\" width=\\"8\\" height=\\"4\\" rx=\\"1\\" ry=\\"1\\"></rect></svg>Copy code</button></div><div class=\\"p-4 overflow-y-auto\\"><code class=\\"!whitespace-pre hljs language-python\\"><span class=\\"hljs-comment\\"># Императивный код для вычисления суммы чисел от 1 до n</span>\\n<span class=\\"hljs-keyword\\">def</span> <span class=\\"hljs-title function_\\">sum_of_numbers</span>(<span class=\\"hljs-params\\">n</span>):\\n    total = <span class=\\"hljs-number\\">0</span>\\n    <span class=\\"hljs-keyword\\">for</span> i <span class=\\"hljs-keyword\\">in</span> <span class=\\"hljs-built_in\\">range</span>(<span class=\\"hljs-number\\">1</span>, n+<span class=\\"hljs-number\\">1</span>):\\n        total += i\\n    <span class=\\"hljs-keyword\\">return</span> total\\n</code></div></div></pre><ol start=\\"2\\"><li>Функциональное программирование:<ul><li>В функциональном программировании код описывает набор функций, которые преобразуют данные без изменения состояния программы или переменных.</li><li>Функциональный код сконцентрирован на \\"что делать\\" и \\"что есть\\" (что данные представляют) для достижения цели.</li></ul></li></ol><p>Пример функционального кода на Haskell:</p><pre><div class=\\"bg-black rounded-md mb-4\\"><div class=\\"flex items-center relative text-gray-200 bg-gray-800 px-4 py-2 text-xs font-sans justify-between rounded-t-md\\"><span>haskell</span><button class=\\"flex ml-auto gap-2\\"><svg stroke=\\"currentColor\\" fill=\\"none\\" stroke-width=\\"2\\" viewBox=\\"0 0 24 24\\" stroke-linecap=\\"round\\" stroke-linejoin=\\"round\\" class=\\"h-4 w-4\\" height=\\"1em\\" width=\\"1em\\" xmlns=\\"http://www.w3.org/2000/svg\\"><path d=\\"M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2\\"></path><rect x=\\"8\\" y=\\"2\\" width=\\"8\\" height=\\"4\\" rx=\\"1\\" ry=\\"1\\"></rect></svg>Copy code</button></div><div class=\\"p-4 overflow-y-auto\\"><code class=\\"!whitespace-pre hljs language-haskell\\">-- Функциональный код для вычисления суммы чисел от 1 до n\\nsumOfNumbers :: Int -&gt; Int\\nsumOfNumbers n = sum [1..n]\\n</code></div></div></pre><p>Соответствие между функциональными и императивными программами возможно через применение конверсий и трансляции между стилями. Однако, стоит отметить, что каждый стиль имеет свои особенности и преимущества, и выбор между ними зависит от конкретных требований задачи, уровня абстракции и предпочтений программиста.</p></div>"]],"Сети ЭВМ и телекоммуникации":[["Основные характеристики, области применения ЭВМ различных классов","<div class=\\"markdown prose w-full break-words dark:prose-invert light\\"><p>Основные характеристики и области применения ЭВМ различных классов:</p><ol><li><p>Области применения и классы ЭВМ:</p><ul><li><p>Суперкомпьютеры:</p><ul><li>Основное предназначение - высокопроизводительные вычисления для научных и инженерных задач.</li><li>Применяются для моделирования сложных процессов, анализа данных, расчетов в области физики, аэродинамики, климатологии, биомедицины и других научных областях.</li><li>Обладают мощными вычислительными ресурсами, высокой параллельностью и большим объемом оперативной памяти.</li></ul></li><li><p>Серверы:</p><ul><li>Используются для предоставления различных услуг и хранения данных в корпоративных и облачных сетях.</li><li>Серверы могут быть ориентированы на веб-хостинг, базы данных, электронную почту, файловое хранилище и другие приложения.</li></ul></li><li><p>Рабочие станции:</p><ul><li>Предназначены для выполнения сложных инженерных, графических и научных задач.</li><li>Используются в проектировании, архитектуре, графическом дизайне, аудио-видео обработке и других профессиональных областях.</li></ul></li><li><p>Персональные компьютеры (ПК):</p><ul><li>Широко распространены и предназначены для общего назначения - выполнения офисных задач, интернет-серфинга, мультимедийных приложений и игр.</li><li>Используются в домашних условиях и офисах для повседневных задач.</li></ul></li><li><p>Мобильные устройства:</p><ul><li>Включают смартфоны, планшеты и ноутбуки.</li><li>Предоставляют мобильный доступ к интернету, коммуникациям, мультимедийным приложениям и мобильным приложениям.</li></ul></li></ul></li><li><p>Основные характеристики:</p><ul><li>Производительность: определяется мощностью процессора, объемом оперативной памяти и графической подсистемы.</li><li>Архитектура процессора: может быть CISC (Complex Instruction Set Computing) или RISC (Reduced Instruction Set Computing).</li><li>Память: включает оперативную память (RAM) для временного хранения данных и постоянную память (жесткий диск, SSD) для долгосрочного хранения данных.</li><li>Порты и интерфейсы: USB, Ethernet, HDMI, аудио, Wi-Fi и другие интерфейсы для подключения устройств.</li><li>Операционная система: программное обеспечение, которое управляет работой компьютера и обеспечивает взаимодействие с пользователем.</li></ul></li></ol><p>Каждый класс ЭВМ имеет свои уникальные характеристики, которые определяют области их применения. Выбор подходящего класса ЭВМ зависит от конкретных требований задачи и необходимых вычислительных возможностей.</p></div>"],["Функциональная и структурная организация процессора","<div class=\\"markdown prose w-full break-words dark:prose-invert light\\"><p>Функциональная и структурная организация процессора:</p><p>Функциональная организация процессора:</p><ol><li>Функциональная организация определяет архитектуру процессора и его функциональные блоки, которые выполняют различные операции.</li><li>Основной компонент - арифметико-логическое устройство (ALU), которое отвечает за выполнение арифметических операций (сложение, вычитание и т.д.) и логических операций (И, ИЛИ, НЕ).</li><li>Функциональная организация также включает блок управления, который управляет последовательностью операций и управляющими сигналами.</li></ol><p>Структурная организация процессора:</p><ol><li>Структурная организация определяет физическую реализацию процессора и связи между его функциональными блоками.</li><li>Включает в себя регистры - быструю память, доступную непосредственно для процессора, используемую для временного хранения данных и инструкций.</li><li>Структурная организация также включает шины данных, адресов и управления, которые обеспечивают передачу информации между различными компонентами процессора и памятью.</li></ol><p>Соотношение между функциональной и структурной организацией процессора:</p><ul><li>Функциональная организация определяет, какие операции и функции должен выполнять процессор, а также его архитектуру.</li><li>Структурная организация определяет, как физически реализованы эти функции и как происходит взаимодействие между компонентами процессора.</li></ul><p>Оба типа организации сильно взаимосвязаны и определяют работу процессора. Функциональная организация влияет на возможности процессора и его архитектуру, а структурная организация воплощает эти возможности в физическом исполнении. Комбинация обеих организаций определяет характеристики процессора, такие как скорость работы, производительность и энергопотребление.</p></div>"],["Организация памяти ЭВМ","<div class=\\"markdown prose w-full break-words dark:prose-invert light\\"><p>Организация памяти ЭВМ:</p><p>Организация памяти в компьютере играет важную роль в хранении данных и инструкций, необходимых для работы программ. Память может быть организована на разных уровнях и с разными характеристиками для обеспечения эффективной работы компьютера.</p><ol><li><p>Основные типы памяти:</p><ul><li><p>Оперативная память (RAM):</p><ul><li>Используется для хранения данных и инструкций, которые компьютер активно использует во время работы программ.</li><li>Оперативная память является \\"временной\\" памятью, так как ее содержимое теряется при выключении компьютера.</li><li>Часто обозначается как \\"виртуальная память\\" и играет важную роль в обеспечении быстрого доступа к данным программ.</li></ul></li><li><p>Постоянная память:</p><ul><li>Используется для хранения данных, которые должны сохраняться после выключения компьютера.</li><li>Включает жесткие диски (HDD), твердотельные накопители (SSD) и оптические диски (CD, DVD, Blu-ray).</li><li>Чаще всего используется для хранения операционной системы, программ и пользовательских данных.</li></ul></li><li><p>Кэш-память:</p><ul><li>Кэш-память является особенной и быстрой формой памяти, используемой для ускорения доступа к данным.</li><li>Она располагается ближе к процессору, чем оперативная и постоянная память, что позволяет уменьшить задержки при доступе к данным.</li></ul></li></ul></li><li><p>Иерархия памяти:</p><ul><li>В компьютере применяется иерархическая организация памяти, где каждый уровень предоставляет определенный компромисс между скоростью и объемом хранения данных.</li><li>Кэш-память обычно представлена несколькими уровнями (L1, L2, L3), расположенными ближе всего к процессору, но с уменьшающимся объемом и возрастанием скорости доступа на каждом последующем уровне.</li><li>Оперативная память и постоянная память составляют более медленные уровни с большим объемом хранения данных.</li></ul></li><li><p>Виртуальная память:</p><ul><li>Виртуальная память используется для обеспечения работы программ, чьи размеры могут превышать объем доступной оперативной памяти.</li><li>Этот механизм позволяет компьютеру использовать часть постоянной памяти в качестве временного хранилища для данных, которые в данный момент не активно используются программами.</li><li>Виртуальная память поддерживается операционной системой и автоматически управляется для обеспечения оптимального использования ресурсов.</li></ul></li></ol><p>Организация памяти в компьютере включает в себя несколько уровней и технологий, обеспечивающих эффективное и удобное хранение и доступ к данным и программам.</p></div>"],["Основные стадии выполнения команды","<div class=\\"markdown prose w-full break-words dark:prose-invert light\\"><p>Основные стадии выполнения команды:</p><p>Выполнение команды в компьютере происходит в несколько этапов, которые образуют основные стадии выполнения команды. Эти этапы называются циклами команд (instruction cycle) и состоят из следующих стадий:</p><ol><li><p>Получение команды (Fetch):</p><ul><li>Процессор считывает следующую команду из памяти по адресу, указанному в регистре команд (Instruction Pointer или Program Counter).</li><li>Считанная команда загружается во внутренний регистр команд процессора для последующего выполнения.</li></ul></li><li><p>Декодирование команды (Decode):</p><ul><li>Считанная команда декодируется процессором для понимания типа операции, операндов и другой необходимой информации.</li><li>Декодирование определяет, какую операцию нужно выполнить и какие данные из памяти или регистров требуются для этой операции.</li></ul></li><li><p>Исполнение команды (Execute):</p><ul><li>Процессор выполняет операцию, указанную в команде, используя данные из предыдущего этапа и/или из регистров процессора.</li><li>На этом этапе происходят арифметические и логические операции, доступ к данным в памяти или регистрах, и т.д.</li></ul></li><li><p>Запись результата (Write Back):</p><ul><li>Результат выполнения команды записывается в регистры процессора или в память, если это необходимо.</li><li>Это позволяет сохранить результат для последующего использования другими командами или программами.</li></ul></li></ol><p>Цикл выполнения команд повторяется для каждой команды в программе, пока программа не завершится или не будет достигнута инструкция прерывания (interrupt).</p><p>Этапы выполнения команды могут различаться в зависимости от архитектуры процессора и его инструкционного набора. В современных процессорах также используются техники предсказания выполнения команд (branch prediction) и параллельного выполнения команд (pipelining), чтобы повысить производительность и эффективность работы процессора.</p></div>"],["Организация прерываний в ЭВМ","<div class=\\"markdown prose w-full break-words dark:prose-invert light\\"><p>Организация прерываний в ЭВМ:</p><p>Прерывания (interrupts) в компьютере — это механизм, который позволяет обрабатывать события или запросы, возникающие вне последовательности исполнения программы, и прерывать текущее выполнение процессора для обработки этих событий. Прерывания позволяют обеспечить отклик системы на внешние события в реальном времени и обрабатывать различные типы запросов, такие как ввод-вывод, таймеры, ошибки и другие.</p><p>Организация прерываний включает следующие основные элементы:</p><ol><li><p>Прерывания и прерывательные устройства:</p><ul><li>Прерывания могут быть вызваны внешними устройствами, такими как контроллеры ввода-вывода, сетевые карты, клавиатура и другие.</li><li>Устройства, способные вызывать прерывания, имеют соответствующие линии прерываний, на которых они активируются при возникновении события.</li></ul></li><li><p>Контроллер прерываний (Interrupt Controller):</p><ul><li>Контроллер прерываний — это специальное устройство, которое управляет и распределяет прерывания от различных устройств.</li><li>Он отвечает за приоритизацию прерываний, чтобы система могла обрабатывать их в нужной последовательности.</li></ul></li><li><p>Процессор и обработка прерываний:</p><ul><li>Когда происходит активация линии прерывания, процессор завершает текущее выполнение команды и переходит в режим обработки прерываний.</li><li>Он сохраняет состояние текущей работы (например, значения регистров и указатель команд) и переключается на обработку прерывания.</li></ul></li><li><p>Обработчики прерываний (Interrupt Handlers):</p><ul><li>Обработчики прерываний — это программные процедуры или функции, которые вызываются при возникновении прерывания.</li><li>Они выполняют обработку события, связанного с прерыванием, и восстанавливают состояние системы после завершения обработки.</li></ul></li><li><p>Приоритеты и маскировка прерываний:</p><ul><li>Прерывания могут иметь различные приоритеты, и некоторые могут быть временно отключены (замаскированы) для предотвращения их активации в определенных условиях.</li></ul></li></ol><p>Прерывания позволяют компьютеру эффективно реагировать на внешние события, минимизировать задержки и обеспечивать отклик системы на различные запросы, что делает их важным компонентом в работе ЭВМ и обеспечивает множество функций, таких как многозадачность, ввод-вывод, управление памятью и другие.</p></div>"],["Организация ввода-вывода","<div class=\\"markdown prose w-full break-words dark:prose-invert light\\"><p>Организация ввода-вывода (Input/Output, I/O) в ЭВМ:</p><p>Организация ввода-вывода в компьютере включает в себя механизмы и методы обмена данными между процессором (ЦПУ) и внешними устройствами, такими как жесткие диски, клавиатура, мышь, принтеры, сетевые карты и другие периферийные устройства. Задача ввода-вывода заключается в обеспечении эффективного и надежного взаимодействия между процессором и устройствами ввода-вывода.</p><p>Основные принципы организации ввода-вывода:</p><ol><li><p>I/O порты:</p><ul><li>Взаимодействие между процессором и устройствами ввода-вывода осуществляется через I/O порты (порты ввода-вывода).</li><li>Каждое устройство ввода-вывода обычно имеет свой адрес в адресном пространстве компьютера, через который оно доступно для обмена данными.</li></ul></li><li><p>Программирование ввода-вывода:</p><ul><li>Для работы с устройствами ввода-вывода, процессор использует специальные команды ввода-вывода, которые позволяют выполнять операции чтения и записи данных.</li><li>Программы должны включать соответствующие команды ввода-вывода, чтобы обмениваться данными с периферийными устройствами.</li></ul></li><li><p>Прерывания:</p><ul><li>Ввод-вывод может осуществляться с использованием прерываний. Когда устройство завершает операцию ввода или вывода, оно может активировать прерывание, чтобы уведомить процессор о завершении операции.</li><li>Процессор может обрабатывать прерывание, вызывая соответствующий обработчик прерывания (interrupt handler) для выполнения дополнительных действий или получения результатов операции.</li></ul></li><li><p>DMA (Direct Memory Access):</p><ul><li>Для ускорения передачи данных между устройствами ввода-вывода и памятью компьютера, используется технология DMA.</li><li>DMA позволяет устройству ввода-вывода напрямую обмениваться данными с памятью, минуя процессор, что увеличивает скорость ввода-вывода.</li></ul></li><li><p>Буферизация:</p><ul><li>Чтобы уменьшить задержки при вводе-выводе данных, используется буферизация.</li><li>Данные временно хранятся в буфере перед передачей между устройством и памятью, что позволяет более эффективно управлять потоком данных.</li></ul></li></ol><p>Организация ввода-вывода включает в себя различные техники и методы, чтобы обеспечить эффективное и надежное взаимодействие между процессором и устройствами ввода-вывода, что является важным аспектом работы компьютерных систем.</p></div>"],["Периферийные устройства","<div class=\\"markdown prose w-full break-words dark:prose-invert light\\"><p>Периферийные устройства - это устройства, которые подключаются к компьютеру или другим электронным устройствам для обеспечения ввода, вывода, хранения данных и выполнения других функций вне основной центральной обработки. Они представляют собой внешние устройства, которые расширяют функциональность компьютерной системы и позволяют пользователю взаимодействовать с компьютером и обрабатывать данные.</p><p>Некоторые примеры периферийных устройств:</p><ol><li><p>Клавиатура: Используется для ввода текста и команд в компьютер.</p></li><li><p>Мышь: Позволяет управлять указателем на экране и осуществлять взаимодействие с графическим интерфейсом пользователя.</p></li><li><p>Монитор: Отображает информацию, созданную компьютером, и позволяет пользователю визуально взаимодействовать с системой.</p></li><li><p>Принтер: Предназначен для вывода текста и графики на бумагу или другие материалы.</p></li><li><p>Сканер: Используется для получения электронных копий документов или изображений с бумаги или других материалов.</p></li><li><p>Жесткий диск (Hard Drive): Служит для хранения данных и программ на длительный срок.</p></li><li><p>USB-накопители: Портативные устройства для хранения данных, которые подключаются через порт USB.</p></li><li><p>Оптические приводы (CD/DVD/Blu-ray): Используются для чтения и записи данных с оптических дисков.</p></li><li><p>Сетевая карта: Предназначена для подключения компьютера к сети.</p></li><li><p>Звуковая карта: Обрабатывает звуковой сигнал, позволяя компьютеру воспроизводить и записывать звук.</p></li><li><p>Веб-камера: Позволяет пользователю видеть и общаться с другими людьми через интернет.</p></li><li><p>Сканер отпечатков пальцев: Используется для биометрической идентификации пользователя.</p></li></ol><p>Это лишь небольшой список разнообразных периферийных устройств, которые могут быть использованы с компьютером. Они значительно расширяют функциональность и возможности компьютерной системы, делая ее более удобной и полезной для пользователей.</p></div>"],["Архитектурные особенности организации ЭВМ различных классов","<div class=\\"markdown prose w-full break-words dark:prose-invert light\\"><p>Архитектурные особенности организации ЭВМ различных классов:</p><ol><li><p>Однопроцессорные ЭВМ:</p><ul><li>Однопроцессорные ЭВМ имеют один процессор (ЦПУ), который выполняет все операции.</li><li>Процессор в таких системах последовательно выполняет команды из памяти.</li></ul></li><li><p>Многопроцессорные ЭВМ:</p><ul><li>Многопроцессорные ЭВМ содержат более одного процессора (двух-, четырех-, многопроцессорные системы).</li><li>Процессоры в таких системах работают параллельно, что позволяет эффективно выполнять параллельные задачи и повышает производительность.</li></ul></li><li><p>Суперкомпьютеры:</p><ul><li>Суперкомпьютеры представляют собой мощные многопроцессорные системы, спроектированные для обработки огромных объемов данных и высокопроизводительных вычислений.</li><li>Они используются в научных и инженерных приложениях, моделировании, криптографии и других областях, где требуются экстремальные вычислительные возможности.</li></ul></li><li><p>Кластеры:</p><ul><li>Кластеры представляют собой сети связанных между собой компьютеров, работающих вместе как единая система.</li><li>Они обладают высокой отказоустойчивостью и масштабируемостью и могут использоваться для распределенных вычислений и хранения больших объемов данных.</li></ul></li><li><p>Встроенные системы:</p><ul><li>Встроенные системы предназначены для выполнения специфических задач во встроенных системах или устройствах.</li><li>Они обычно имеют ограниченные вычислительные возможности, но выполняют строго определенные функции, такие как управление бытовой техникой, автомобильными системами, медицинскими устройствами и т.д.</li></ul></li><li><p>Облако (Cloud Computing):</p><ul><li>Облачные вычисления предоставляют доступ к ресурсам и услугам через интернет.</li><li>Это позволяет пользователям арендовать вычислительные мощности и хранение данных без необходимости владеть физическим оборудованием.</li></ul></li></ol><p>Архитектурные особенности каждого класса ЭВМ определяют его функциональность, производительность, масштабируемость и области применения. Выбор определенного класса ЭВМ зависит от требований задачи и специфических потребностей пользователей.</p></div>"],["Параллельные системы","<div class=\\"markdown prose w-full break-words dark:prose-invert light\\"><p>Параллельные системы - это компьютерные системы или архитектуры, которые используют несколько процессоров (ЦПУ) для выполнения задач параллельно. Вместо последовательной обработки команд каждый процессор обрабатывает свою часть данных или задачи одновременно, что позволяет повысить производительность и ускорить выполнение вычислений.</p><p>Основные особенности параллельных систем:</p><ol><li><p>Параллельные алгоритмы: В параллельных системах используются специальные алгоритмы, которые разбивают задачи на более мелкие подзадачи, которые могут выполняться независимо на разных процессорах.</p></li><li><p>Типы параллелизма:</p><ul><li>Задачи параллельных систем могут быть разделены на несколько потоков (потоковый параллелизм), которые обрабатываются на разных процессорах или ядрах.</li><li>Могут использоваться также векторный параллелизм, когда операции выполняются над массивами данных одновременно.</li></ul></li><li><p>Параллельная обработка данных: В параллельных системах данные могут обрабатываться параллельно, что ускоряет выполнение вычислений, особенно в задачах с большим объемом данных.</p></li><li><p>Модели параллельного программирования: Существуют различные модели и технологии программирования для параллельных систем, такие как использование потоков, процессов, MPI (Message Passing Interface), OpenMP, CUDA и другие.</p></li><li><p>Масштабируемость: Параллельные системы обеспечивают масштабируемость, что означает, что их производительность может увеличиваться с увеличением числа процессоров.</p></li><li><p>Типы параллельных систем:</p><ul><li>Многопроцессорные системы (Multi-Processor Systems): Содержат несколько процессоров в одном компьютере, которые работают независимо друг от друга.</li><li>Кластеры (Clusters): Состоят из нескольких компьютеров, которые работают вместе в сети.</li><li>Суперкомпьютеры (Supercomputers): Это мощные параллельные системы, предназначенные для выполнения сложных и вычислительно интенсивных задач.</li></ul></li></ol><p>Параллельные системы широко используются в научных и инженерных расчетах, обработке больших объемов данных, машинном обучении, графике и других областях, где требуется высокая производительность и эффективность вычислений. Однако, параллельное программирование представляет собой сложную задачу, и эффективность параллельной обработки может зависеть от типа задачи и особенностей архитектуры системы.</p></div>"],["Понятие о многомашинных и многопроцессорных вычислительных система","<div class=\\"markdown prose w-full break-words dark:prose-invert light\\"><p>Многомашинные и многопроцессорные вычислительные системы - это два типа параллельных систем, которые используют несколько процессоров (ЦПУ) для выполнения задач параллельно. Однако они имеют различия в своей структуре и способе организации.</p><ol><li><p>Многомашинные вычислительные системы:</p><ul><li>В многомашинных системах каждый процессор имеет свою собственную память и является независимым компьютером, называемым \\"узлом\\" или \\"машиной\\".</li><li>Узлы соединены сетью, и каждый из них может выполнять свои задачи независимо от других узлов.</li><li>Задачи распределяются между узлами, и они обмениваются данными через сеть.</li><li>Примеры многомашинных систем включают кластеры, где каждый узел представляет собой отдельный компьютер.</li></ul></li><li><p>Многопроцессорные вычислительные системы:</p><ul><li>В многопроцессорных системах несколько процессоров объединяются в единую систему и используют общую память.</li><li>Все процессоры имеют доступ к общей памяти и могут обмениваться данными без необходимости использовать сеть.</li><li>Задачи могут быть разделены на несколько потоков, которые обрабатываются на разных процессорах.</li><li>Многопроцессорные системы предоставляют более прямой и быстрый доступ к общей памяти, чем многомашинные системы.</li><li>Примеры многопроцессорных систем включают системы с несколькими процессорами на одной материнской плате или суперкомпьютеры.</li></ul></li></ol><p>Основное различие между многомашинными и многопроцессорными системами заключается в организации памяти и способе взаимодействия между процессорами. В многомашинных системах каждый процессор имеет свою собственную память и обменивается данными через сеть, в то время как в многопроцессорных системах все процессоры используют общую память и могут обмениваться данными напрямую.</p><p>Выбор между этими двумя типами систем зависит от требований конкретной задачи, структуры данных и алгоритмов, которые будут использоваться.</p></div>"]]}');function _t(e,t){if(null==e)return{};var n,r,s={},l=Object.keys(e);for(r=0;r<l.length;r++)n=l[r],t.indexOf(n)>=0||(s[n]=e[n]);return s}function Lt(e,t){return Lt=Object.setPrototypeOf||function(e,t){return e.__proto__=t,e},Lt(e,t)}function Nt(e,t){e.prototype=Object.create(t.prototype),e.prototype.constructor=e,Lt(e,t)}function Tt(e,t){return e.replace(new RegExp("(^|\\s)"+t+"(?:\\s|$)","g"),"$1").replace(/\s+/g," ").replace(/^\s*|\s*$/g,"")}const Rt=r.createContext(null);var Dt=function(e){return e.scrollTop},It="unmounted",Bt="exited",Mt="entering",Ft="entered",qt="exiting",zt=function(e){function t(t,n){var r;r=e.call(this,t,n)||this;var s,l=n&&!n.isMounting?t.enter:t.appear;return r.appearStatus=null,t.in?l?(s=Bt,r.appearStatus=Mt):s=Ft:s=t.unmountOnExit||t.mountOnEnter?It:Bt,r.state={status:s},r.nextCallback=null,r}Nt(t,e),t.getDerivedStateFromProps=function(e,t){return e.in&&t.status===It?{status:Bt}:null};var s=t.prototype;return s.componentDidMount=function(){this.updateStatus(!0,this.appearStatus)},s.componentDidUpdate=function(e){var t=null;if(e!==this.props){var n=this.state.status;this.props.in?n!==Mt&&n!==Ft&&(t=Mt):n!==Mt&&n!==Ft||(t=qt)}this.updateStatus(!1,t)},s.componentWillUnmount=function(){this.cancelNextCallback()},s.getTimeouts=function(){var e,t,n,r=this.props.timeout;return e=t=n=r,null!=r&&"number"!=typeof r&&(e=r.exit,t=r.enter,n=void 0!==r.appear?r.appear:t),{exit:e,enter:t,appear:n}},s.updateStatus=function(e,t){if(void 0===e&&(e=!1),null!==t)if(this.cancelNextCallback(),t===Mt){if(this.props.unmountOnExit||this.props.mountOnEnter){var r=this.props.nodeRef?this.props.nodeRef.current:n.findDOMNode(this);r&&Dt(r)}this.performEnter(e)}else this.performExit();else this.props.unmountOnExit&&this.state.status===Bt&&this.setState({status:It})},s.performEnter=function(e){var t=this,r=this.props.enter,s=this.context?this.context.isMounting:e,l=this.props.nodeRef?[s]:[n.findDOMNode(this),s],o=l[0],a=l[1],i=this.getTimeouts(),p=s?i.appear:i.enter;e||r?(this.props.onEnter(o,a),this.safeSetState({status:Mt},(function(){t.props.onEntering(o,a),t.onTransitionEnd(p,(function(){t.safeSetState({status:Ft},(function(){t.props.onEntered(o,a)}))}))}))):this.safeSetState({status:Ft},(function(){t.props.onEntered(o)}))},s.performExit=function(){var e=this,t=this.props.exit,r=this.getTimeouts(),s=this.props.nodeRef?void 0:n.findDOMNode(this);t?(this.props.onExit(s),this.safeSetState({status:qt},(function(){e.props.onExiting(s),e.onTransitionEnd(r.exit,(function(){e.safeSetState({status:Bt},(function(){e.props.onExited(s)}))}))}))):this.safeSetState({status:Bt},(function(){e.props.onExited(s)}))},s.cancelNextCallback=function(){null!==this.nextCallback&&(this.nextCallback.cancel(),this.nextCallback=null)},s.safeSetState=function(e,t){t=this.setNextCallback(t),this.setState(e,t)},s.setNextCallback=function(e){var t=this,n=!0;return this.nextCallback=function(r){n&&(n=!1,t.nextCallback=null,e(r))},this.nextCallback.cancel=function(){n=!1},this.nextCallback},s.onTransitionEnd=function(e,t){this.setNextCallback(t);var r=this.props.nodeRef?this.props.nodeRef.current:n.findDOMNode(this),s=null==e&&!this.props.addEndListener;if(r&&!s){if(this.props.addEndListener){var l=this.props.nodeRef?[this.nextCallback]:[r,this.nextCallback],o=l[0],a=l[1];this.props.addEndListener(o,a)}null!=e&&setTimeout(this.nextCallback,e)}else setTimeout(this.nextCallback,0)},s.render=function(){var e=this.state.status;if(e===It)return null;var t=this.props,n=t.children,s=(t.in,t.mountOnEnter,t.unmountOnExit,t.appear,t.enter,t.exit,t.timeout,t.addEndListener,t.onEnter,t.onEntering,t.onEntered,t.onExit,t.onExiting,t.onExited,t.nodeRef,_t(t,["children","in","mountOnEnter","unmountOnExit","appear","enter","exit","timeout","addEndListener","onEnter","onEntering","onEntered","onExit","onExiting","onExited","nodeRef"]));return r.createElement(Rt.Provider,{value:null},"function"==typeof n?n(e,s):r.cloneElement(r.Children.only(n),s))},t}(r.Component);function Ut(){}zt.contextType=Rt,zt.propTypes={},zt.defaultProps={in:!1,mountOnEnter:!1,unmountOnExit:!1,appear:!1,enter:!0,exit:!0,onEnter:Ut,onEntering:Ut,onEntered:Ut,onExit:Ut,onExiting:Ut,onExited:Ut},zt.UNMOUNTED=It,zt.EXITED=Bt,zt.ENTERING=Mt,zt.ENTERED=Ft,zt.EXITING=qt;const Ht=zt;var Vt=function(e,t){return e&&t&&t.split(" ").forEach((function(t){return r=t,void((n=e).classList?n.classList.remove(r):"string"==typeof n.className?n.className=Tt(n.className,r):n.setAttribute("class",Tt(n.className&&n.className.baseVal||"",r)));var n,r}))},Qt=function(e){function t(){for(var t,n=arguments.length,r=new Array(n),s=0;s<n;s++)r[s]=arguments[s];return(t=e.call.apply(e,[this].concat(r))||this).appliedClasses={appear:{},enter:{},exit:{}},t.onEnter=function(e,n){var r=t.resolveArguments(e,n),s=r[0],l=r[1];t.removeClasses(s,"exit"),t.addClass(s,l?"appear":"enter","base"),t.props.onEnter&&t.props.onEnter(e,n)},t.onEntering=function(e,n){var r=t.resolveArguments(e,n),s=r[0],l=r[1]?"appear":"enter";t.addClass(s,l,"active"),t.props.onEntering&&t.props.onEntering(e,n)},t.onEntered=function(e,n){var r=t.resolveArguments(e,n),s=r[0],l=r[1]?"appear":"enter";t.removeClasses(s,l),t.addClass(s,l,"done"),t.props.onEntered&&t.props.onEntered(e,n)},t.onExit=function(e){var n=t.resolveArguments(e)[0];t.removeClasses(n,"appear"),t.removeClasses(n,"enter"),t.addClass(n,"exit","base"),t.props.onExit&&t.props.onExit(e)},t.onExiting=function(e){var n=t.resolveArguments(e)[0];t.addClass(n,"exit","active"),t.props.onExiting&&t.props.onExiting(e)},t.onExited=function(e){var n=t.resolveArguments(e)[0];t.removeClasses(n,"exit"),t.addClass(n,"exit","done"),t.props.onExited&&t.props.onExited(e)},t.resolveArguments=function(e,n){return t.props.nodeRef?[t.props.nodeRef.current,e]:[e,n]},t.getClassNames=function(e){var n=t.props.classNames,r="string"==typeof n,s=r?(r&&n?n+"-":"")+e:n[e];return{baseClassName:s,activeClassName:r?s+"-active":n[e+"Active"],doneClassName:r?s+"-done":n[e+"Done"]}},t}Nt(t,e);var n=t.prototype;return n.addClass=function(e,t,n){var r=this.getClassNames(t)[n+"ClassName"],s=this.getClassNames("enter").doneClassName;"appear"===t&&"done"===n&&s&&(r+=" "+s),"active"===n&&e&&Dt(e),r&&(this.appliedClasses[t][n]=r,function(e,t){e&&t&&t.split(" ").forEach((function(t){return r=t,void((n=e).classList?n.classList.add(r):function(e,t){return e.classList?!!t&&e.classList.contains(t):-1!==(" "+(e.className.baseVal||e.className)+" ").indexOf(" "+t+" ")}(n,r)||("string"==typeof n.className?n.className=n.className+" "+r:n.setAttribute("class",(n.className&&n.className.baseVal||"")+" "+r)));var n,r}))}(e,r))},n.removeClasses=function(e,t){var n=this.appliedClasses[t],r=n.base,s=n.active,l=n.done;this.appliedClasses[t]={},r&&Vt(e,r),s&&Vt(e,s),l&&Vt(e,l)},n.render=function(){var e=this.props,t=(e.classNames,_t(e,["classNames"]));return r.createElement(Ht,l({},t,{onEnter:this.onEnter,onEntered:this.onEntered,onEntering:this.onEntering,onExit:this.onExit,onExiting:this.onExiting,onExited:this.onExited}))},t}(r.Component);Qt.defaultProps={classNames:""},Qt.propTypes={};const $t=Qt;var Wt=function(){return Wt=Object.assign||function(e){for(var t,n=1,r=arguments.length;n<r;n++)for(var s in t=arguments[n])Object.prototype.hasOwnProperty.call(t,s)&&(e[s]=t[s]);return e},Wt.apply(this,arguments)};const Xt=function(e){var n=e.title,s=e.children,l=(e.level,e.isAllVisible),o=e.className,a=function(e,t){var n={};for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&t.indexOf(r)<0&&(n[r]=e[r]);if(null!=e&&"function"==typeof Object.getOwnPropertySymbols){var s=0;for(r=Object.getOwnPropertySymbols(e);s<r.length;s++)t.indexOf(r[s])<0&&Object.prototype.propertyIsEnumerable.call(e,r[s])&&(n[r[s]]=e[r[s]])}return n}(e,["title","children","level","isAllVisible","className"]),i=(0,r.useState)(!1),p=i[0],u=i[1],c=(0,r.useCallback)((function(e){u(!p)}),[p]);(0,r.useEffect)((function(){u(l)}),[l]);var d=(0,r.useRef)(null),f=((0,r.useMemo)((function(){return d.current?{"--content-height":"".concat(d.current.offsetHeight,"px")}:{}}),[]),(0,r.useState)({})),g=f[0],h=f[1];return(0,r.useEffect)((function(){if(d.current){var e=d.current?{"--content-height":"".concat(d.current.offsetHeight,"px")}:{};h(e)}}),[]),(0,t.jsxs)("div",Wt({className:["fold",o,p?"folded":""].join(" ")},a,{children:[(0,t.jsx)("h1",Wt({onClick:c},{children:n}),void 0),(0,t.jsx)($t,Wt({in:p,timeout:100},{children:(0,t.jsx)("div",Wt({className:"content",ref:d,style:g},{children:s}),void 0)}),void 0)]}),void 0)};var Kt=function(){return Kt=Object.assign||function(e){for(var t,n=1,r=arguments.length;n<r;n++)for(var s in t=arguments[n])Object.prototype.hasOwnProperty.call(t,s)&&(e[s]=t[s]);return e},Kt.apply(this,arguments)};const Yt=function(){var e=(0,r.useMemo)((function(){return Object.entries(At)}),[]),n=(0,r.useState)(!1),s=n[0],l=n[1],o=(0,r.useState)(!0),a=o[0],i=o[1];return(0,t.jsxs)("div",Kt({className:"App"},{children:[(0,t.jsxs)("div",Kt({className:"buttons-panel"},{children:[(0,t.jsx)(Pt,{isActive:s,setIsActive:l,changeable:["Скрыть","Раскрыть"],text:"все темы"},void 0),(0,t.jsx)(Pt,{isActive:a,setIsActive:i,changeable:["Скрыть","Раскрыть"],text:"все вопросы"},void 0)]}),void 0),(0,t.jsx)("div",Kt({className:"content main"},{children:e.map((function(e,n){var r=e[0],l=e[1];return(0,t.jsx)(Xt,Kt({isAllVisible:s,className:"theme",title:"".concat(n+1,") ").concat(r),level:1},{children:l.map((function(e,n){var r=e[0],s=e[1];return(0,t.jsx)(Xt,Kt({className:"question",title:"".concat(n+1,". ").concat(r),level:2,isAllVisible:a},{children:(0,t.jsx)("div",{className:"answer",dangerouslySetInnerHTML:{__html:s}},void 0)}),n)}))}),n)}))}),void 0)]}),void 0)};function Gt(e){return Gt="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},Gt(e)}function Jt(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function Zt(e,t){for(var n=0;n<t.length;n++){var r=t[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r)}}function en(e,t,n){return t&&Zt(e.prototype,t),n&&Zt(e,n),Object.defineProperty(e,"prototype",{writable:!1}),e}function tn(e){if(void 0===e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return e}function nn(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function");e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,writable:!0,configurable:!0}}),Object.defineProperty(e,"prototype",{writable:!1}),t&&Lt(e,t)}function rn(e,t){if(t&&("object"===Gt(t)||"function"==typeof t))return t;if(void 0!==t)throw new TypeError("Derived constructors may only return object or undefined");return tn(e)}function sn(e){return sn=Object.setPrototypeOf?Object.getPrototypeOf:function(e){return e.__proto__||Object.getPrototypeOf(e)},sn(e)}function ln(e){if(Array.isArray(e))return e}function on(e,t){(null==t||t>e.length)&&(t=e.length);for(var n=0,r=new Array(t);n<t;n++)r[n]=e[n];return r}function an(e,t){if(e){if("string"==typeof e)return on(e,t);var n=Object.prototype.toString.call(e).slice(8,-1);return"Object"===n&&e.constructor&&(n=e.constructor.name),"Map"===n||"Set"===n?Array.from(e):"Arguments"===n||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)?on(e,t):void 0}}function pn(){throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}function un(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function cn(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?un(Object(n),!0).forEach((function(t){Ae(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):un(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}var dn={type:"logger",log:function(e){this.output("log",e)},warn:function(e){this.output("warn",e)},error:function(e){this.output("error",e)},output:function(e,t){console&&console[e]&&console[e].apply(console,t)}},fn=new(function(){function e(t){var n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};Jt(this,e),this.init(t,n)}return en(e,[{key:"init",value:function(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};this.prefix=t.prefix||"i18next:",this.logger=e||dn,this.options=t,this.debug=t.debug}},{key:"setDebug",value:function(e){this.debug=e}},{key:"log",value:function(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];return this.forward(t,"log","",!0)}},{key:"warn",value:function(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];return this.forward(t,"warn","",!0)}},{key:"error",value:function(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];return this.forward(t,"error","")}},{key:"deprecate",value:function(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];return this.forward(t,"warn","WARNING DEPRECATED: ",!0)}},{key:"forward",value:function(e,t,n,r){return r&&!this.debug?null:("string"==typeof e[0]&&(e[0]="".concat(n).concat(this.prefix," ").concat(e[0])),this.logger[t](e))}},{key:"create",value:function(t){return new e(this.logger,cn(cn({},{prefix:"".concat(this.prefix,":").concat(t,":")}),this.options))}}]),e}()),gn=function(){function e(){Jt(this,e),this.observers={}}return en(e,[{key:"on",value:function(e,t){var n=this;return e.split(" ").forEach((function(e){n.observers[e]=n.observers[e]||[],n.observers[e].push(t)})),this}},{key:"off",value:function(e,t){this.observers[e]&&(t?this.observers[e]=this.observers[e].filter((function(e){return e!==t})):delete this.observers[e])}},{key:"emit",value:function(e){for(var t=arguments.length,n=new Array(t>1?t-1:0),r=1;r<t;r++)n[r-1]=arguments[r];if(this.observers[e]){var s=[].concat(this.observers[e]);s.forEach((function(e){e.apply(void 0,n)}))}if(this.observers["*"]){var l=[].concat(this.observers["*"]);l.forEach((function(t){t.apply(t,[e].concat(n))}))}}}]),e}();function hn(){var e,t,n=new Promise((function(n,r){e=n,t=r}));return n.resolve=e,n.reject=t,n}function vn(e){return null==e?"":""+e}function mn(e,t,n){e.forEach((function(e){t[e]&&(n[e]=t[e])}))}function yn(e,t,n){function r(e){return e&&e.indexOf("###")>-1?e.replace(/###/g,"."):e}function s(){return!e||"string"==typeof e}for(var l="string"!=typeof t?[].concat(t):t.split(".");l.length>1;){if(s())return{};var o=r(l.shift());!e[o]&&n&&(e[o]=new n),e=Object.prototype.hasOwnProperty.call(e,o)?e[o]:{}}return s()?{}:{obj:e,k:r(l.shift())}}function bn(e,t,n){var r=yn(e,t,Object);r.obj[r.k]=n}function wn(e,t){var n=yn(e,t),r=n.obj,s=n.k;if(r)return r[s]}function kn(e,t,n){var r=wn(e,n);return void 0!==r?r:wn(t,n)}function xn(e,t,n){for(var r in t)"__proto__"!==r&&"constructor"!==r&&(r in e?"string"==typeof e[r]||e[r]instanceof String||"string"==typeof t[r]||t[r]instanceof String?n&&(e[r]=t[r]):xn(e[r],t[r],n):e[r]=t[r]);return e}function jn(e){return e.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g,"\\$&")}var Sn={"&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;","/":"&#x2F;"};function En(e){return"string"==typeof e?e.replace(/[&<>"'\/]/g,(function(e){return Sn[e]})):e}var On="undefined"!=typeof window&&window.navigator&&window.navigator.userAgent&&window.navigator.userAgent.indexOf("MSIE")>-1,Cn=[" ",",","?","!",";"];function Pn(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function An(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?Pn(Object(n),!0).forEach((function(t){Ae(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):Pn(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function _n(e,t){var n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:".";if(e){if(e[t])return e[t];for(var r=t.split(n),s=e,l=0;l<r.length;++l){if(!s)return;if("string"==typeof s[r[l]]&&l+1<r.length)return;if(void 0===s[r[l]]){for(var o=2,a=r.slice(l,l+o).join(n),i=s[a];void 0===i&&r.length>l+o;)o++,i=s[a=r.slice(l,l+o).join(n)];if(void 0===i)return;if(t.endsWith(a)){if("string"==typeof i)return i;if(a&&"string"==typeof i[a])return i[a]}var p=r.slice(l+o).join(n);return p?_n(i,p,n):void 0}s=s[r[l]]}return s}}var Ln=function(e){nn(s,e);var t,n,r=(t=s,n=function(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(e){return!1}}(),function(){var e,r=sn(t);if(n){var s=sn(this).constructor;e=Reflect.construct(r,arguments,s)}else e=r.apply(this,arguments);return rn(this,e)});function s(e){var t,n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{ns:["translation"],defaultNS:"translation"};return Jt(this,s),t=r.call(this),On&&gn.call(tn(t)),t.data=e||{},t.options=n,void 0===t.options.keySeparator&&(t.options.keySeparator="."),void 0===t.options.ignoreJSONStructure&&(t.options.ignoreJSONStructure=!0),t}return en(s,[{key:"addNamespaces",value:function(e){this.options.ns.indexOf(e)<0&&this.options.ns.push(e)}},{key:"removeNamespaces",value:function(e){var t=this.options.ns.indexOf(e);t>-1&&this.options.ns.splice(t,1)}},{key:"getResource",value:function(e,t,n){var r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{},s=void 0!==r.keySeparator?r.keySeparator:this.options.keySeparator,l=void 0!==r.ignoreJSONStructure?r.ignoreJSONStructure:this.options.ignoreJSONStructure,o=[e,t];n&&"string"!=typeof n&&(o=o.concat(n)),n&&"string"==typeof n&&(o=o.concat(s?n.split(s):n)),e.indexOf(".")>-1&&(o=e.split("."));var a=wn(this.data,o);return a||!l||"string"!=typeof n?a:_n(this.data&&this.data[e]&&this.data[e][t],n,s)}},{key:"addResource",value:function(e,t,n,r){var s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:{silent:!1},l=this.options.keySeparator;void 0===l&&(l=".");var o=[e,t];n&&(o=o.concat(l?n.split(l):n)),e.indexOf(".")>-1&&(r=t,t=(o=e.split("."))[1]),this.addNamespaces(t),bn(this.data,o,r),s.silent||this.emit("added",e,t,n,r)}},{key:"addResources",value:function(e,t,n){var r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{silent:!1};for(var s in n)"string"!=typeof n[s]&&"[object Array]"!==Object.prototype.toString.apply(n[s])||this.addResource(e,t,s,n[s],{silent:!0});r.silent||this.emit("added",e,t,n)}},{key:"addResourceBundle",value:function(e,t,n,r,s){var l=arguments.length>5&&void 0!==arguments[5]?arguments[5]:{silent:!1},o=[e,t];e.indexOf(".")>-1&&(r=n,n=t,t=(o=e.split("."))[1]),this.addNamespaces(t);var a=wn(this.data,o)||{};r?xn(a,n,s):a=An(An({},a),n),bn(this.data,o,a),l.silent||this.emit("added",e,t,n)}},{key:"removeResourceBundle",value:function(e,t){this.hasResourceBundle(e,t)&&delete this.data[e][t],this.removeNamespaces(t),this.emit("removed",e,t)}},{key:"hasResourceBundle",value:function(e,t){return void 0!==this.getResource(e,t)}},{key:"getResourceBundle",value:function(e,t){return t||(t=this.options.defaultNS),"v1"===this.options.compatibilityAPI?An(An({},{}),this.getResource(e,t)):this.getResource(e,t)}},{key:"getDataByLanguage",value:function(e){return this.data[e]}},{key:"hasLanguageSomeTranslations",value:function(e){var t=this.getDataByLanguage(e);return!!(t&&Object.keys(t)||[]).find((function(e){return t[e]&&Object.keys(t[e]).length>0}))}},{key:"toJSON",value:function(){return this.data}}]),s}(gn),Nn={processors:{},addPostProcessor:function(e){this.processors[e.name]=e},handle:function(e,t,n,r,s){var l=this;return e.forEach((function(e){l.processors[e]&&(t=l.processors[e].process(t,n,r,s))})),t}};function Tn(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function Rn(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?Tn(Object(n),!0).forEach((function(t){Ae(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):Tn(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}var Dn={},In=function(e){nn(s,e);var t,n,r=(t=s,n=function(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(e){return!1}}(),function(){var e,r=sn(t);if(n){var s=sn(this).constructor;e=Reflect.construct(r,arguments,s)}else e=r.apply(this,arguments);return rn(this,e)});function s(e){var t,n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return Jt(this,s),t=r.call(this),On&&gn.call(tn(t)),mn(["resourceStore","languageUtils","pluralResolver","interpolator","backendConnector","i18nFormat","utils"],e,tn(t)),t.options=n,void 0===t.options.keySeparator&&(t.options.keySeparator="."),t.logger=fn.create("translator"),t}return en(s,[{key:"changeLanguage",value:function(e){e&&(this.language=e)}},{key:"exists",value:function(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{interpolation:{}};if(null==e)return!1;var n=this.resolve(e,t);return n&&void 0!==n.res}},{key:"extractFromKey",value:function(e,t){var n=void 0!==t.nsSeparator?t.nsSeparator:this.options.nsSeparator;void 0===n&&(n=":");var r=void 0!==t.keySeparator?t.keySeparator:this.options.keySeparator,s=t.ns||this.options.defaultNS||[],l=n&&e.indexOf(n)>-1,o=!(this.options.userDefinedKeySeparator||t.keySeparator||this.options.userDefinedNsSeparator||t.nsSeparator||function(e,t,n){t=t||"",n=n||"";var r=Cn.filter((function(e){return t.indexOf(e)<0&&n.indexOf(e)<0}));if(0===r.length)return!0;var s=new RegExp("(".concat(r.map((function(e){return"?"===e?"\\?":e})).join("|"),")")),l=!s.test(e);if(!l){var o=e.indexOf(n);o>0&&!s.test(e.substring(0,o))&&(l=!0)}return l}(e,n,r));if(l&&!o){var a=e.match(this.interpolator.nestingRegexp);if(a&&a.length>0)return{key:e,namespaces:s};var i=e.split(n);(n!==r||n===r&&this.options.ns.indexOf(i[0])>-1)&&(s=i.shift()),e=i.join(r)}return"string"==typeof s&&(s=[s]),{key:e,namespaces:s}}},{key:"translate",value:function(e,t,n){var r=this;if("object"!==Gt(t)&&this.options.overloadTranslationOptionHandler&&(t=this.options.overloadTranslationOptionHandler(arguments)),t||(t={}),null==e)return"";Array.isArray(e)||(e=[String(e)]);var l=void 0!==t.keySeparator?t.keySeparator:this.options.keySeparator,o=this.extractFromKey(e[e.length-1],t),a=o.key,i=o.namespaces,p=i[i.length-1],u=t.lng||this.language,c=t.appendNamespaceToCIMode||this.options.appendNamespaceToCIMode;if(u&&"cimode"===u.toLowerCase()){if(c){var d=t.nsSeparator||this.options.nsSeparator;return p+d+a}return a}var f=this.resolve(e,t),g=f&&f.res,h=f&&f.usedKey||a,v=f&&f.exactUsedKey||a,m=Object.prototype.toString.apply(g),y=["[object Number]","[object Function]","[object RegExp]"],b=void 0!==t.joinArrays?t.joinArrays:this.options.joinArrays,w=!this.i18nFormat||this.i18nFormat.handleAsObject,k="string"!=typeof g&&"boolean"!=typeof g&&"number"!=typeof g;if(w&&g&&k&&y.indexOf(m)<0&&("string"!=typeof b||"[object Array]"!==m)){if(!t.returnObjects&&!this.options.returnObjects)return this.options.returnedObjectHandler||this.logger.warn("accessing an object - but returnObjects options is not enabled!"),this.options.returnedObjectHandler?this.options.returnedObjectHandler(h,g,Rn(Rn({},t),{},{ns:i})):"key '".concat(a," (").concat(this.language,")' returned an object instead of string.");if(l){var x="[object Array]"===m,j=x?[]:{},S=x?v:h;for(var E in g)if(Object.prototype.hasOwnProperty.call(g,E)){var O="".concat(S).concat(l).concat(E);j[E]=this.translate(O,Rn(Rn({},t),{joinArrays:!1,ns:i})),j[E]===O&&(j[E]=g[E])}g=j}}else if(w&&"string"==typeof b&&"[object Array]"===m)(g=g.join(b))&&(g=this.extendTranslation(g,e,t,n));else{var C=!1,P=!1,A=void 0!==t.count&&"string"!=typeof t.count,_=s.hasDefaultValue(t),L=A?this.pluralResolver.getSuffix(u,t.count,t):"",N=t["defaultValue".concat(L)]||t.defaultValue;!this.isValidLookup(g)&&_&&(C=!0,g=N),this.isValidLookup(g)||(P=!0,g=a);var T=t.missingKeyNoValueFallbackToKey||this.options.missingKeyNoValueFallbackToKey,R=T&&P?void 0:g,D=_&&N!==g&&this.options.updateMissing;if(P||C||D){if(this.logger.log(D?"updateKey":"missingKey",u,p,a,D?N:g),l){var I=this.resolve(a,Rn(Rn({},t),{},{keySeparator:!1}));I&&I.res&&this.logger.warn("Seems the loaded translations were in flat JSON format instead of nested. Either set keySeparator: false on init or make sure your translations are published in nested format.")}var B=[],M=this.languageUtils.getFallbackCodes(this.options.fallbackLng,t.lng||this.language);if("fallback"===this.options.saveMissingTo&&M&&M[0])for(var F=0;F<M.length;F++)B.push(M[F]);else"all"===this.options.saveMissingTo?B=this.languageUtils.toResolveHierarchy(t.lng||this.language):B.push(t.lng||this.language);var q=function(e,n,s){var l=_&&s!==g?s:R;r.options.missingKeyHandler?r.options.missingKeyHandler(e,p,n,l,D,t):r.backendConnector&&r.backendConnector.saveMissing&&r.backendConnector.saveMissing(e,p,n,l,D,t),r.emit("missingKey",e,p,n,g)};this.options.saveMissing&&(this.options.saveMissingPlurals&&A?B.forEach((function(e){r.pluralResolver.getSuffixes(e,t).forEach((function(n){q([e],a+n,t["defaultValue".concat(n)]||N)}))})):q(B,a,N))}g=this.extendTranslation(g,e,t,f,n),P&&g===a&&this.options.appendNamespaceToMissingKey&&(g="".concat(p,":").concat(a)),(P||C)&&this.options.parseMissingKeyHandler&&(g="v1"!==this.options.compatibilityAPI?this.options.parseMissingKeyHandler(a,C?g:void 0):this.options.parseMissingKeyHandler(g))}return g}},{key:"extendTranslation",value:function(e,t,n,r,s){var l=this;if(this.i18nFormat&&this.i18nFormat.parse)e=this.i18nFormat.parse(e,n,r.usedLng,r.usedNS,r.usedKey,{resolved:r});else if(!n.skipInterpolation){n.interpolation&&this.interpolator.init(Rn(Rn({},n),{interpolation:Rn(Rn({},this.options.interpolation),n.interpolation)}));var o,a="string"==typeof e&&(n&&n.interpolation&&void 0!==n.interpolation.skipOnVariables?n.interpolation.skipOnVariables:this.options.interpolation.skipOnVariables);if(a){var i=e.match(this.interpolator.nestingRegexp);o=i&&i.length}var p=n.replace&&"string"!=typeof n.replace?n.replace:n;if(this.options.interpolation.defaultVariables&&(p=Rn(Rn({},this.options.interpolation.defaultVariables),p)),e=this.interpolator.interpolate(e,p,n.lng||this.language,n),a){var u=e.match(this.interpolator.nestingRegexp);o<(u&&u.length)&&(n.nest=!1)}!1!==n.nest&&(e=this.interpolator.nest(e,(function(){for(var e=arguments.length,r=new Array(e),o=0;o<e;o++)r[o]=arguments[o];return s&&s[0]===r[0]&&!n.context?(l.logger.warn("It seems you are nesting recursively key: ".concat(r[0]," in key: ").concat(t[0])),null):l.translate.apply(l,r.concat([t]))}),n)),n.interpolation&&this.interpolator.reset()}var c=n.postProcess||this.options.postProcess,d="string"==typeof c?[c]:c;return null!=e&&d&&d.length&&!1!==n.applyPostProcessor&&(e=Nn.handle(d,e,t,this.options&&this.options.postProcessPassResolved?Rn({i18nResolved:r},n):n,this)),e}},{key:"resolve",value:function(e){var t,n,r,s,l,o=this,a=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return"string"==typeof e&&(e=[e]),e.forEach((function(e){if(!o.isValidLookup(t)){var i=o.extractFromKey(e,a),p=i.key;n=p;var u=i.namespaces;o.options.fallbackNS&&(u=u.concat(o.options.fallbackNS));var c=void 0!==a.count&&"string"!=typeof a.count,d=c&&!a.ordinal&&0===a.count&&o.pluralResolver.shouldUseIntlApi(),f=void 0!==a.context&&("string"==typeof a.context||"number"==typeof a.context)&&""!==a.context,g=a.lngs?a.lngs:o.languageUtils.toResolveHierarchy(a.lng||o.language,a.fallbackLng);u.forEach((function(e){o.isValidLookup(t)||(l=e,!Dn["".concat(g[0],"-").concat(e)]&&o.utils&&o.utils.hasLoadedNamespace&&!o.utils.hasLoadedNamespace(l)&&(Dn["".concat(g[0],"-").concat(e)]=!0,o.logger.warn('key "'.concat(n,'" for languages "').concat(g.join(", "),'" won\'t get resolved as namespace "').concat(l,'" was not yet loaded'),"This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!")),g.forEach((function(n){if(!o.isValidLookup(t)){s=n;var l,i=[p];if(o.i18nFormat&&o.i18nFormat.addLookupKeys)o.i18nFormat.addLookupKeys(i,p,n,e,a);else{var u;c&&(u=o.pluralResolver.getSuffix(n,a.count,a));var g="_zero";if(c&&(i.push(p+u),d&&i.push(p+g)),f){var h="".concat(p).concat(o.options.contextSeparator).concat(a.context);i.push(h),c&&(i.push(h+u),d&&i.push(h+g))}}for(;l=i.pop();)o.isValidLookup(t)||(r=l,t=o.getResource(n,e,l,a))}})))}))}})),{res:t,usedKey:n,exactUsedKey:r,usedLng:s,usedNS:l}}},{key:"isValidLookup",value:function(e){return!(void 0===e||!this.options.returnNull&&null===e||!this.options.returnEmptyString&&""===e)}},{key:"getResource",value:function(e,t,n){var r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};return this.i18nFormat&&this.i18nFormat.getResource?this.i18nFormat.getResource(e,t,n,r):this.resourceStore.getResource(e,t,n,r)}}],[{key:"hasDefaultValue",value:function(e){var t="defaultValue";for(var n in e)if(Object.prototype.hasOwnProperty.call(e,n)&&t===n.substring(0,t.length)&&void 0!==e[n])return!0;return!1}}]),s}(gn);function Bn(e){return e.charAt(0).toUpperCase()+e.slice(1)}var Mn=function(){function e(t){Jt(this,e),this.options=t,this.supportedLngs=this.options.supportedLngs||!1,this.logger=fn.create("languageUtils")}return en(e,[{key:"getScriptPartFromCode",value:function(e){if(!e||e.indexOf("-")<0)return null;var t=e.split("-");return 2===t.length?null:(t.pop(),"x"===t[t.length-1].toLowerCase()?null:this.formatLanguageCode(t.join("-")))}},{key:"getLanguagePartFromCode",value:function(e){if(!e||e.indexOf("-")<0)return e;var t=e.split("-");return this.formatLanguageCode(t[0])}},{key:"formatLanguageCode",value:function(e){if("string"==typeof e&&e.indexOf("-")>-1){var t=["hans","hant","latn","cyrl","cans","mong","arab"],n=e.split("-");return this.options.lowerCaseLng?n=n.map((function(e){return e.toLowerCase()})):2===n.length?(n[0]=n[0].toLowerCase(),n[1]=n[1].toUpperCase(),t.indexOf(n[1].toLowerCase())>-1&&(n[1]=Bn(n[1].toLowerCase()))):3===n.length&&(n[0]=n[0].toLowerCase(),2===n[1].length&&(n[1]=n[1].toUpperCase()),"sgn"!==n[0]&&2===n[2].length&&(n[2]=n[2].toUpperCase()),t.indexOf(n[1].toLowerCase())>-1&&(n[1]=Bn(n[1].toLowerCase())),t.indexOf(n[2].toLowerCase())>-1&&(n[2]=Bn(n[2].toLowerCase()))),n.join("-")}return this.options.cleanCode||this.options.lowerCaseLng?e.toLowerCase():e}},{key:"isSupportedCode",value:function(e){return("languageOnly"===this.options.load||this.options.nonExplicitSupportedLngs)&&(e=this.getLanguagePartFromCode(e)),!this.supportedLngs||!this.supportedLngs.length||this.supportedLngs.indexOf(e)>-1}},{key:"getBestMatchFromCodes",value:function(e){var t,n=this;return e?(e.forEach((function(e){if(!t){var r=n.formatLanguageCode(e);n.options.supportedLngs&&!n.isSupportedCode(r)||(t=r)}})),!t&&this.options.supportedLngs&&e.forEach((function(e){if(!t){var r=n.getLanguagePartFromCode(e);if(n.isSupportedCode(r))return t=r;t=n.options.supportedLngs.find((function(e){if(0===e.indexOf(r))return e}))}})),t||(t=this.getFallbackCodes(this.options.fallbackLng)[0]),t):null}},{key:"getFallbackCodes",value:function(e,t){if(!e)return[];if("function"==typeof e&&(e=e(t)),"string"==typeof e&&(e=[e]),"[object Array]"===Object.prototype.toString.apply(e))return e;if(!t)return e.default||[];var n=e[t];return n||(n=e[this.getScriptPartFromCode(t)]),n||(n=e[this.formatLanguageCode(t)]),n||(n=e[this.getLanguagePartFromCode(t)]),n||(n=e.default),n||[]}},{key:"toResolveHierarchy",value:function(e,t){var n=this,r=this.getFallbackCodes(t||this.options.fallbackLng||[],e),s=[],l=function(e){e&&(n.isSupportedCode(e)?s.push(e):n.logger.warn("rejecting language code not found in supportedLngs: ".concat(e)))};return"string"==typeof e&&e.indexOf("-")>-1?("languageOnly"!==this.options.load&&l(this.formatLanguageCode(e)),"languageOnly"!==this.options.load&&"currentOnly"!==this.options.load&&l(this.getScriptPartFromCode(e)),"currentOnly"!==this.options.load&&l(this.getLanguagePartFromCode(e))):"string"==typeof e&&l(this.formatLanguageCode(e)),r.forEach((function(e){s.indexOf(e)<0&&l(n.formatLanguageCode(e))})),s}}]),e}(),Fn=[{lngs:["ach","ak","am","arn","br","fil","gun","ln","mfe","mg","mi","oc","pt","pt-BR","tg","tl","ti","tr","uz","wa"],nr:[1,2],fc:1},{lngs:["af","an","ast","az","bg","bn","ca","da","de","dev","el","en","eo","es","et","eu","fi","fo","fur","fy","gl","gu","ha","hi","hu","hy","ia","it","kk","kn","ku","lb","mai","ml","mn","mr","nah","nap","nb","ne","nl","nn","no","nso","pa","pap","pms","ps","pt-PT","rm","sco","se","si","so","son","sq","sv","sw","ta","te","tk","ur","yo"],nr:[1,2],fc:2},{lngs:["ay","bo","cgg","fa","ht","id","ja","jbo","ka","km","ko","ky","lo","ms","sah","su","th","tt","ug","vi","wo","zh"],nr:[1],fc:3},{lngs:["be","bs","cnr","dz","hr","ru","sr","uk"],nr:[1,2,5],fc:4},{lngs:["ar"],nr:[0,1,2,3,11,100],fc:5},{lngs:["cs","sk"],nr:[1,2,5],fc:6},{lngs:["csb","pl"],nr:[1,2,5],fc:7},{lngs:["cy"],nr:[1,2,3,8],fc:8},{lngs:["fr"],nr:[1,2],fc:9},{lngs:["ga"],nr:[1,2,3,7,11],fc:10},{lngs:["gd"],nr:[1,2,3,20],fc:11},{lngs:["is"],nr:[1,2],fc:12},{lngs:["jv"],nr:[0,1],fc:13},{lngs:["kw"],nr:[1,2,3,4],fc:14},{lngs:["lt"],nr:[1,2,10],fc:15},{lngs:["lv"],nr:[1,2,0],fc:16},{lngs:["mk"],nr:[1,2],fc:17},{lngs:["mnk"],nr:[0,1,2],fc:18},{lngs:["mt"],nr:[1,2,11,20],fc:19},{lngs:["or"],nr:[2,1],fc:2},{lngs:["ro"],nr:[1,2,20],fc:20},{lngs:["sl"],nr:[5,1,2,3],fc:21},{lngs:["he","iw"],nr:[1,2,20,21],fc:22}],qn={1:function(e){return Number(e>1)},2:function(e){return Number(1!=e)},3:function(e){return 0},4:function(e){return Number(e%10==1&&e%100!=11?0:e%10>=2&&e%10<=4&&(e%100<10||e%100>=20)?1:2)},5:function(e){return Number(0==e?0:1==e?1:2==e?2:e%100>=3&&e%100<=10?3:e%100>=11?4:5)},6:function(e){return Number(1==e?0:e>=2&&e<=4?1:2)},7:function(e){return Number(1==e?0:e%10>=2&&e%10<=4&&(e%100<10||e%100>=20)?1:2)},8:function(e){return Number(1==e?0:2==e?1:8!=e&&11!=e?2:3)},9:function(e){return Number(e>=2)},10:function(e){return Number(1==e?0:2==e?1:e<7?2:e<11?3:4)},11:function(e){return Number(1==e||11==e?0:2==e||12==e?1:e>2&&e<20?2:3)},12:function(e){return Number(e%10!=1||e%100==11)},13:function(e){return Number(0!==e)},14:function(e){return Number(1==e?0:2==e?1:3==e?2:3)},15:function(e){return Number(e%10==1&&e%100!=11?0:e%10>=2&&(e%100<10||e%100>=20)?1:2)},16:function(e){return Number(e%10==1&&e%100!=11?0:0!==e?1:2)},17:function(e){return Number(1==e||e%10==1&&e%100!=11?0:1)},18:function(e){return Number(0==e?0:1==e?1:2)},19:function(e){return Number(1==e?0:0==e||e%100>1&&e%100<11?1:e%100>10&&e%100<20?2:3)},20:function(e){return Number(1==e?0:0==e||e%100>0&&e%100<20?1:2)},21:function(e){return Number(e%100==1?1:e%100==2?2:e%100==3||e%100==4?3:0)},22:function(e){return Number(1==e?0:2==e?1:(e<0||e>10)&&e%10==0?2:3)}},zn=["v1","v2","v3"],Un={zero:0,one:1,two:2,few:3,many:4,other:5};function Hn(){var e={};return Fn.forEach((function(t){t.lngs.forEach((function(n){e[n]={numbers:t.nr,plurals:qn[t.fc]}}))})),e}var Vn=function(){function e(t){var n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};Jt(this,e),this.languageUtils=t,this.options=n,this.logger=fn.create("pluralResolver"),this.options.compatibilityJSON&&"v4"!==this.options.compatibilityJSON||"undefined"!=typeof Intl&&Intl.PluralRules||(this.options.compatibilityJSON="v3",this.logger.error("Your environment seems not to be Intl API compatible, use an Intl.PluralRules polyfill. Will fallback to the compatibilityJSON v3 format handling.")),this.rules=Hn()}return en(e,[{key:"addRule",value:function(e,t){this.rules[e]=t}},{key:"getRule",value:function(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(this.shouldUseIntlApi())try{return new Intl.PluralRules(e,{type:t.ordinal?"ordinal":"cardinal"})}catch(e){return}return this.rules[e]||this.rules[this.languageUtils.getLanguagePartFromCode(e)]}},{key:"needsPlural",value:function(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},n=this.getRule(e,t);return this.shouldUseIntlApi()?n&&n.resolvedOptions().pluralCategories.length>1:n&&n.numbers.length>1}},{key:"getPluralFormsOfKey",value:function(e,t){var n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};return this.getSuffixes(e,n).map((function(e){return"".concat(t).concat(e)}))}},{key:"getSuffixes",value:function(e){var t=this,n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},r=this.getRule(e,n);return r?this.shouldUseIntlApi()?r.resolvedOptions().pluralCategories.sort((function(e,t){return Un[e]-Un[t]})).map((function(e){return"".concat(t.options.prepend).concat(e)})):r.numbers.map((function(r){return t.getSuffix(e,r,n)})):[]}},{key:"getSuffix",value:function(e,t){var n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},r=this.getRule(e,n);return r?this.shouldUseIntlApi()?"".concat(this.options.prepend).concat(r.select(t)):this.getSuffixRetroCompatible(r,t):(this.logger.warn("no plural rule found for: ".concat(e)),"")}},{key:"getSuffixRetroCompatible",value:function(e,t){var n=this,r=e.noAbs?e.plurals(t):e.plurals(Math.abs(t)),s=e.numbers[r];this.options.simplifyPluralSuffix&&2===e.numbers.length&&1===e.numbers[0]&&(2===s?s="plural":1===s&&(s=""));var l=function(){return n.options.prepend&&s.toString()?n.options.prepend+s.toString():s.toString()};return"v1"===this.options.compatibilityJSON?1===s?"":"number"==typeof s?"_plural_".concat(s.toString()):l():"v2"===this.options.compatibilityJSON||this.options.simplifyPluralSuffix&&2===e.numbers.length&&1===e.numbers[0]?l():this.options.prepend&&r.toString()?this.options.prepend+r.toString():r.toString()}},{key:"shouldUseIntlApi",value:function(){return!zn.includes(this.options.compatibilityJSON)}}]),e}();function Qn(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function $n(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?Qn(Object(n),!0).forEach((function(t){Ae(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):Qn(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}var Wn=function(){function e(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};Jt(this,e),this.logger=fn.create("interpolator"),this.options=t,this.format=t.interpolation&&t.interpolation.format||function(e){return e},this.init(t)}return en(e,[{key:"init",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};e.interpolation||(e.interpolation={escapeValue:!0});var t=e.interpolation;this.escape=void 0!==t.escape?t.escape:En,this.escapeValue=void 0===t.escapeValue||t.escapeValue,this.useRawValueToEscape=void 0!==t.useRawValueToEscape&&t.useRawValueToEscape,this.prefix=t.prefix?jn(t.prefix):t.prefixEscaped||"{{",this.suffix=t.suffix?jn(t.suffix):t.suffixEscaped||"}}",this.formatSeparator=t.formatSeparator?t.formatSeparator:t.formatSeparator||",",this.unescapePrefix=t.unescapeSuffix?"":t.unescapePrefix||"-",this.unescapeSuffix=this.unescapePrefix?"":t.unescapeSuffix||"",this.nestingPrefix=t.nestingPrefix?jn(t.nestingPrefix):t.nestingPrefixEscaped||jn("$t("),this.nestingSuffix=t.nestingSuffix?jn(t.nestingSuffix):t.nestingSuffixEscaped||jn(")"),this.nestingOptionsSeparator=t.nestingOptionsSeparator?t.nestingOptionsSeparator:t.nestingOptionsSeparator||",",this.maxReplaces=t.maxReplaces?t.maxReplaces:1e3,this.alwaysFormat=void 0!==t.alwaysFormat&&t.alwaysFormat,this.resetRegExp()}},{key:"reset",value:function(){this.options&&this.init(this.options)}},{key:"resetRegExp",value:function(){var e="".concat(this.prefix,"(.+?)").concat(this.suffix);this.regexp=new RegExp(e,"g");var t="".concat(this.prefix).concat(this.unescapePrefix,"(.+?)").concat(this.unescapeSuffix).concat(this.suffix);this.regexpUnescape=new RegExp(t,"g");var n="".concat(this.nestingPrefix,"(.+?)").concat(this.nestingSuffix);this.nestingRegexp=new RegExp(n,"g")}},{key:"interpolate",value:function(e,t,n,r){var s,l,o,a=this,i=this.options&&this.options.interpolation&&this.options.interpolation.defaultVariables||{};function p(e){return e.replace(/\$/g,"$$$$")}var u=function(e){if(e.indexOf(a.formatSeparator)<0){var s=kn(t,i,e);return a.alwaysFormat?a.format(s,void 0,n,$n($n($n({},r),t),{},{interpolationkey:e})):s}var l=e.split(a.formatSeparator),o=l.shift().trim(),p=l.join(a.formatSeparator).trim();return a.format(kn(t,i,o),p,n,$n($n($n({},r),t),{},{interpolationkey:o}))};this.resetRegExp();var c=r&&r.missingInterpolationHandler||this.options.missingInterpolationHandler,d=r&&r.interpolation&&void 0!==r.interpolation.skipOnVariables?r.interpolation.skipOnVariables:this.options.interpolation.skipOnVariables;return[{regex:this.regexpUnescape,safeValue:function(e){return p(e)}},{regex:this.regexp,safeValue:function(e){return a.escapeValue?p(a.escape(e)):p(e)}}].forEach((function(t){for(o=0;s=t.regex.exec(e);){var n=s[1].trim();if(void 0===(l=u(n)))if("function"==typeof c){var i=c(e,s,r);l="string"==typeof i?i:""}else if(r&&r.hasOwnProperty(n))l="";else{if(d){l=s[0];continue}a.logger.warn("missed to pass in variable ".concat(n," for interpolating ").concat(e)),l=""}else"string"==typeof l||a.useRawValueToEscape||(l=vn(l));var p=t.safeValue(l);if(e=e.replace(s[0],p),d?(t.regex.lastIndex+=p.length,t.regex.lastIndex-=s[0].length):t.regex.lastIndex=0,++o>=a.maxReplaces)break}})),e}},{key:"nest",value:function(e,t){var n,r,s=this,l=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},o=$n({},l);function a(e,t){var n=this.nestingOptionsSeparator;if(e.indexOf(n)<0)return e;var r=e.split(new RegExp("".concat(n,"[ ]*{"))),s="{".concat(r[1]);e=r[0],s=(s=this.interpolate(s,o)).replace(/'/g,'"');try{o=JSON.parse(s),t&&(o=$n($n({},t),o))}catch(t){return this.logger.warn("failed parsing options string in nesting for key ".concat(e),t),"".concat(e).concat(n).concat(s)}return delete o.defaultValue,e}for(o.applyPostProcessor=!1,delete o.defaultValue;n=this.nestingRegexp.exec(e);){var i=[],p=!1;if(-1!==n[0].indexOf(this.formatSeparator)&&!/{.*}/.test(n[1])){var u=n[1].split(this.formatSeparator).map((function(e){return e.trim()}));n[1]=u.shift(),i=u,p=!0}if((r=t(a.call(this,n[1].trim(),o),o))&&n[0]===e&&"string"!=typeof r)return r;"string"!=typeof r&&(r=vn(r)),r||(this.logger.warn("missed to resolve ".concat(n[1]," for nesting ").concat(e)),r=""),p&&(r=i.reduce((function(e,t){return s.format(e,t,l.lng,$n($n({},l),{},{interpolationkey:n[1].trim()}))}),r.trim())),e=e.replace(n[0],r),this.regexp.lastIndex=0}return e}}]),e}();function Xn(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function Kn(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?Xn(Object(n),!0).forEach((function(t){Ae(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):Xn(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}var Yn=function(){function e(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};Jt(this,e),this.logger=fn.create("formatter"),this.options=t,this.formats={number:function(e,t,n){return new Intl.NumberFormat(t,n).format(e)},currency:function(e,t,n){return new Intl.NumberFormat(t,Kn(Kn({},n),{},{style:"currency"})).format(e)},datetime:function(e,t,n){return new Intl.DateTimeFormat(t,Kn({},n)).format(e)},relativetime:function(e,t,n){return new Intl.RelativeTimeFormat(t,Kn({},n)).format(e,n.range||"day")},list:function(e,t,n){return new Intl.ListFormat(t,Kn({},n)).format(e)}},this.init(t)}return en(e,[{key:"init",value:function(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{interpolation:{}},n=t.interpolation;this.formatSeparator=n.formatSeparator?n.formatSeparator:n.formatSeparator||","}},{key:"add",value:function(e,t){this.formats[e.toLowerCase().trim()]=t}},{key:"format",value:function(e,t,n,r){var s=this,l=t.split(this.formatSeparator).reduce((function(e,t){var l=function(e){var t=e.toLowerCase().trim(),n={};if(e.indexOf("(")>-1){var r=e.split("(");t=r[0].toLowerCase().trim();var s=r[1].substring(0,r[1].length-1);"currency"===t&&s.indexOf(":")<0?n.currency||(n.currency=s.trim()):"relativetime"===t&&s.indexOf(":")<0?n.range||(n.range=s.trim()):s.split(";").forEach((function(e){if(e){var t=function(e){return ln(e)||function(e){if("undefined"!=typeof Symbol&&null!=e[Symbol.iterator]||null!=e["@@iterator"])return Array.from(e)}(e)||an(e)||pn()}(e.split(":")),r=t[0],s=t.slice(1).join(":");"false"===s.trim()&&(n[r.trim()]=!1),"true"===s.trim()&&(n[r.trim()]=!0),isNaN(s.trim())||(n[r.trim()]=parseInt(s.trim(),10)),n[r.trim()]||(n[r.trim()]=s.trim())}}))}return{formatName:t,formatOptions:n}}(t),o=l.formatName,a=l.formatOptions;if(s.formats[o]){var i=e;try{var p=r&&r.formatParams&&r.formatParams[r.interpolationkey]||{},u=p.locale||p.lng||r.locale||r.lng||n;i=s.formats[o](e,u,Kn(Kn(Kn({},a),r),p))}catch(e){s.logger.warn(e)}return i}return s.logger.warn("there was no format function for ".concat(o)),e}),e);return l}}]),e}();function Gn(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function Jn(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?Gn(Object(n),!0).forEach((function(t){Ae(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):Gn(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}var Zn=function(e){nn(s,e);var t,n,r=(t=s,n=function(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(e){return!1}}(),function(){var e,r=sn(t);if(n){var s=sn(this).constructor;e=Reflect.construct(r,arguments,s)}else e=r.apply(this,arguments);return rn(this,e)});function s(e,t,n){var l,o=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};return Jt(this,s),l=r.call(this),On&&gn.call(tn(l)),l.backend=e,l.store=t,l.services=n,l.languageUtils=n.languageUtils,l.options=o,l.logger=fn.create("backendConnector"),l.state={},l.queue=[],l.backend&&l.backend.init&&l.backend.init(n,o.backend,o),l}return en(s,[{key:"queueLoad",value:function(e,t,n,r){var s=this,l=[],o=[],a=[],i=[];return e.forEach((function(e){var r=!0;t.forEach((function(t){var a="".concat(e,"|").concat(t);!n.reload&&s.store.hasResourceBundle(e,t)?s.state[a]=2:s.state[a]<0||(1===s.state[a]?o.indexOf(a)<0&&o.push(a):(s.state[a]=1,r=!1,o.indexOf(a)<0&&o.push(a),l.indexOf(a)<0&&l.push(a),i.indexOf(t)<0&&i.push(t)))})),r||a.push(e)})),(l.length||o.length)&&this.queue.push({pending:o,loaded:{},errors:[],callback:r}),{toLoad:l,pending:o,toLoadLanguages:a,toLoadNamespaces:i}}},{key:"loaded",value:function(e,t,n){var r=e.split("|"),s=r[0],l=r[1];t&&this.emit("failedLoading",s,l,t),n&&this.store.addResourceBundle(s,l,n),this.state[e]=t?-1:2;var o={};this.queue.forEach((function(n){!function(e,t,n,r){var s=yn(e,t,Object),l=s.obj,o=s.k;l[o]=l[o]||[],l[o].push(n)}(n.loaded,[s],l),function(e,t){for(var n=e.indexOf(t);-1!==n;)e.splice(n,1),n=e.indexOf(t)}(n.pending,e),t&&n.errors.push(t),0!==n.pending.length||n.done||(Object.keys(n.loaded).forEach((function(e){o[e]||(o[e]=[]),n.loaded[e].length&&n.loaded[e].forEach((function(t){o[e].indexOf(t)<0&&o[e].push(t)}))})),n.done=!0,n.errors.length?n.callback(n.errors):n.callback())})),this.emit("loaded",o),this.queue=this.queue.filter((function(e){return!e.done}))}},{key:"read",value:function(e,t,n){var r=this,s=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0,l=arguments.length>4&&void 0!==arguments[4]?arguments[4]:350,o=arguments.length>5?arguments[5]:void 0;return e.length?this.backend[n](e,t,(function(a,i){a&&i&&s<5?setTimeout((function(){r.read.call(r,e,t,n,s+1,2*l,o)}),l):o(a,i)})):o(null,{})}},{key:"prepareLoading",value:function(e,t){var n=this,r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},s=arguments.length>3?arguments[3]:void 0;if(!this.backend)return this.logger.warn("No backend was added via i18next.use. Will not load resources."),s&&s();"string"==typeof e&&(e=this.languageUtils.toResolveHierarchy(e)),"string"==typeof t&&(t=[t]);var l=this.queueLoad(e,t,r,s);if(!l.toLoad.length)return l.pending.length||s(),null;l.toLoad.forEach((function(e){n.loadOne(e)}))}},{key:"load",value:function(e,t,n){this.prepareLoading(e,t,{},n)}},{key:"reload",value:function(e,t,n){this.prepareLoading(e,t,{reload:!0},n)}},{key:"loadOne",value:function(e){var t=this,n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"",r=e.split("|"),s=r[0],l=r[1];this.read(s,l,"read",void 0,void 0,(function(r,o){r&&t.logger.warn("".concat(n,"loading namespace ").concat(l," for language ").concat(s," failed"),r),!r&&o&&t.logger.log("".concat(n,"loaded namespace ").concat(l," for language ").concat(s),o),t.loaded(e,r,o)}))}},{key:"saveMissing",value:function(e,t,n,r,s){var l=arguments.length>5&&void 0!==arguments[5]?arguments[5]:{};this.services.utils&&this.services.utils.hasLoadedNamespace&&!this.services.utils.hasLoadedNamespace(t)?this.logger.warn('did not save key "'.concat(n,'" as the namespace "').concat(t,'" was not yet loaded'),"This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!"):null!=n&&""!==n&&(this.backend&&this.backend.create&&this.backend.create(e,t,n,r,null,Jn(Jn({},l),{},{isUpdate:s})),e&&e[0]&&this.store.addResource(e[0],t,n,r))}}]),s}(gn);function er(){return{debug:!1,initImmediate:!0,ns:["translation"],defaultNS:["translation"],fallbackLng:["dev"],fallbackNS:!1,supportedLngs:!1,nonExplicitSupportedLngs:!1,load:"all",preload:!1,simplifyPluralSuffix:!0,keySeparator:".",nsSeparator:":",pluralSeparator:"_",contextSeparator:"_",partialBundledLanguages:!1,saveMissing:!1,updateMissing:!1,saveMissingTo:"fallback",saveMissingPlurals:!0,missingKeyHandler:!1,missingInterpolationHandler:!1,postProcess:!1,postProcessPassResolved:!1,returnNull:!0,returnEmptyString:!0,returnObjects:!1,joinArrays:!1,returnedObjectHandler:!1,parseMissingKeyHandler:!1,appendNamespaceToMissingKey:!1,appendNamespaceToCIMode:!1,overloadTranslationOptionHandler:function(e){var t={};if("object"===Gt(e[1])&&(t=e[1]),"string"==typeof e[1]&&(t.defaultValue=e[1]),"string"==typeof e[2]&&(t.tDescription=e[2]),"object"===Gt(e[2])||"object"===Gt(e[3])){var n=e[3]||e[2];Object.keys(n).forEach((function(e){t[e]=n[e]}))}return t},interpolation:{escapeValue:!0,format:function(e,t,n,r){return e},prefix:"{{",suffix:"}}",formatSeparator:",",unescapePrefix:"-",nestingPrefix:"$t(",nestingSuffix:")",nestingOptionsSeparator:",",maxReplaces:1e3,skipOnVariables:!0}}}function tr(e){return"string"==typeof e.ns&&(e.ns=[e.ns]),"string"==typeof e.fallbackLng&&(e.fallbackLng=[e.fallbackLng]),"string"==typeof e.fallbackNS&&(e.fallbackNS=[e.fallbackNS]),e.supportedLngs&&e.supportedLngs.indexOf("cimode")<0&&(e.supportedLngs=e.supportedLngs.concat(["cimode"])),e}function nr(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function rr(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?nr(Object(n),!0).forEach((function(t){Ae(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):nr(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function sr(){}function lr(e){Object.getOwnPropertyNames(Object.getPrototypeOf(e)).forEach((function(t){"function"==typeof e[t]&&(e[t]=e[t].bind(e))}))}var or=function(e){nn(s,e);var t,n,r=(t=s,n=function(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(e){return!1}}(),function(){var e,r=sn(t);if(n){var s=sn(this).constructor;e=Reflect.construct(r,arguments,s)}else e=r.apply(this,arguments);return rn(this,e)});function s(){var e,t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},n=arguments.length>1?arguments[1]:void 0;if(Jt(this,s),e=r.call(this),On&&gn.call(tn(e)),e.options=tr(t),e.services={},e.logger=fn,e.modules={external:[]},lr(tn(e)),n&&!e.isInitialized&&!t.isClone){if(!e.options.initImmediate)return e.init(t,n),rn(e,tn(e));setTimeout((function(){e.init(t,n)}),0)}return e}return en(s,[{key:"init",value:function(){var e=this,t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},n=arguments.length>1?arguments[1]:void 0;"function"==typeof t&&(n=t,t={}),!t.defaultNS&&t.ns&&("string"==typeof t.ns?t.defaultNS=t.ns:t.ns.indexOf("translation")<0&&(t.defaultNS=t.ns[0]));var r=er();function s(e){return e?"function"==typeof e?new e:e:null}if(this.options=rr(rr(rr({},r),this.options),tr(t)),"v1"!==this.options.compatibilityAPI&&(this.options.interpolation=rr(rr({},r.interpolation),this.options.interpolation)),void 0!==t.keySeparator&&(this.options.userDefinedKeySeparator=t.keySeparator),void 0!==t.nsSeparator&&(this.options.userDefinedNsSeparator=t.nsSeparator),!this.options.isClone){var l;this.modules.logger?fn.init(s(this.modules.logger),this.options):fn.init(null,this.options),this.modules.formatter?l=this.modules.formatter:"undefined"!=typeof Intl&&(l=Yn);var o=new Mn(this.options);this.store=new Ln(this.options.resources,this.options);var a=this.services;a.logger=fn,a.resourceStore=this.store,a.languageUtils=o,a.pluralResolver=new Vn(o,{prepend:this.options.pluralSeparator,compatibilityJSON:this.options.compatibilityJSON,simplifyPluralSuffix:this.options.simplifyPluralSuffix}),!l||this.options.interpolation.format&&this.options.interpolation.format!==r.interpolation.format||(a.formatter=s(l),a.formatter.init(a,this.options),this.options.interpolation.format=a.formatter.format.bind(a.formatter)),a.interpolator=new Wn(this.options),a.utils={hasLoadedNamespace:this.hasLoadedNamespace.bind(this)},a.backendConnector=new Zn(s(this.modules.backend),a.resourceStore,a,this.options),a.backendConnector.on("*",(function(t){for(var n=arguments.length,r=new Array(n>1?n-1:0),s=1;s<n;s++)r[s-1]=arguments[s];e.emit.apply(e,[t].concat(r))})),this.modules.languageDetector&&(a.languageDetector=s(this.modules.languageDetector),a.languageDetector.init(a,this.options.detection,this.options)),this.modules.i18nFormat&&(a.i18nFormat=s(this.modules.i18nFormat),a.i18nFormat.init&&a.i18nFormat.init(this)),this.translator=new In(this.services,this.options),this.translator.on("*",(function(t){for(var n=arguments.length,r=new Array(n>1?n-1:0),s=1;s<n;s++)r[s-1]=arguments[s];e.emit.apply(e,[t].concat(r))})),this.modules.external.forEach((function(t){t.init&&t.init(e)}))}if(this.format=this.options.interpolation.format,n||(n=sr),this.options.fallbackLng&&!this.services.languageDetector&&!this.options.lng){var i=this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);i.length>0&&"dev"!==i[0]&&(this.options.lng=i[0])}this.services.languageDetector||this.options.lng||this.logger.warn("init: no languageDetector is used and no lng is defined");var p=["getResource","hasResourceBundle","getResourceBundle","getDataByLanguage"];p.forEach((function(t){e[t]=function(){var n;return(n=e.store)[t].apply(n,arguments)}}));var u=["addResource","addResources","addResourceBundle","removeResourceBundle"];u.forEach((function(t){e[t]=function(){var n;return(n=e.store)[t].apply(n,arguments),e}}));var c=hn(),d=function(){var t=function(t,r){e.isInitialized&&!e.initializedStoreOnce&&e.logger.warn("init: i18next is already initialized. You should call init just once!"),e.isInitialized=!0,e.options.isClone||e.logger.log("initialized",e.options),e.emit("initialized",e.options),c.resolve(r),n(t,r)};if(e.languages&&"v1"!==e.options.compatibilityAPI&&!e.isInitialized)return t(null,e.t.bind(e));e.changeLanguage(e.options.lng,t)};return this.options.resources||!this.options.initImmediate?d():setTimeout(d,0),c}},{key:"loadResources",value:function(e){var t=this,n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:sr,r=n,s="string"==typeof e?e:this.language;if("function"==typeof e&&(r=e),!this.options.resources||this.options.partialBundledLanguages){if(s&&"cimode"===s.toLowerCase())return r();var l=[],o=function(e){e&&t.services.languageUtils.toResolveHierarchy(e).forEach((function(e){l.indexOf(e)<0&&l.push(e)}))};if(s)o(s);else{var a=this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);a.forEach((function(e){return o(e)}))}this.options.preload&&this.options.preload.forEach((function(e){return o(e)})),this.services.backendConnector.load(l,this.options.ns,r)}else r(null)}},{key:"reloadResources",value:function(e,t,n){var r=hn();return e||(e=this.languages),t||(t=this.options.ns),n||(n=sr),this.services.backendConnector.reload(e,t,(function(e){r.resolve(),n(e)})),r}},{key:"use",value:function(e){if(!e)throw new Error("You are passing an undefined module! Please check the object you are passing to i18next.use()");if(!e.type)throw new Error("You are passing a wrong module! Please check the object you are passing to i18next.use()");return"backend"===e.type&&(this.modules.backend=e),("logger"===e.type||e.log&&e.warn&&e.error)&&(this.modules.logger=e),"languageDetector"===e.type&&(this.modules.languageDetector=e),"i18nFormat"===e.type&&(this.modules.i18nFormat=e),"postProcessor"===e.type&&Nn.addPostProcessor(e),"formatter"===e.type&&(this.modules.formatter=e),"3rdParty"===e.type&&this.modules.external.push(e),this}},{key:"changeLanguage",value:function(e,t){var n=this;this.isLanguageChangingTo=e;var r=hn();this.emit("languageChanging",e);var s=function(e){if(n.language=e,n.languages=n.services.languageUtils.toResolveHierarchy(e),n.resolvedLanguage=void 0,!(["cimode","dev"].indexOf(e)>-1))for(var t=0;t<n.languages.length;t++){var r=n.languages[t];if(!(["cimode","dev"].indexOf(r)>-1)&&n.store.hasLanguageSomeTranslations(r)){n.resolvedLanguage=r;break}}},l=function(l){e||l||!n.services.languageDetector||(l=[]);var o="string"==typeof l?l:n.services.languageUtils.getBestMatchFromCodes(l);o&&(n.language||s(o),n.translator.language||n.translator.changeLanguage(o),n.services.languageDetector&&n.services.languageDetector.cacheUserLanguage(o)),n.loadResources(o,(function(e){!function(e,l){l?(s(l),n.translator.changeLanguage(l),n.isLanguageChangingTo=void 0,n.emit("languageChanged",l),n.logger.log("languageChanged",l)):n.isLanguageChangingTo=void 0,r.resolve((function(){return n.t.apply(n,arguments)})),t&&t(e,(function(){return n.t.apply(n,arguments)}))}(e,o)}))};return e||!this.services.languageDetector||this.services.languageDetector.async?!e&&this.services.languageDetector&&this.services.languageDetector.async?this.services.languageDetector.detect(l):l(e):l(this.services.languageDetector.detect()),r}},{key:"getFixedT",value:function(e,t,n){var r=this,s=function e(t,s){var l;if("object"!==Gt(s)){for(var o=arguments.length,a=new Array(o>2?o-2:0),i=2;i<o;i++)a[i-2]=arguments[i];l=r.options.overloadTranslationOptionHandler([t,s].concat(a))}else l=rr({},s);l.lng=l.lng||e.lng,l.lngs=l.lngs||e.lngs,l.ns=l.ns||e.ns;var p=r.options.keySeparator||".",u=n?"".concat(n).concat(p).concat(t):t;return r.t(u,l)};return"string"==typeof e?s.lng=e:s.lngs=e,s.ns=t,s.keyPrefix=n,s}},{key:"t",value:function(){var e;return this.translator&&(e=this.translator).translate.apply(e,arguments)}},{key:"exists",value:function(){var e;return this.translator&&(e=this.translator).exists.apply(e,arguments)}},{key:"setDefaultNamespace",value:function(e){this.options.defaultNS=e}},{key:"hasLoadedNamespace",value:function(e){var t=this,n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(!this.isInitialized)return this.logger.warn("hasLoadedNamespace: i18next was not initialized",this.languages),!1;if(!this.languages||!this.languages.length)return this.logger.warn("hasLoadedNamespace: i18n.languages were undefined or empty",this.languages),!1;var r=this.resolvedLanguage||this.languages[0],s=!!this.options&&this.options.fallbackLng,l=this.languages[this.languages.length-1];if("cimode"===r.toLowerCase())return!0;var o=function(e,n){var r=t.services.backendConnector.state["".concat(e,"|").concat(n)];return-1===r||2===r};if(n.precheck){var a=n.precheck(this,o);if(void 0!==a)return a}return!!this.hasResourceBundle(r,e)||!this.services.backendConnector.backend||!(!o(r,e)||s&&!o(l,e))}},{key:"loadNamespaces",value:function(e,t){var n=this,r=hn();return this.options.ns?("string"==typeof e&&(e=[e]),e.forEach((function(e){n.options.ns.indexOf(e)<0&&n.options.ns.push(e)})),this.loadResources((function(e){r.resolve(),t&&t(e)})),r):(t&&t(),Promise.resolve())}},{key:"loadLanguages",value:function(e,t){var n=hn();"string"==typeof e&&(e=[e]);var r=this.options.preload||[],s=e.filter((function(e){return r.indexOf(e)<0}));return s.length?(this.options.preload=r.concat(s),this.loadResources((function(e){n.resolve(),t&&t(e)})),n):(t&&t(),Promise.resolve())}},{key:"dir",value:function(e){return e||(e=this.resolvedLanguage||(this.languages&&this.languages.length>0?this.languages[0]:this.language)),e?["ar","shu","sqr","ssh","xaa","yhd","yud","aao","abh","abv","acm","acq","acw","acx","acy","adf","ads","aeb","aec","afb","ajp","apc","apd","arb","arq","ars","ary","arz","auz","avl","ayh","ayl","ayn","ayp","bbz","pga","he","iw","ps","pbt","pbu","pst","prp","prd","ug","ur","ydd","yds","yih","ji","yi","hbo","men","xmn","fa","jpr","peo","pes","prs","dv","sam","ckb"].indexOf(this.services.languageUtils.getLanguagePartFromCode(e))>-1||e.toLowerCase().indexOf("-arab")>1?"rtl":"ltr":"rtl"}},{key:"cloneInstance",value:function(){var e=this,t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:sr,r=rr(rr(rr({},this.options),t),{isClone:!0}),l=new s(r),o=["store","services","language"];return o.forEach((function(t){l[t]=e[t]})),l.services=rr({},this.services),l.services.utils={hasLoadedNamespace:l.hasLoadedNamespace.bind(l)},l.translator=new In(l.services,l.options),l.translator.on("*",(function(e){for(var t=arguments.length,n=new Array(t>1?t-1:0),r=1;r<t;r++)n[r-1]=arguments[r];l.emit.apply(l,[e].concat(n))})),l.init(r,n),l.translator.options=l.options,l.translator.backendConnector.services.utils={hasLoadedNamespace:l.hasLoadedNamespace.bind(l)},l}},{key:"toJSON",value:function(){return{options:this.options,store:this.store,language:this.language,languages:this.languages,resolvedLanguage:this.resolvedLanguage}}}]),s}(gn);Ae(or,"createInstance",(function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t=arguments.length>1?arguments[1]:void 0;return new or(e,t)}));var ar=or.createInstance();ar.createInstance=or.createInstance,ar.createInstance,ar.init,ar.loadResources,ar.reloadResources,ar.use,ar.changeLanguage,ar.getFixedT,ar.t,ar.exists,ar.setDefaultNamespace,ar.hasLoadedNamespace,ar.loadNamespaces,ar.loadLanguages;const ir=ar;function pr(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function ur(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?pr(Object(n),!0).forEach((function(t){Ae(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):pr(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}var cr,dr={bindI18n:"languageChanged",bindI18nStore:"",transEmptyNodeValue:"",transSupportBasicHtmlNodes:!0,transWrapTextNodes:"",transKeepBasicHtmlNodesFor:["br","strong","i","p"],useSuspense:!0},fr=r.createContext();function gr(){return dr}var hr=function(){function e(){Jt(this,e),this.usedNamespaces={}}return en(e,[{key:"addUsedNamespaces",value:function(e){var t=this;e.forEach((function(e){t.usedNamespaces[e]||(t.usedNamespaces[e]=!0)}))}},{key:"getUsedNamespaces",value:function(){return Object.keys(this.usedNamespaces)}}]),e}();function vr(){return cr}var mr={type:"3rdParty",init:function(e){!function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};dr=ur(ur({},dr),e)}(e.options.react),function(e){cr=e}(e)}};function yr(e){return yr="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},yr(e)}var br=[],wr=br.forEach,kr=br.slice;function xr(e){return wr.call(kr.call(arguments,1),(function(t){if(t)for(var n in t)void 0===e[n]&&(e[n]=t[n])})),e}function jr(){return"function"==typeof XMLHttpRequest||"object"===("undefined"==typeof XMLHttpRequest?"undefined":yr(XMLHttpRequest))}var Sr,Er,Or,Cr=s(154),Pr=s.t(Cr,2);function Ar(e){return Ar="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},Ar(e)}"function"==typeof fetch&&("undefined"!=typeof global&&global.fetch?Sr=global.fetch:"undefined"!=typeof window&&window.fetch&&(Sr=window.fetch)),jr&&("undefined"!=typeof global&&global.XMLHttpRequest?Er=global.XMLHttpRequest:"undefined"!=typeof window&&window.XMLHttpRequest&&(Er=window.XMLHttpRequest)),"function"==typeof ActiveXObject&&("undefined"!=typeof global&&global.ActiveXObject?Or=global.ActiveXObject:"undefined"!=typeof window&&window.ActiveXObject&&(Or=window.ActiveXObject)),Sr||!Pr||Er||Or||(Sr=Cr||Pr),"function"!=typeof Sr&&(Sr=void 0);var _r=function(e,t){if(t&&"object"===Ar(t)){var n="";for(var r in t)n+="&"+encodeURIComponent(r)+"="+encodeURIComponent(t[r]);if(!n)return e;e=e+(-1!==e.indexOf("?")?"&":"?")+n.slice(1)}return e};const Lr=function(e,t,n,r){return"function"==typeof n&&(r=n,n=void 0),r=r||function(){},Sr?function(e,t,n,r){e.queryStringParams&&(t=_r(t,e.queryStringParams));var s=xr({},"function"==typeof e.customHeaders?e.customHeaders():e.customHeaders);n&&(s["Content-Type"]="application/json"),Sr(t,xr({method:n?"POST":"GET",body:n?e.stringify(n):void 0,headers:s},"function"==typeof e.requestOptions?e.requestOptions(n):e.requestOptions)).then((function(e){if(!e.ok)return r(e.statusText||"Error",{status:e.status});e.text().then((function(t){r(null,{status:e.status,data:t})})).catch(r)})).catch(r)}(e,t,n,r):jr||"function"==typeof ActiveXObject?function(e,t,n,r){n&&"object"===Ar(n)&&(n=_r("",n).slice(1)),e.queryStringParams&&(t=_r(t,e.queryStringParams));try{var s;(s=Er?new Er:new Or("MSXML2.XMLHTTP.3.0")).open(n?"POST":"GET",t,1),e.crossDomain||s.setRequestHeader("X-Requested-With","XMLHttpRequest"),s.withCredentials=!!e.withCredentials,n&&s.setRequestHeader("Content-Type","application/x-www-form-urlencoded"),s.overrideMimeType&&s.overrideMimeType("application/json");var l=e.customHeaders;if(l="function"==typeof l?l():l)for(var o in l)s.setRequestHeader(o,l[o]);s.onreadystatechange=function(){s.readyState>3&&r(s.status>=400?s.statusText:null,{status:s.status,data:s.responseText})},s.send(n)}catch(e){console&&console.log(e)}}(e,t,n,r):void 0};function Nr(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function Tr(e,t){for(var n=0;n<t.length;n++){var r=t[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r)}}var Rr=function(){return{loadPath:"/locales/{{lng}}/{{ns}}.json",addPath:"/locales/add/{{lng}}/{{ns}}",allowMultiLoading:!1,parse:function(e){return JSON.parse(e)},stringify:JSON.stringify,parsePayload:function(e,t,n){return function(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}({},t,n||"")},request:Lr,reloadInterval:"undefined"==typeof window&&36e5,customHeaders:{},queryStringParams:{},crossDomain:!1,withCredentials:!1,overrideMimeType:!1,requestOptions:{mode:"cors",credentials:"same-origin",cache:"default"}}},Dr=function(){function e(t){var n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Nr(this,e),this.services=t,this.options=n,this.allOptions=r,this.type="backend",this.init(t,n,r)}var t,n;return t=e,n=[{key:"init",value:function(e){var t=this,n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};this.services=e,this.options=xr(n,this.options||{},Rr()),this.allOptions=r,this.services&&this.options.reloadInterval&&setInterval((function(){return t.reload()}),this.options.reloadInterval)}},{key:"readMulti",value:function(e,t,n){this._readAny(e,e,t,t,n)}},{key:"read",value:function(e,t,n){this._readAny([e],e,[t],t,n)}},{key:"_readAny",value:function(e,t,n,r,s){var l,o=this,a=this.options.loadPath;"function"==typeof this.options.loadPath&&(a=this.options.loadPath(e,n)),(a=function(e){return!!e&&"function"==typeof e.then}(l=a)?l:Promise.resolve(l)).then((function(l){var a=o.services.interpolator.interpolate(l,{lng:e.join("+"),ns:n.join("+")});o.loadUrl(a,s,t,r)}))}},{key:"loadUrl",value:function(e,t,n,r){var s=this;this.options.request(this.options,e,void 0,(function(l,o){if(o&&(o.status>=500&&o.status<600||!o.status))return t("failed loading "+e+"; status code: "+o.status,!0);if(o&&o.status>=400&&o.status<500)return t("failed loading "+e+"; status code: "+o.status,!1);if(!o&&l&&l.message&&l.message.indexOf("Failed to fetch")>-1)return t("failed loading "+e+": "+l.message,!0);if(l)return t(l,!1);var a,i;try{a="string"==typeof o.data?s.options.parse(o.data,n,r):o.data}catch(t){i="failed parsing "+e+" to json"}if(i)return t(i,!1);t(null,a)}))}},{key:"create",value:function(e,t,n,r,s){var l=this;if(this.options.addPath){"string"==typeof e&&(e=[e]);var o=this.options.parsePayload(t,n,r),a=0,i=[],p=[];e.forEach((function(n){var r=l.options.addPath;"function"==typeof l.options.addPath&&(r=l.options.addPath(n,t));var u=l.services.interpolator.interpolate(r,{lng:n,ns:t});l.options.request(l.options,u,o,(function(t,n){a+=1,i.push(t),p.push(n),a===e.length&&s&&s(i,p)}))}))}}},{key:"reload",value:function(){var e=this,t=this.services,n=t.backendConnector,r=t.languageUtils,s=t.logger,l=n.language;if(!l||"cimode"!==l.toLowerCase()){var o=[],a=function(e){r.toResolveHierarchy(e).forEach((function(e){o.indexOf(e)<0&&o.push(e)}))};a(l),this.allOptions.preload&&this.allOptions.preload.forEach((function(e){return a(e)})),o.forEach((function(t){e.allOptions.ns.forEach((function(e){n.read(t,e,"read",null,null,(function(r,l){r&&s.warn("loading namespace ".concat(e," for language ").concat(t," failed"),r),!r&&l&&s.log("loaded namespace ".concat(e," for language ").concat(t),l),n.loaded("".concat(t,"|").concat(e),r,l)}))}))}))}}}],n&&Tr(t.prototype,n),Object.defineProperty(t,"prototype",{writable:!1}),e}();Dr.type="backend";const Ir=Dr;var Br=[],Mr=Br.forEach,Fr=Br.slice;function qr(e){return Mr.call(Fr.call(arguments,1),(function(t){if(t)for(var n in t)void 0===e[n]&&(e[n]=t[n])})),e}var zr=/^[\u0009\u0020-\u007e\u0080-\u00ff]+$/,Ur=function(e,t,n){var r=n||{};r.path=r.path||"/";var s=e+"="+encodeURIComponent(t);if(r.maxAge>0){var l=r.maxAge-0;if(isNaN(l))throw new Error("maxAge should be a Number");s+="; Max-Age="+Math.floor(l)}if(r.domain){if(!zr.test(r.domain))throw new TypeError("option domain is invalid");s+="; Domain="+r.domain}if(r.path){if(!zr.test(r.path))throw new TypeError("option path is invalid");s+="; Path="+r.path}if(r.expires){if("function"!=typeof r.expires.toUTCString)throw new TypeError("option expires is invalid");s+="; Expires="+r.expires.toUTCString()}if(r.httpOnly&&(s+="; HttpOnly"),r.secure&&(s+="; Secure"),r.sameSite)switch("string"==typeof r.sameSite?r.sameSite.toLowerCase():r.sameSite){case!0:s+="; SameSite=Strict";break;case"lax":s+="; SameSite=Lax";break;case"strict":s+="; SameSite=Strict";break;case"none":s+="; SameSite=None";break;default:throw new TypeError("option sameSite is invalid")}return s},Hr={name:"cookie",lookup:function(e){var t;if(e.lookupCookie&&"undefined"!=typeof document){var n=function(e){for(var t=e+"=",n=document.cookie.split(";"),r=0;r<n.length;r++){for(var s=n[r];" "===s.charAt(0);)s=s.substring(1,s.length);if(0===s.indexOf(t))return s.substring(t.length,s.length)}return null}(e.lookupCookie);n&&(t=n)}return t},cacheUserLanguage:function(e,t){t.lookupCookie&&"undefined"!=typeof document&&function(e,t,n,r){var s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:{path:"/",sameSite:"strict"};n&&(s.expires=new Date,s.expires.setTime(s.expires.getTime()+60*n*1e3)),r&&(s.domain=r),document.cookie=Ur(e,encodeURIComponent(t),s)}(t.lookupCookie,e,t.cookieMinutes,t.cookieDomain,t.cookieOptions)}},Vr={name:"querystring",lookup:function(e){var t;if("undefined"!=typeof window)for(var n=window.location.search.substring(1).split("&"),r=0;r<n.length;r++){var s=n[r].indexOf("=");s>0&&n[r].substring(0,s)===e.lookupQuerystring&&(t=n[r].substring(s+1))}return t}},Qr=null,$r=function(){if(null!==Qr)return Qr;try{Qr="undefined"!==window&&null!==window.localStorage;var e="i18next.translate.boo";window.localStorage.setItem(e,"foo"),window.localStorage.removeItem(e)}catch(e){Qr=!1}return Qr},Wr={name:"localStorage",lookup:function(e){var t;if(e.lookupLocalStorage&&$r()){var n=window.localStorage.getItem(e.lookupLocalStorage);n&&(t=n)}return t},cacheUserLanguage:function(e,t){t.lookupLocalStorage&&$r()&&window.localStorage.setItem(t.lookupLocalStorage,e)}},Xr=null,Kr=function(){if(null!==Xr)return Xr;try{Xr="undefined"!==window&&null!==window.sessionStorage;var e="i18next.translate.boo";window.sessionStorage.setItem(e,"foo"),window.sessionStorage.removeItem(e)}catch(e){Xr=!1}return Xr},Yr={name:"sessionStorage",lookup:function(e){var t;if(e.lookupSessionStorage&&Kr()){var n=window.sessionStorage.getItem(e.lookupSessionStorage);n&&(t=n)}return t},cacheUserLanguage:function(e,t){t.lookupSessionStorage&&Kr()&&window.sessionStorage.setItem(t.lookupSessionStorage,e)}},Gr={name:"navigator",lookup:function(e){var t=[];if("undefined"!=typeof navigator){if(navigator.languages)for(var n=0;n<navigator.languages.length;n++)t.push(navigator.languages[n]);navigator.userLanguage&&t.push(navigator.userLanguage),navigator.language&&t.push(navigator.language)}return t.length>0?t:void 0}},Jr={name:"htmlTag",lookup:function(e){var t,n=e.htmlTag||("undefined"!=typeof document?document.documentElement:null);return n&&"function"==typeof n.getAttribute&&(t=n.getAttribute("lang")),t}},Zr={name:"path",lookup:function(e){var t;if("undefined"!=typeof window){var n=window.location.pathname.match(/\/([a-zA-Z-]*)/g);if(n instanceof Array)if("number"==typeof e.lookupFromPathIndex){if("string"!=typeof n[e.lookupFromPathIndex])return;t=n[e.lookupFromPathIndex].replace("/","")}else t=n[0].replace("/","")}return t}},es={name:"subdomain",lookup:function(e){var t;if("undefined"!=typeof window){var n=window.location.href.match(/(?:http[s]*\:\/\/)*(.*?)\.(?=[^\/]*\..{2,5})/gi);n instanceof Array&&(t="number"==typeof e.lookupFromSubdomainIndex?n[e.lookupFromSubdomainIndex].replace("http://","").replace("https://","").replace(".",""):n[0].replace("http://","").replace("https://","").replace(".",""))}return t}},ts=function(){function e(t){var n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};Jt(this,e),this.type="languageDetector",this.detectors={},this.init(t,n)}return en(e,[{key:"init",value:function(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};this.services=e,this.options=qr(t,this.options||{},{order:["querystring","cookie","localStorage","sessionStorage","navigator","htmlTag"],lookupQuerystring:"lng",lookupCookie:"i18next",lookupLocalStorage:"i18nextLng",lookupSessionStorage:"i18nextLng",caches:["localStorage"],excludeCacheFor:["cimode"]}),this.options.lookupFromUrlIndex&&(this.options.lookupFromPathIndex=this.options.lookupFromUrlIndex),this.i18nOptions=n,this.addDetector(Hr),this.addDetector(Vr),this.addDetector(Wr),this.addDetector(Yr),this.addDetector(Gr),this.addDetector(Jr),this.addDetector(Zr),this.addDetector(es)}},{key:"addDetector",value:function(e){this.detectors[e.name]=e}},{key:"detect",value:function(e){var t=this;e||(e=this.options.order);var n=[];return e.forEach((function(e){if(t.detectors[e]){var r=t.detectors[e].lookup(t.options);r&&"string"==typeof r&&(r=[r]),r&&(n=n.concat(r))}})),this.services.languageUtils.getBestMatchFromCodes?n:n.length>0?n[0]:null}},{key:"cacheUserLanguage",value:function(e,t){var n=this;t||(t=this.options.caches),t&&(this.options.excludeCacheFor&&this.options.excludeCacheFor.indexOf(e)>-1||t.forEach((function(t){n.detectors[t]&&n.detectors[t].cacheUserLanguage(e,n.options)})))}}]),e}();function ns(e,t){return ln(e)||function(e,t){var n=null==e?null:"undefined"!=typeof Symbol&&e[Symbol.iterator]||e["@@iterator"];if(null!=n){var r,s,l=[],o=!0,a=!1;try{for(n=n.call(e);!(o=(r=n.next()).done)&&(l.push(r.value),!t||l.length!==t);o=!0);}catch(e){a=!0,s=e}finally{try{o||null==n.return||n.return()}finally{if(a)throw s}}return l}}(e,t)||an(e,t)||pn()}function rs(){if(console&&console.warn){for(var e,t=arguments.length,n=new Array(t),r=0;r<t;r++)n[r]=arguments[r];"string"==typeof n[0]&&(n[0]="react-i18next:: ".concat(n[0])),(e=console).warn.apply(e,n)}}ts.type="languageDetector",ir.use(Ir).use(ts).use(mr).init({fallbackLng:"en",debug:!1,interpolation:{escapeValue:!1},backend:{loadPath:"/locales/{{lng}}/{{ns}}.json"}});var ss={};function ls(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];"string"==typeof t[0]&&ss[t[0]]||("string"==typeof t[0]&&(ss[t[0]]=new Date),rs.apply(void 0,t))}function os(e,t,n){e.loadNamespaces(t,(function(){e.isInitialized?n():e.on("initialized",(function t(){setTimeout((function(){e.off("initialized",t)}),0),n()}))}))}function as(e,t){var n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(!t.languages||!t.languages.length)return ls("i18n.languages were undefined or empty",t.languages),!0;var r=t.languages[0],s=!!t.options&&t.options.fallbackLng,l=t.languages[t.languages.length-1];if("cimode"===r.toLowerCase())return!0;var o=function(e,n){var r=t.services.backendConnector.state["".concat(e,"|").concat(n)];return-1===r||2===r};return!(n.bindI18n&&n.bindI18n.indexOf("languageChanging")>-1&&t.services.backendConnector.backend&&t.isLanguageChangingTo&&!o(t.isLanguageChangingTo,e)||!t.hasResourceBundle(r,e)&&t.services.backendConnector.backend&&(!o(r,e)||s&&!o(l,e)))}function is(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function ps(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?is(Object(n),!0).forEach((function(t){Ae(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):is(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}var us,cs=function(){return cs=Object.assign||function(e){for(var t,n=1,r=arguments.length;n<r;n++)for(var s in t=arguments[n])Object.prototype.hasOwnProperty.call(t,s)&&(e[s]=t[s]);return e},cs.apply(this,arguments)},ds=function(e){var n=e.className,s=function(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},n=t.i18n,s=(0,r.useContext)(fr)||{},l=s.i18n,o=s.defaultNS,a=n||l||vr();if(a&&!a.reportNamespaces&&(a.reportNamespaces=new hr),!a){ls("You will need to pass in an i18next instance by using initReactI18next");var i=function(e){return Array.isArray(e)?e[e.length-1]:e},p=[i,{},!1];return p.t=i,p.i18n={},p.ready=!1,p}a.options.react&&void 0!==a.options.react.wait&&ls("It seems you are still using the old wait option, you may migrate to the new useSuspense behaviour.");var u=ps(ps(ps({},gr()),a.options.react),t),c=u.useSuspense,d=u.keyPrefix,f=e||o||a.options&&a.options.defaultNS;f="string"==typeof f?[f]:f||["translation"],a.reportNamespaces.addUsedNamespaces&&a.reportNamespaces.addUsedNamespaces(f);var g=(a.isInitialized||a.initializedStoreOnce)&&f.every((function(e){return as(e,a,u)}));function h(){return a.getFixedT(null,"fallback"===u.nsMode?f:f[0],d)}var v=ns((0,r.useState)(h),2),m=v[0],y=v[1],b=(0,r.useRef)(!0);(0,r.useEffect)((function(){var e=u.bindI18n,t=u.bindI18nStore;function n(){b.current&&y(h)}return b.current=!0,g||c||os(a,f,(function(){b.current&&y(h)})),e&&a&&a.on(e,n),t&&a&&a.store.on(t,n),function(){b.current=!1,e&&a&&e.split(" ").forEach((function(e){return a.off(e,n)})),t&&a&&t.split(" ").forEach((function(e){return a.store.off(e,n)}))}}),[a,f.join()]);var w=(0,r.useRef)(!0);(0,r.useEffect)((function(){b.current&&!w.current&&y(h),w.current=!1}),[a]);var k=[m,a,g];if(k.t=m,k.i18n=a,k.ready=g,g)return k;if(!g&&!c)return k;throw new Promise((function(e){os(a,f,(function(){e()}))}))}().t;return(0,t.jsxs)("div",cs({className:pt("df00YLS1",{},[n])},{children:[(0,t.jsx)("p",{children:s("Произошла непредвиденная ошибка")},void 0),(0,t.jsx)(gt,cs({onClick:function(){location.reload()}},{children:s("Обновить страницу")}),void 0)]}),void 0)},fs=(us=function(e,t){return us=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,t){e.__proto__=t}||function(e,t){for(var n in t)Object.prototype.hasOwnProperty.call(t,n)&&(e[n]=t[n])},us(e,t)},function(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Class extends value "+String(t)+" is not a constructor or null");function n(){this.constructor=e}us(e,t),e.prototype=null===t?Object.create(t):(n.prototype=t.prototype,new n)}),gs=function(){return gs=Object.assign||function(e){for(var t,n=1,r=arguments.length;n<r;n++)for(var s in t=arguments[n])Object.prototype.hasOwnProperty.call(t,s)&&(e[s]=t[s]);return e},gs.apply(this,arguments)};const hs=function(e){function n(t){var n=e.call(this,t)||this;return n.state={hasError:!1},n}return fs(n,e),n.getDerivedStateFromError=function(e){return{hasError:!0}},n.prototype.componentDidCatch=function(e,t){console.log(e,t)},n.prototype.render=function(){var e=this.state.hasError,n=this.props.children;return e?(0,t.jsx)(r.Suspense,gs({fallback:""},{children:(0,t.jsx)(ds,{},void 0)}),void 0):n},n}(r.Component);(0,n.render)((0,t.jsx)((function(e){var n=e.children,r=function(e,t){var n,r,s,l=Et(Et({},t),{counter:at,user:jt}),o=(n=St({},l),r=Me(n),s=[],{getReducerMap:function(){return n},reduce:function(e,t){return s.length>0&&(e=St({},e),s.forEach((function(t){delete e[t]})),s=[]),r(e,t)},add:function(e,t){e&&!n[e]&&(n[e]=t,r=Me(n))},remove:function(e){e&&n[e]&&(delete n[e],s.push(e),r=Me(n))}}),a=tt({reducer:o.reduce,devTools:!1,preloadedState:e});return a.reducerManager=o,a}(e.initialState,e.asyncReducers);return(0,t.jsx)(S,Ot({store:r},{children:n}),void 0)}),{children:(0,t.jsx)((function(t){let{basename:n,children:s,window:u}=t,c=(0,r.useRef)();null==c.current&&(c.current=function(t){void 0===t&&(t={});var n=t.window,r=void 0===n?document.defaultView:n,s=r.history;function u(){var e=r.location,t=e.pathname,n=e.search,l=e.hash,o=s.state||{};return[o.idx,{pathname:t,search:n,hash:l,state:o.usr||null,key:o.key||"default"}]}var c=null;r.addEventListener("popstate",(function(){if(c)m.call(c),c=null;else{var t=e.Pop,n=u(),r=n[0],s=n[1];if(m.length){if(null!=r){var l=g-r;l&&(c={action:t,location:s,retry:function(){j(-1*l)}},j(l))}}else x(t)}}));var d=e.Pop,f=u(),g=f[0],h=f[1],v=i(),m=i();function y(e){return"string"==typeof e?e:function(e){var t=e.pathname,n=void 0===t?"/":t,r=e.search,s=void 0===r?"":r,l=e.hash,o=void 0===l?"":l;return s&&"?"!==s&&(n+="?"===s.charAt(0)?s:"?"+s),o&&"#"!==o&&(n+="#"===o.charAt(0)?o:"#"+o),n}(e)}function b(e,t){return void 0===t&&(t=null),l({pathname:h.pathname,hash:"",search:""},"string"==typeof e?p(e):e,{state:t,key:Math.random().toString(36).substr(2,8)})}function w(e,t){return[{usr:e.state,key:e.key,idx:t},y(e)]}function k(e,t,n){return!m.length||(m.call({action:e,location:t,retry:n}),!1)}function x(e){d=e;var t=u();g=t[0],h=t[1],v.call({action:d,location:h})}function j(e){s.go(e)}null==g&&(g=0,s.replaceState(l({},s.state,{idx:g}),""));var S={get action(){return d},get location(){return h},createHref:y,push:function t(n,l){var o=e.Push,a=b(n,l);if(k(o,a,(function(){t(n,l)}))){var i=w(a,g+1),p=i[0],u=i[1];try{s.pushState(p,"",u)}catch(e){r.location.assign(u)}x(o)}},replace:function t(n,r){var l=e.Replace,o=b(n,r);if(k(l,o,(function(){t(n,r)}))){var a=w(o,g),i=a[0],p=a[1];s.replaceState(i,"",p),x(l)}},go:j,back:function(){j(-1)},forward:function(){j(1)},listen:function(e){return v.push(e)},block:function(e){var t=m.push(e);return 1===m.length&&r.addEventListener(o,a),function(){t(),m.length||r.removeEventListener(o,a)}}};return S}({window:u}));let f=c.current,[g,h]=(0,r.useState)({action:f.action,location:f.location});return(0,r.useLayoutEffect)((()=>f.listen(h)),[f]),(0,r.createElement)(d,{basename:n,children:s,location:g.location,navigationType:g.action,navigator:f})}),{children:(0,t.jsx)(hs,{children:(0,t.jsx)((function(e){var n=e.initialTheme,s=e.children,l=(0,r.useState)(n||y),o=l[0],a=l[1],i=(0,r.useMemo)((function(){return{theme:o,setTheme:a}}),[o]);return(0,t.jsx)(h.Provider,m({value:i},{children:s}),void 0)}),{children:(0,t.jsx)((function(){var e;e=(0,r.useContext)(h),e.theme,e.setTheme;var n=_();return(0,r.useEffect)((function(){n(xt.initAuthData())}),[n]),(0,t.jsx)(Yt,{},void 0)}),{},void 0)},void 0)},void 0)},void 0)},void 0),document.getElementById("root"))})()})();